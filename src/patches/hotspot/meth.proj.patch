diff --git a/src/share/projects/meth/README.txt b/src/share/projects/meth/README.txt
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/README.txt
@@ -0,0 +1,203 @@
+Standalone NetBeans project of JSR 292 RI
+
+(Not yet merged with the JDK; use -Xbootclasspath.)
+
+To open:
+  open -a netbeans .  # Open Project => select this directory
+
+To build:
+  cd .; ant clean compile run
+
+To run a unit test (requires modified JVM):
+  #NetBeansResources=$(find /Applications/NetBeans* -type d -name Resources | tail -1)
+  #NetBeansResources="/Applications/NetBeans/NetBeans 6.1.app/Contents/Resources"
+  #junit="$NetBeansResources/NetBeans/java2/modules/ext/junit-3.8.2.jar"
+  export junit=$HOME/env/jars/junit-4.1.jar  #(or wherever you have it stashed)
+  export mhproj="$HOME/Projects/MethodHandle"  #(pwd -P)
+  export acproj="$HOME/Projects/AnonymousClass"  #(cd ../AnonymousClass; pwd -P)
+  export cpath="$acproj/dist/AnonymousClass.jar:$mhproj/build/classes:$mhproj/build/test/classes:$junit"
+  gamma -XX:+EnableMethodHandles -Xbootclasspath/p:"$cpath" jdk.java.dyn.MethodHandleBytecodeTest
+
+Simpler MH demo:
+  gamma -XX:+EnableMethodHandles -Xbootclasspath/p:"$cpath" jdk.java.dyn.MethodHandleDemo
+
+Simpler invokedynamic demo:
+  gamma -XX:+EnableInvokeDynamic -Xbootclasspath/p:"$cpath" jdk.java.dyn.Hello Moe Larry Curly
+
+Using JUnit 4:
+  gamma -XX:+EnableMethodHandles -Xbootclasspath/p:"$cpath" org.junit.runner.JUnitCore jdk.java.dyn.MethodHandlesTest
+
+Current output:
+
+-------- -------- -------- --------
+VM option '+EnableMethodHandles'
+JUnit version 4.1
+.findStatic
+findStatic class jdk.java.dyn.MethodHandlesTest$Example.s0/()void => jdk.java.dyn.MethodHandlesTest$Example.s0()void
+calling [s0, []] on jdk.java.dyn.MethodHandlesTest$Example.s0()void
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L0/11502424@d80be3
+:findStatic class jdk.java.dyn.MethodHandlesTest$Example.pkg_s0/()void => jdk.java.dyn.MethodHandlesTest$Example.pkg_s0()void
+calling [pkg_s0, []] on jdk.java.dyn.MethodHandlesTest$Example.pkg_s0()void
+:findStatic class jdk.java.dyn.MethodHandlesTest$Example.pri_s0/()void => jdk.java.dyn.MethodHandlesTest$Example.pri_s0()void
+calling [pri_s0, []] on jdk.java.dyn.MethodHandlesTest$Example.pri_s0()void
+:findStatic class jdk.java.dyn.MethodHandlesTest$Example.s1/(java.lang.Object)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.s1(java.lang.Object)java.lang.Object
+calling [s1, [#1000000]] on jdk.java.dyn.MethodHandlesTest$Example.s1(java.lang.Object)java.lang.Object
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L1/26083064@15e83f9
+:findStatic class jdk.java.dyn.MethodHandlesTest$Example.s2/(int)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.s2(int)java.lang.Object
+calling [s2, [1000001]] on jdk.java.dyn.MethodHandlesTest$Example.s2(int)java.lang.Object
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L1/31149935@13c1b02
+:findStatic class jdk.java.dyn.MethodHandlesTest$Example.bogus/()void => null !! java.dyn.NoAccessException: cannot access: jdk.java.dyn.MethodHandlesTest$Example.bogus()void, from jdk.java.dyn.MethodHandlesTest$Example
+.findVirtual
+findVirtual class jdk.java.dyn.MethodHandlesTest$Example.v0/()void => jdk.java.dyn.MethodHandlesTest$Example.v0()void
+calling [v0, [Example#1000002]] on jdk.java.dyn.MethodHandlesTest$Example.v0()void
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L1/14867177@19209ea
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.pkg_v0/()void => jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void
+calling [pkg_v0, [Example#1000003]] on jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.pri_v0/()void => jdk.java.dyn.MethodHandlesTest$Example.pri_v0()void
+calling [pri_v0, [Example#1000004]] on jdk.java.dyn.MethodHandlesTest$Example.pri_v0()void
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.v1/(java.lang.Object)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v1(java.lang.Object)java.lang.Object
+calling [v1, [Example#1000005, #1000006]] on jdk.java.dyn.MethodHandlesTest$Example.v1(java.lang.Object)java.lang.Object
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L2/18820833@3ecfff
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.v2/(java.lang.Object,java.lang.Object)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,java.lang.Object)java.lang.Object
+calling [v2, [Example#1000007, #1000008, #1000009]] on jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,java.lang.Object)java.lang.Object
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L3/10883428@bfc8e0
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.v2/(java.lang.Object,int)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,int)java.lang.Object
+calling [v2, [Example#1000010, #1000011, 1000012]] on jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,int)java.lang.Object
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L3/597230@4a63d8
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.v2/(int,java.lang.Object)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v2(int,java.lang.Object)java.lang.Object
+calling [v2, [Example#1000013, 1000014, #1000015]] on jdk.java.dyn.MethodHandlesTest$Example.v2(int,java.lang.Object)java.lang.Object
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L3/22201561@f99ff5
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.v2/(int,int)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v2(int,int)java.lang.Object
+calling [v2, [Example#1000016, 1000017, 1000018]] on jdk.java.dyn.MethodHandlesTest$Example.v2(int,int)java.lang.Object
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L3/13783459@1edc073
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.bogus/()void => null !! java.dyn.NoAccessException: cannot access: jdk.java.dyn.MethodHandlesTest$Example.bogus()void, from jdk.java.dyn.MethodHandlesTest
+findVirtual class jdk.java.dyn.MethodHandlesTest$SubExample.Sub/v0/()void => jdk.java.dyn.MethodHandlesTest$SubExample.v0()void
+calling [Sub/v0, [SubExample#1000019]] on jdk.java.dyn.MethodHandlesTest$SubExample.v0()void
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L1/9502784@1a786c3
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.Sub/v0/()void => jdk.java.dyn.MethodHandlesTest$Example.v0()void
+calling [Sub/v0, [SubExample#1000021]] on jdk.java.dyn.MethodHandlesTest$Example.v0()void
+:findVirtual interface jdk.java.dyn.MethodHandlesTest$IntExample.Sub/v0/()void => jdk.java.dyn.MethodHandlesTest$IntExample.v0()void
+calling [Sub/v0, [SubExample#1000023]] on jdk.java.dyn.MethodHandlesTest$IntExample.v0()void
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L1/20111677@1617189
+:findVirtual class jdk.java.dyn.MethodHandlesTest$SubExample.Sub/pkg_v0/()void => jdk.java.dyn.MethodHandlesTest$SubExample.pkg_v0()void
+calling [Sub/pkg_v0, [SubExample#1000024]] on jdk.java.dyn.MethodHandlesTest$SubExample.pkg_v0()void
+:findVirtual class jdk.java.dyn.MethodHandlesTest$Example.Sub/pkg_v0/()void => jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void
+calling [Sub/pkg_v0, [SubExample#1000026]] on jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void
+:findVirtual interface jdk.java.dyn.MethodHandlesTest$IntExample.v0/()void => jdk.java.dyn.MethodHandlesTest$IntExample.v0()void
+calling [v0, [Example#1000028]] on jdk.java.dyn.MethodHandlesTest$IntExample.v0()void
+:findVirtual interface jdk.java.dyn.MethodHandlesTest$IntExample.Int/v0/()void => jdk.java.dyn.MethodHandlesTest$IntExample.v0()void
+calling [Int/v0, [jdk.java.dyn.MethodHandlesTest$IntExample$Impl@2bb514]] on jdk.java.dyn.MethodHandlesTest$IntExample.v0()void
+:.findSpecial
+findSpecial class jdk.java.dyn.MethodHandlesTest$Example.v0/()void => jdk.java.dyn.MethodHandlesTest$Example.v0()void
+calling [v0, [Example#1000031]] on jdk.java.dyn.MethodHandlesTest$Example.v0()void
+:findSpecial class jdk.java.dyn.MethodHandlesTest$Example.pkg_v0/()void => jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void
+calling [pkg_v0, [Example#1000032]] on jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void
+:findSpecial class jdk.java.dyn.MethodHandlesTest$SubExample.<init>/(int)void => jdk.java.dyn.MethodHandlesTest$SubExample.<init>(int)void
+calling [<init>, [SubExample#1000033, 1000034]] on jdk.java.dyn.MethodHandlesTest$SubExample.<init>(int)void
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L2/26335425@2d9c06
+:findSpecial class jdk.java.dyn.MethodHandlesTest$Example.<init>/(int)void => null !! java.dyn.NoAccessException: constructor must be local to caller: jdk.java.dyn.MethodHandlesTest$Example.<init>(int)void, from jdk.java.dyn.MethodHandlesTest$SubExample
+findSpecial class jdk.java.dyn.MethodHandlesTest$Example.bogus/()void => null !! java.dyn.NoAccessException: cannot access: jdk.java.dyn.MethodHandlesTest$Example.bogus()void, from jdk.java.dyn.MethodHandlesTest$SubExample
+.bind
+init BMH type=()void argnum=0 vmargslot=0
+bind Example#1000036.v0/()void => Bound[jdk.java.dyn.MethodHandlesTest$Example.v0()void]
+calling [v0, []] on Bound[jdk.java.dyn.MethodHandlesTest$Example.v0()void]
+:init BMH type=()void argnum=0 vmargslot=0
+bind Example#1000037.pkg_v0/()void => Bound[jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void]
+calling [pkg_v0, []] on Bound[jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void]
+:init BMH type=()void argnum=0 vmargslot=0
+bind Example#1000038.pri_v0/()void => Bound[jdk.java.dyn.MethodHandlesTest$Example.pri_v0()void]
+calling [pri_v0, []] on Bound[jdk.java.dyn.MethodHandlesTest$Example.pri_v0()void]
+:init BMH type=(java.lang.Object)java.lang.Object argnum=0 vmargslot=1
+bind Example#1000039.v1/(java.lang.Object)java.lang.Object => Bound[jdk.java.dyn.MethodHandlesTest$Example.v1(java.lang.Object)java.lang.Object]
+calling [v1, [#1000040]] on Bound[jdk.java.dyn.MethodHandlesTest$Example.v1(java.lang.Object)java.lang.Object]
+:init BMH type=(java.lang.Object,java.lang.Object)java.lang.Object argnum=0 vmargslot=2
+bind Example#1000041.v2/(java.lang.Object,java.lang.Object)java.lang.Object => Bound[jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,java.lang.Object)java.lang.Object]
+calling [v2, [#1000042, #1000043]] on Bound[jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,java.lang.Object)java.lang.Object]
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L2/32392776@482923
+:init BMH type=(java.lang.Object,int)java.lang.Object argnum=0 vmargslot=2
+bind Example#1000044.v2/(java.lang.Object,int)java.lang.Object => Bound[jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,int)java.lang.Object]
+calling [v2, [#1000045, 1000046]] on Bound[jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,int)java.lang.Object]
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L2/10053659@181edf4
+:init BMH type=(int,java.lang.Object)java.lang.Object argnum=0 vmargslot=2
+bind Example#1000047.v2/(int,java.lang.Object)java.lang.Object => Bound[jdk.java.dyn.MethodHandlesTest$Example.v2(int,java.lang.Object)java.lang.Object]
+calling [v2, [1000048, #1000049]] on Bound[jdk.java.dyn.MethodHandlesTest$Example.v2(int,java.lang.Object)java.lang.Object]
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L2/1760304@16df84b
+:init BMH type=(int,int)java.lang.Object argnum=0 vmargslot=2
+bind Example#1000050.v2/(int,int)java.lang.Object => Bound[jdk.java.dyn.MethodHandlesTest$Example.v2(int,int)java.lang.Object]
+calling [v2, [1000051, 1000052]] on Bound[jdk.java.dyn.MethodHandlesTest$Example.v2(int,int)java.lang.Object]
+new invoker: impl.java.dyn.util.MethodHandleInvoker$L2/27940859@763f5d
+:bind Example#1000053.bogus/()void => null !! java.dyn.NoAccessException: cannot access: jdk.java.dyn.MethodHandlesTest$Example.bogus()void, from jdk.java.dyn.MethodHandlesTest
+init BMH type=()void argnum=0 vmargslot=0
+bind SubExample#1000054.Sub/v0/()void => Bound[jdk.java.dyn.MethodHandlesTest$SubExample.v0()void]
+calling [Sub/v0, []] on Bound[jdk.java.dyn.MethodHandlesTest$SubExample.v0()void]
+:init BMH type=()void argnum=0 vmargslot=0
+bind SubExample#1000055.Sub/pkg_v0/()void => Bound[jdk.java.dyn.MethodHandlesTest$SubExample.pkg_v0()void]
+calling [Sub/pkg_v0, []] on Bound[jdk.java.dyn.MethodHandlesTest$SubExample.pkg_v0()void]
+:init BMH type=()void argnum=0 vmargslot=0
+bind jdk.java.dyn.MethodHandlesTest$IntExample$Impl@13a317a.Int/v0/()void => Bound[jdk.java.dyn.MethodHandlesTest$IntExample$Impl.v0()void]
+calling [Int/v0, []] on Bound[jdk.java.dyn.MethodHandlesTest$IntExample$Impl.v0()void]
+:.unreflect
+unreflect class jdk.java.dyn.MethodHandlesTest$Example.s0/()void => jdk.java.dyn.MethodHandlesTest$Example.s0()void
+calling [s0, []] on jdk.java.dyn.MethodHandlesTest$Example.s0()void
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.pkg_s0/()void => jdk.java.dyn.MethodHandlesTest$Example.pkg_s0()void
+calling [pkg_s0, []] on jdk.java.dyn.MethodHandlesTest$Example.pkg_s0()void
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.pri_s0/()void => jdk.java.dyn.MethodHandlesTest$Example.pri_s0()void
+calling [pri_s0, []] on jdk.java.dyn.MethodHandlesTest$Example.pri_s0()void
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.s1/(java.lang.Object)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.s1(java.lang.Object)java.lang.Object
+calling [s1, [#1000057]] on jdk.java.dyn.MethodHandlesTest$Example.s1(java.lang.Object)java.lang.Object
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.s2/(int)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.s2(int)java.lang.Object
+calling [s2, [1000058]] on jdk.java.dyn.MethodHandlesTest$Example.s2(int)java.lang.Object
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.v0/()void => jdk.java.dyn.MethodHandlesTest$Example.v0()void
+calling [v0, [Example#1000059]] on jdk.java.dyn.MethodHandlesTest$Example.v0()void
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.pkg_v0/()void => jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void
+calling [pkg_v0, [Example#1000060]] on jdk.java.dyn.MethodHandlesTest$Example.pkg_v0()void
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.pri_v0/()void => jdk.java.dyn.MethodHandlesTest$Example.pri_v0()void
+calling [pri_v0, [Example#1000061]] on jdk.java.dyn.MethodHandlesTest$Example.pri_v0()void
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.v1/(java.lang.Object)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v1(java.lang.Object)java.lang.Object
+calling [v1, [Example#1000062, #1000063]] on jdk.java.dyn.MethodHandlesTest$Example.v1(java.lang.Object)java.lang.Object
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.v2/(java.lang.Object,java.lang.Object)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,java.lang.Object)java.lang.Object
+calling [v2, [Example#1000064, #1000065, #1000066]] on jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,java.lang.Object)java.lang.Object
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.v2/(java.lang.Object,int)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,int)java.lang.Object
+calling [v2, [Example#1000067, #1000068, 1000069]] on jdk.java.dyn.MethodHandlesTest$Example.v2(java.lang.Object,int)java.lang.Object
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.v2/(int,java.lang.Object)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v2(int,java.lang.Object)java.lang.Object
+calling [v2, [Example#1000070, 1000071, #1000072]] on jdk.java.dyn.MethodHandlesTest$Example.v2(int,java.lang.Object)java.lang.Object
+:unreflect class jdk.java.dyn.MethodHandlesTest$Example.v2/(int,int)java.lang.Object => jdk.java.dyn.MethodHandlesTest$Example.v2(int,int)java.lang.Object
+calling [v2, [Example#1000073, 1000074, 1000075]] on jdk.java.dyn.MethodHandlesTest$Example.v2(int,int)java.lang.Object
+:IIIII.convertArguments/pairwise
+convert jdk.java.dyn.MethodHandlesTest$Callee.id(java.lang.Object)java.lang.Object to (java.lang.String)java.lang.Object => null !! java.lang.UnsupportedOperationException: Not yet implemented
+EIIIIIIII
+Time: 2.544
+There was 1 failure:
+1) testConvertArguments_pairwise(jdk.java.dyn.MethodHandlesTest)
+java.lang.UnsupportedOperationException: Not yet implemented
+	at impl.java.dyn.MethodHandleImpl.convertArguments(MethodHandleImpl.java:185)
+	at java.dyn.MethodHandles.convertArguments(MethodHandles.java:565)
+	at jdk.java.dyn.MethodHandlesTest.testConvert(MethodHandlesTest.java:521)
+	at jdk.java.dyn.MethodHandlesTest.testConvert(MethodHandlesTest.java:508)
+	at jdk.java.dyn.MethodHandlesTest.testConvertArguments_pairwise(MethodHandlesTest.java:501)
+	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
+	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
+	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
+	at java.lang.reflect.Method.invoke(Method.java:597)
+	at org.junit.internal.runners.TestMethodRunner.executeMethodBody(TestMethodRunner.java:99)
+	at org.junit.internal.runners.TestMethodRunner.runUnprotected(TestMethodRunner.java:81)
+	at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)
+	at org.junit.internal.runners.TestMethodRunner.runMethod(TestMethodRunner.java:75)
+	at org.junit.internal.runners.TestMethodRunner.run(TestMethodRunner.java:45)
+	at org.junit.internal.runners.TestClassMethodsRunner.invokeTestMethod(TestClassMethodsRunner.java:71)
+	at org.junit.internal.runners.TestClassMethodsRunner.run(TestClassMethodsRunner.java:35)
+	at org.junit.internal.runners.TestClassRunner$1.runUnprotected(TestClassRunner.java:42)
+	at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)
+	at org.junit.internal.runners.TestClassRunner.run(TestClassRunner.java:52)
+	at org.junit.internal.runners.CompositeRunner.run(CompositeRunner.java:29)
+	at org.junit.runner.JUnitCore.run(JUnitCore.java:121)
+	at org.junit.runner.JUnitCore.run(JUnitCore.java:100)
+	at org.junit.runner.JUnitCore.run(JUnitCore.java:91)
+	at org.junit.runner.JUnitCore.runMain(JUnitCore.java:75)
+	at org.junit.runner.JUnitCore.main(JUnitCore.java:42)
+
+FAILURES!!!
+Tests run: 6,  Failures: 1
+
+
+-------- -------- -------- --------
diff --git a/src/share/projects/meth/TEST.sh b/src/share/projects/meth/TEST.sh
new file mode 100755
--- /dev/null
+++ b/src/share/projects/meth/TEST.sh
@@ -0,0 +1,11 @@
+#! /bin/ksh
+#NetBeansResources=$(find /Applications/NetBeans* -type d -name Resources | tail -1)
+#NetBeansResources="/Applications/NetBeans/NetBeans 6.1.app/Contents/Resources"
+#junit="$NetBeansResources/NetBeans/java2/modules/ext/junit-3.8.2.jar"
+#export junit=$HOME/env/jars/junit-3.8.2.jar
+export junit=$HOME/env/jars/junit-4.1.jar
+export akproj="$HOME/Projects/AnonymousClass"
+export mhproj="$HOME/Projects/MethodHandle"
+export cpath="$mhproj/build/classes:$mhproj/build/test/classes:$junit:$akproj/build/classes:"
+java -XX:+EnableMethodHandles -Xbootclasspath/p:"$cpath" jdk.java.dyn.MethodHandleDemo
+java -XX:+MethodHandles -Xbootclasspath/p:"$cpath" org.junit.runner.JUnitCore jdk.java.dyn.MethodHandlesTest
\ No newline at end of file
diff --git a/src/share/projects/meth/build.xml b/src/share/projects/meth/build.xml
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/build.xml
@@ -0,0 +1,110 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- You may freely edit this file. See commented blocks below for -->
+<!-- some examples of how to customize the build. -->
+<!-- (If you delete it and reopen the project it will be recreated.) -->
+<project name="MethodHandle" default="default" basedir=".">
+    <description>Builds, tests, and runs the project MethodHandle.</description>
+    <import file="nbproject/build-impl.xml"/>
+
+    <property name="javadoc.includes" value="java/dyn/*.java"/>
+
+    <!--- copy dependency class files straight into the output JAR -->
+    <target name="-post-jar" if="reference.AnonymousClass.jar">
+        <jar destfile="${dist.jar}"
+	     update="true" compress="true">
+            <zipfileset src="${reference.AnonymousClass.jar}"/>
+        </jar>
+    </target>
+
+    <!--- build a bundle of the tests -->
+    <target name="-post-compile-test">
+        <echo message="make build/test-classes.jar from ${build.test.classes.dir}"/>
+        <jar compress="${jar.compress}" jarfile="${build.dir}/test-classes.jar">
+            <fileset dir="${build.test.classes.dir}"/>
+        </jar>
+    </target>
+
+    <target depends="init" name="-javadoc-build">
+        <mkdir dir="${dist.javadoc.dir}"/>
+        <javadoc additionalparam="${javadoc.additionalparam}" author="${javadoc.author}" charset="UTF-8" destdir="${dist.javadoc.dir}" docencoding="UTF-8" encoding="${javadoc.encoding.used}" executable="${platform.javadoc}" failonerror="true" noindex="${javadoc.noindex}" nonavbar="${javadoc.nonavbar}" notree="${javadoc.notree}" private="${javadoc.private}" source="${javac.source}" splitindex="${javadoc.splitindex}" use="${javadoc.use}" useexternalfile="true" version="${javadoc.version}" windowtitle="${javadoc.windowtitle}"
+         verbose="yes"
+         public="yes"
+         >
+            <classpath>
+                <path path="${javac.classpath}"/>
+            </classpath>
+            <fileset dir="${src.src.dir}" excludes="${excludes}" includes="${javadoc.includes}">
+                <filename name="**/*.java"/>
+            </fileset>
+        </javadoc>
+    </target>
+
+
+    <!--
+
+    There exist several targets which are by default empty and which can be 
+    used for execution of your tasks. These targets are usually executed 
+    before and after some main targets. They are: 
+
+      -pre-init:                 called before initialization of project properties
+      -post-init:                called after initialization of project properties
+      -pre-compile:              called before javac compilation
+      -post-compile:             called after javac compilation
+      -pre-compile-single:       called before javac compilation of single file
+      -post-compile-single:      called after javac compilation of single file
+      -pre-compile-test:         called before javac compilation of JUnit tests
+      -post-compile-test:        called after javac compilation of JUnit tests
+      -pre-compile-test-single:  called before javac compilation of single JUnit test
+      -post-compile-test-single: called after javac compilation of single JUunit test
+      -pre-jar:                  called before JAR building
+      -post-jar:                 called after JAR building
+      -post-clean:               called after cleaning build products
+
+    (Targets beginning with '-' are not intended to be called on their own.)
+
+    Example of inserting an obfuscator after compilation could look like this:
+
+        <target name="-post-compile">
+            <obfuscate>
+                <fileset dir="${build.classes.dir}"/>
+            </obfuscate>
+        </target>
+
+    For list of available properties check the imported 
+    nbproject/build-impl.xml file. 
+
+
+    Another way to customize the build is by overriding existing main targets.
+    The targets of interest are: 
+
+      -init-macrodef-javac:     defines macro for javac compilation
+      -init-macrodef-junit:     defines macro for junit execution
+      -init-macrodef-debug:     defines macro for class debugging
+      -init-macrodef-java:      defines macro for class execution
+      -do-jar-with-manifest:    JAR building (if you are using a manifest)
+      -do-jar-without-manifest: JAR building (if you are not using a manifest)
+      run:                      execution of project 
+      -javadoc-build:           Javadoc generation
+      test-report:              JUnit report generation
+
+    An example of overriding the target for project execution could look like this:
+
+        <target name="run" depends="MethodHandle-impl.jar">
+            <exec dir="bin" executable="launcher.exe">
+                <arg file="${dist.jar}"/>
+            </exec>
+        </target>
+
+    Notice that the overridden target depends on the jar target and not only on 
+    the compile target as the regular run target does. Again, for a list of available 
+    properties which you can use, check the target you are overriding in the
+    nbproject/build-impl.xml file. 
+
+    -->
+
+<!--- hack to print props -->
+    <target depends="init" name="show-config">
+        <echoproperties regex="^(run|platform|config)(\.|$)"/>
+    </target>
+
+</project>
diff --git a/src/share/projects/meth/nbproject/build-impl.xml b/src/share/projects/meth/nbproject/build-impl.xml
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/nbproject/build-impl.xml
@@ -0,0 +1,684 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+*** GENERATED FROM project.xml - DO NOT EDIT  ***
+***         EDIT ../build.xml INSTEAD         ***
+
+For the purpose of easier reading the script
+is divided into following sections:
+
+  - initialization
+  - compilation
+  - jar
+  - execution
+  - debugging
+  - javadoc
+  - junit compilation
+  - junit execution
+  - junit debugging
+  - applet
+  - cleanup
+
+        -->
+<project xmlns:j2seproject1="http://www.netbeans.org/ns/j2se-project/1" xmlns:j2seproject3="http://www.netbeans.org/ns/j2se-project/3" xmlns:jaxrpc="http://www.netbeans.org/ns/j2se-project/jax-rpc" basedir=".." default="default" name="MethodHandle-impl">
+    <target depends="test,jar,javadoc" description="Build and test whole project." name="default"/>
+    <!-- 
+                ======================
+                INITIALIZATION SECTION 
+                ======================
+            -->
+    <target name="-pre-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="-pre-init" name="-init-private">
+        <property file="nbproject/private/config.properties"/>
+        <property file="nbproject/private/configs/${config}.properties"/>
+        <property file="nbproject/private/private.properties"/>
+    </target>
+    <target depends="-pre-init,-init-private" name="-init-user">
+        <property file="${user.properties.file}"/>
+        <!-- The two properties below are usually overridden -->
+        <!-- by the active platform. Just a fallback. -->
+        <property name="default.javac.source" value="1.4"/>
+        <property name="default.javac.target" value="1.4"/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user" name="-init-project">
+        <property file="nbproject/configs/${config}.properties"/>
+        <property file="nbproject/project.properties"/>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-init-macrodef-property" name="-do-init">
+        <j2seproject1:property name="platform.home" value="platforms.${platform.active}.home"/>
+        <j2seproject1:property name="platform.bootcp" value="platforms.${platform.active}.bootclasspath"/>
+        <j2seproject1:property name="platform.compiler" value="platforms.${platform.active}.compile"/>
+        <j2seproject1:property name="platform.javac.tmp" value="platforms.${platform.active}.javac"/>
+        <condition property="platform.javac" value="${platform.home}/bin/javac">
+            <equals arg1="${platform.javac.tmp}" arg2="$${platforms.${platform.active}.javac}"/>
+        </condition>
+        <property name="platform.javac" value="${platform.javac.tmp}"/>
+        <j2seproject1:property name="platform.java.tmp" value="platforms.${platform.active}.java"/>
+        <condition property="platform.java" value="${platform.home}/bin/java">
+            <equals arg1="${platform.java.tmp}" arg2="$${platforms.${platform.active}.java}"/>
+        </condition>
+        <property name="platform.java" value="${platform.java.tmp}"/>
+        <j2seproject1:property name="platform.javadoc.tmp" value="platforms.${platform.active}.javadoc"/>
+        <condition property="platform.javadoc" value="${platform.home}/bin/javadoc">
+            <equals arg1="${platform.javadoc.tmp}" arg2="$${platforms.${platform.active}.javadoc}"/>
+        </condition>
+        <property name="platform.javadoc" value="${platform.javadoc.tmp}"/>
+        <condition property="platform.invalid" value="true">
+            <or>
+                <contains string="${platform.javac}" substring="$${platforms."/>
+                <contains string="${platform.java}" substring="$${platforms."/>
+                <contains string="${platform.javadoc}" substring="$${platforms."/>
+            </or>
+        </condition>
+        <fail unless="platform.home">Must set platform.home</fail>
+        <fail unless="platform.bootcp">Must set platform.bootcp</fail>
+        <fail unless="platform.java">Must set platform.java</fail>
+        <fail unless="platform.javac">Must set platform.javac</fail>
+        <fail if="platform.invalid">
+ The J2SE Platform is not correctly set up.
+ Your active platform is: ${platform.active}, but the corresponding property "platforms.${platform.active}.home" is not found in the project's properties files. 
+ Either open the project in the IDE and setup the Platform with the same name or add it manually.
+ For example like this:
+     ant -Duser.properties.file=&lt;path_to_property_file&gt; jar (where you put the property "platforms.${platform.active}.home" in a .properties file)
+  or ant -Dplatforms.${platform.active}.home=&lt;path_to_JDK_home&gt; jar (where no properties file is used) 
+  </fail>
+        <available file="${manifest.file}" property="manifest.available"/>
+        <condition property="manifest.available+main.class">
+            <and>
+                <isset property="manifest.available"/>
+                <isset property="main.class"/>
+                <not>
+                    <equals arg1="${main.class}" arg2="" trim="true"/>
+                </not>
+            </and>
+        </condition>
+        <condition property="manifest.available+main.class+mkdist.available">
+            <and>
+                <istrue value="${manifest.available+main.class}"/>
+                <isset property="libs.CopyLibs.classpath"/>
+            </and>
+        </condition>
+        <condition property="have.tests">
+            <or>
+                <available file="${test.src.dir}"/>
+            </or>
+        </condition>
+        <condition property="have.sources">
+            <or>
+                <available file="${src.src.dir}"/>
+            </or>
+        </condition>
+        <condition property="netbeans.home+have.tests">
+            <and>
+                <isset property="netbeans.home"/>
+                <isset property="have.tests"/>
+            </and>
+        </condition>
+        <condition property="no.javadoc.preview">
+            <and>
+                <isset property="javadoc.preview"/>
+                <isfalse value="${javadoc.preview}"/>
+            </and>
+        </condition>
+        <property name="run.jvmargs" value=""/>
+        <property name="javac.compilerargs" value=""/>
+        <property name="work.dir" value="${basedir}"/>
+        <condition property="no.deps">
+            <and>
+                <istrue value="${no.dependencies}"/>
+            </and>
+        </condition>
+        <property name="javac.debug" value="true"/>
+        <property name="javadoc.preview" value="true"/>
+        <property name="application.args" value=""/>
+        <property name="source.encoding" value="${file.encoding}"/>
+        <condition property="javadoc.encoding.used" value="${javadoc.encoding}">
+            <and>
+                <isset property="javadoc.encoding"/>
+                <not>
+                    <equals arg1="${javadoc.encoding}" arg2=""/>
+                </not>
+            </and>
+        </condition>
+        <property name="javadoc.encoding.used" value="${source.encoding}"/>
+        <property name="includes" value="**"/>
+        <property name="excludes" value=""/>
+        <property name="do.depend" value="false"/>
+        <condition property="do.depend.true">
+            <istrue value="${do.depend}"/>
+        </condition>
+        <condition else="" property="javac.compilerargs.jaxws" value="-Djava.endorsed.dirs='${jaxws.endorsed.dir}'">
+            <and>
+                <isset property="jaxws.endorsed.dir"/>
+                <available file="nbproject/jaxws-build.xml"/>
+            </and>
+        </condition>
+    </target>
+    <target name="-post-init">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-do-init" name="-init-check">
+        <fail unless="src.src.dir">Must set src.src.dir</fail>
+        <fail unless="test.src.dir">Must set test.src.dir</fail>
+        <fail unless="build.dir">Must set build.dir</fail>
+        <fail unless="dist.dir">Must set dist.dir</fail>
+        <fail unless="build.classes.dir">Must set build.classes.dir</fail>
+        <fail unless="dist.javadoc.dir">Must set dist.javadoc.dir</fail>
+        <fail unless="build.test.classes.dir">Must set build.test.classes.dir</fail>
+        <fail unless="build.test.results.dir">Must set build.test.results.dir</fail>
+        <fail unless="build.classes.excludes">Must set build.classes.excludes</fail>
+        <fail unless="dist.jar">Must set dist.jar</fail>
+    </target>
+    <target name="-init-macrodef-property">
+        <macrodef name="property" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute name="name"/>
+            <attribute name="value"/>
+            <sequential>
+                <property name="@{name}" value="${@{value}}"/>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-javac">
+        <macrodef name="javac" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.src.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="${javac.debug}" name="debug"/>
+            <attribute default="/does/not/exist" name="sourcepath"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <javac debug="@{debug}" deprecation="${javac.deprecation}" destdir="@{destdir}" encoding="${source.encoding}" excludes="@{excludes}" executable="${platform.javac}" fork="yes" includeantruntime="false" includes="@{includes}" source="${javac.source}" sourcepath="@{sourcepath}" srcdir="@{srcdir}" target="${javac.target}" tempdir="${java.io.tmpdir}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <compilerarg line="${javac.compilerargs} ${javac.compilerargs.jaxws}"/>
+                    <customize/>
+                </javac>
+            </sequential>
+        </macrodef>
+        <macrodef name="depend" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${src.src.dir}" name="srcdir"/>
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <attribute default="${javac.classpath}" name="classpath"/>
+            <sequential>
+                <depend cache="${build.dir}/depcache" destdir="@{destdir}" excludes="${excludes}" includes="${includes}" srcdir="@{srcdir}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                </depend>
+            </sequential>
+        </macrodef>
+        <macrodef name="force-recompile" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${build.classes.dir}" name="destdir"/>
+            <sequential>
+                <fail unless="javac.includes">Must set javac.includes</fail>
+                <pathconvert pathsep="," property="javac.includes.binary">
+                    <path>
+                        <filelist dir="@{destdir}" files="${javac.includes}"/>
+                    </path>
+                    <globmapper from="*.java" to="*.class"/>
+                </pathconvert>
+                <delete>
+                    <files includes="${javac.includes.binary}"/>
+                </delete>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-junit">
+        <macrodef name="junit" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${includes}" name="includes"/>
+            <attribute default="${excludes}" name="excludes"/>
+            <attribute default="**" name="testincludes"/>
+            <sequential>
+                <junit dir="${work.dir}" errorproperty="tests.failed" failureproperty="tests.failed" fork="true" jvm="${platform.java}" showoutput="true">
+                    <batchtest todir="${build.test.results.dir}">
+                        <fileset dir="${test.src.dir}" excludes="@{excludes},${excludes}" includes="@{includes}">
+                            <filename name="@{testincludes}"/>
+                        </fileset>
+                    </batchtest>
+                    <classpath>
+                        <path path="${run.test.classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="test-sys-prop."/>
+                        <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <formatter type="brief" usefile="false"/>
+                    <formatter type="xml"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                </junit>
+            </sequential>
+        </macrodef>
+    </target>
+    <target depends="-init-debug-args" name="-init-macrodef-nbjpda">
+        <macrodef name="nbjpdastart" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${main.class}" name="name"/>
+            <attribute default="${debug.classpath}" name="classpath"/>
+            <attribute default="" name="stopclassname"/>
+            <sequential>
+                <nbjpdastart addressproperty="jpda.address" name="@{name}" stopclassname="@{stopclassname}" transport="${debug-transport}">
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <bootclasspath>
+                        <path path="${platform.bootcp}"/>
+                    </bootclasspath>
+                </nbjpdastart>
+            </sequential>
+        </macrodef>
+        <macrodef name="nbjpdareload" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${build.classes.dir}" name="dir"/>
+            <sequential>
+                <nbjpdareload>
+                    <fileset dir="@{dir}" includes="${fix.classes}">
+                        <include name="${fix.includes}*.class"/>
+                    </fileset>
+                </nbjpdareload>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-debug-args">
+        <exec executable="${platform.java}" outputproperty="version-output">
+            <arg value="-version"/>
+        </exec>
+        <condition property="have-jdk-older-than-1.4">
+            <or>
+                <contains string="${version-output}" substring="java version &quot;1.0"/>
+                <contains string="${version-output}" substring="java version &quot;1.1"/>
+                <contains string="${version-output}" substring="java version &quot;1.2"/>
+                <contains string="${version-output}" substring="java version &quot;1.3"/>
+            </or>
+        </condition>
+        <condition else="-Xdebug" property="debug-args-line" value="-Xdebug -Xnoagent -Djava.compiler=none">
+            <istrue value="${have-jdk-older-than-1.4}"/>
+        </condition>
+        <condition else="dt_socket" property="debug-transport-by-os" value="dt_shmem">
+            <os family="windows"/>
+        </condition>
+        <condition else="${debug-transport-by-os}" property="debug-transport" value="${debug.transport}">
+            <isset property="debug.transport"/>
+        </condition>
+    </target>
+    <target depends="-init-debug-args" name="-init-macrodef-debug">
+        <macrodef name="debug" uri="http://www.netbeans.org/ns/j2se-project/3">
+            <attribute default="${main.class}" name="classname"/>
+            <attribute default="${debug.classpath}" name="classpath"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <java classname="@{classname}" dir="${work.dir}" fork="true" jvm="${platform.java}">
+                    <jvmarg line="${debug-args-line}"/>
+                    <jvmarg value="-Xrunjdwp:transport=${debug-transport},address=${jpda.address}"/>
+                    <jvmarg line="${run.jvmargs}"/>
+                    <classpath>
+                        <path path="@{classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-macrodef-java">
+        <macrodef name="java" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <attribute default="${main.class}" name="classname"/>
+            <element name="customize" optional="true"/>
+            <sequential>
+                <java classname="@{classname}" dir="${work.dir}" fork="true" jvm="${platform.java}">
+                    <jvmarg line="${run.jvmargs}"/>
+                    <classpath>
+                        <path path="${run.classpath}"/>
+                    </classpath>
+                    <syspropertyset>
+                        <propertyref prefix="run-sys-prop."/>
+                        <mapper from="run-sys-prop.*" to="*" type="glob"/>
+                    </syspropertyset>
+                    <customize/>
+                </java>
+            </sequential>
+        </macrodef>
+    </target>
+    <target name="-init-presetdef-jar">
+        <presetdef name="jar" uri="http://www.netbeans.org/ns/j2se-project/1">
+            <jar compress="${jar.compress}" jarfile="${dist.jar}">
+                <j2seproject1:fileset dir="${build.classes.dir}"/>
+            </jar>
+        </presetdef>
+    </target>
+    <target depends="-pre-init,-init-private,-init-user,-init-project,-do-init,-post-init,-init-check,-init-macrodef-property,-init-macrodef-javac,-init-macrodef-junit,-init-macrodef-nbjpda,-init-macrodef-debug,-init-macrodef-java,-init-presetdef-jar" name="init"/>
+    <!--
+                ===================
+                COMPILATION SECTION
+                ===================
+            -->
+    <target depends="init" name="deps-jar" unless="no.deps"/>
+    <target depends="init,-check-automatic-build,-clean-after-automatic-build" name="-verify-automatic-build"/>
+    <target depends="init" name="-check-automatic-build">
+        <available file="${build.classes.dir}/.netbeans_automatic_build" property="netbeans.automatic.build"/>
+    </target>
+    <target depends="init" if="netbeans.automatic.build" name="-clean-after-automatic-build">
+        <antcall target="clean"/>
+    </target>
+    <target depends="init,deps-jar" name="-pre-pre-compile">
+        <mkdir dir="${build.classes.dir}"/>
+    </target>
+    <target name="-pre-compile">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target if="do.depend.true" name="-compile-depend">
+        <j2seproject3:depend/>
+    </target>
+    <target depends="init,deps-jar,-pre-pre-compile,-pre-compile,-compile-depend" if="have.sources" name="-do-compile">
+        <j2seproject3:javac/>
+        <copy todir="${build.classes.dir}">
+            <fileset dir="${src.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-verify-automatic-build,-pre-pre-compile,-pre-compile,-do-compile,-post-compile" description="Compile project." name="compile"/>
+    <target name="-pre-compile-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-pre-pre-compile" name="-do-compile-single">
+        <fail unless="javac.includes">Must select some files in the IDE or set javac.includes</fail>
+        <j2seproject3:force-recompile/>
+        <j2seproject3:javac excludes="" includes="${javac.includes}" sourcepath="${src.src.dir}"/>
+    </target>
+    <target name="-post-compile-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-jar,-verify-automatic-build,-pre-pre-compile,-pre-compile-single,-do-compile-single,-post-compile-single" name="compile-single"/>
+    <!--
+                ====================
+                JAR BUILDING SECTION
+                ====================
+            -->
+    <target depends="init" name="-pre-pre-jar">
+        <dirname file="${dist.jar}" property="dist.jar.dir"/>
+        <mkdir dir="${dist.jar.dir}"/>
+    </target>
+    <target name="-pre-jar">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" name="-do-jar-without-manifest" unless="manifest.available">
+        <j2seproject1:jar/>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" if="manifest.available" name="-do-jar-with-manifest" unless="manifest.available+main.class">
+        <j2seproject1:jar manifest="${manifest.file}"/>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" if="manifest.available+main.class" name="-do-jar-with-mainclass" unless="manifest.available+main.class+mkdist.available">
+        <j2seproject1:jar manifest="${manifest.file}">
+            <j2seproject1:manifest>
+                <j2seproject1:attribute name="Main-Class" value="${main.class}"/>
+            </j2seproject1:manifest>
+        </j2seproject1:jar>
+        <echo>To run this application from the command line without Ant, try:</echo>
+        <property location="${build.classes.dir}" name="build.classes.dir.resolved"/>
+        <property location="${dist.jar}" name="dist.jar.resolved"/>
+        <pathconvert property="run.classpath.with.dist.jar">
+            <path path="${run.classpath}"/>
+            <map from="${build.classes.dir.resolved}" to="${dist.jar.resolved}"/>
+        </pathconvert>
+        <echo>${platform.java} -cp "${run.classpath.with.dist.jar}" ${main.class}</echo>
+    </target>
+    <target depends="init,compile,-pre-pre-jar,-pre-jar" if="manifest.available+main.class+mkdist.available" name="-do-jar-with-libraries">
+        <property location="${build.classes.dir}" name="build.classes.dir.resolved"/>
+        <pathconvert property="run.classpath.without.build.classes.dir">
+            <path path="${run.classpath}"/>
+            <map from="${build.classes.dir.resolved}" to=""/>
+        </pathconvert>
+        <pathconvert pathsep=" " property="jar.classpath">
+            <path path="${run.classpath.without.build.classes.dir}"/>
+            <chainedmapper>
+                <flattenmapper/>
+                <globmapper from="*" to="lib/*"/>
+            </chainedmapper>
+        </pathconvert>
+        <taskdef classname="org.netbeans.modules.java.j2seproject.copylibstask.CopyLibs" classpath="${libs.CopyLibs.classpath}" name="copylibs"/>
+        <copylibs compress="${jar.compress}" jarfile="${dist.jar}" manifest="${manifest.file}" runtimeclasspath="${run.classpath.without.build.classes.dir}">
+            <fileset dir="${build.classes.dir}"/>
+            <manifest>
+                <attribute name="Main-Class" value="${main.class}"/>
+                <attribute name="Class-Path" value="${jar.classpath}"/>
+            </manifest>
+        </copylibs>
+        <echo>To run this application from the command line without Ant, try:</echo>
+        <property location="${dist.jar}" name="dist.jar.resolved"/>
+        <echo>${platform.java} -jar "${dist.jar.resolved}"</echo>
+    </target>
+    <target name="-post-jar">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-jar,-do-jar-with-manifest,-do-jar-without-manifest,-do-jar-with-mainclass,-do-jar-with-libraries,-post-jar" description="Build JAR." name="jar"/>
+    <!--
+                =================
+                EXECUTION SECTION
+                =================
+            -->
+    <target depends="init,compile" description="Run a main class." name="run">
+        <j2seproject1:java>
+            <customize>
+                <arg line="${application.args}"/>
+            </customize>
+        </j2seproject1:java>
+    </target>
+    <target name="-do-not-recompile">
+        <property name="javac.includes.binary" value=""/>
+    </target>
+    <target depends="init,-do-not-recompile,compile-single" name="run-single">
+        <fail unless="run.class">Must select one file in the IDE or set run.class</fail>
+        <j2seproject1:java classname="${run.class}"/>
+    </target>
+    <!--
+                =================
+                DEBUGGING SECTION
+                =================
+            -->
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger">
+        <j2seproject1:nbjpdastart name="${debug.class}"/>
+    </target>
+    <target depends="init,compile" name="-debug-start-debuggee">
+        <j2seproject3:debug>
+            <customize>
+                <arg line="${application.args}"/>
+            </customize>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile,-debug-start-debugger,-debug-start-debuggee" description="Debug project in IDE." if="netbeans.home" name="debug"/>
+    <target depends="init" if="netbeans.home" name="-debug-start-debugger-stepinto">
+        <j2seproject1:nbjpdastart stopclassname="${main.class}"/>
+    </target>
+    <target depends="init,compile,-debug-start-debugger-stepinto,-debug-start-debuggee" if="netbeans.home" name="debug-stepinto"/>
+    <target depends="init,compile-single" if="netbeans.home" name="-debug-start-debuggee-single">
+        <fail unless="debug.class">Must select one file in the IDE or set debug.class</fail>
+        <j2seproject3:debug classname="${debug.class}"/>
+    </target>
+    <target depends="init,-do-not-recompile,compile-single,-debug-start-debugger,-debug-start-debuggee-single" if="netbeans.home" name="debug-single"/>
+    <target depends="init" name="-pre-debug-fix">
+        <fail unless="fix.includes">Must set fix.includes</fail>
+        <property name="javac.includes" value="${fix.includes}.java"/>
+    </target>
+    <target depends="init,-pre-debug-fix,compile-single" if="netbeans.home" name="-do-debug-fix">
+        <j2seproject1:nbjpdareload/>
+    </target>
+    <target depends="init,-pre-debug-fix,-do-debug-fix" if="netbeans.home" name="debug-fix"/>
+    <!--
+                ===============
+                JAVADOC SECTION
+                ===============
+            -->
+    <target depends="init" name="-javadoc-build">
+        <mkdir dir="${dist.javadoc.dir}"/>
+        <javadoc additionalparam="${javadoc.additionalparam}" author="${javadoc.author}" charset="UTF-8" destdir="${dist.javadoc.dir}" docencoding="UTF-8" encoding="${javadoc.encoding.used}" executable="${platform.javadoc}" failonerror="true" noindex="${javadoc.noindex}" nonavbar="${javadoc.nonavbar}" notree="${javadoc.notree}" private="${javadoc.private}" source="${javac.source}" splitindex="${javadoc.splitindex}" use="${javadoc.use}" useexternalfile="true" version="${javadoc.version}" windowtitle="${javadoc.windowtitle}">
+            <classpath>
+                <path path="${javac.classpath}"/>
+            </classpath>
+            <fileset dir="${src.src.dir}" excludes="${excludes}" includes="${includes}">
+                <filename name="**/*.java"/>
+            </fileset>
+        </javadoc>
+    </target>
+    <target depends="init,-javadoc-build" if="netbeans.home" name="-javadoc-browse" unless="no.javadoc.preview">
+        <nbbrowse file="${dist.javadoc.dir}/index.html"/>
+    </target>
+    <target depends="init,-javadoc-build,-javadoc-browse" description="Build Javadoc." name="javadoc"/>
+    <!--
+                =========================
+                JUNIT COMPILATION SECTION
+                =========================
+            -->
+    <target depends="init,compile" if="have.tests" name="-pre-pre-compile-test">
+        <mkdir dir="${build.test.classes.dir}"/>
+    </target>
+    <target name="-pre-compile-test">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target if="do.depend.true" name="-compile-test-depend">
+        <j2seproject3:depend classpath="${javac.test.classpath}" destdir="${build.test.classes.dir}" srcdir="${test.src.dir}"/>
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test,-compile-test-depend" if="have.tests" name="-do-compile-test">
+        <j2seproject3:javac classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" srcdir="${test.src.dir}"/>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile-test">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test,-do-compile-test,-post-compile-test" name="compile-test"/>
+    <target name="-pre-compile-test-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test-single" if="have.tests" name="-do-compile-test-single">
+        <fail unless="javac.includes">Must select some files in the IDE or set javac.includes</fail>
+        <j2seproject3:force-recompile destdir="${build.test.classes.dir}"/>
+        <j2seproject3:javac classpath="${javac.test.classpath}" debug="true" destdir="${build.test.classes.dir}" excludes="" includes="${javac.includes}" sourcepath="${test.src.dir}" srcdir="${test.src.dir}"/>
+        <copy todir="${build.test.classes.dir}">
+            <fileset dir="${test.src.dir}" excludes="${build.classes.excludes},${excludes}" includes="${includes}"/>
+        </copy>
+    </target>
+    <target name="-post-compile-test-single">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,compile,-pre-pre-compile-test,-pre-compile-test-single,-do-compile-test-single,-post-compile-test-single" name="compile-test-single"/>
+    <!--
+                =======================
+                JUNIT EXECUTION SECTION
+                =======================
+            -->
+    <target depends="init" if="have.tests" name="-pre-test-run">
+        <mkdir dir="${build.test.results.dir}"/>
+    </target>
+    <target depends="init,compile-test,-pre-test-run" if="have.tests" name="-do-test-run">
+        <j2seproject3:junit testincludes="**/*Test.java"/>
+    </target>
+    <target depends="init,compile-test,-pre-test-run,-do-test-run" if="have.tests" name="-post-test-run">
+        <fail if="tests.failed">Some tests failed; see details above.</fail>
+    </target>
+    <target depends="init" if="have.tests" name="test-report"/>
+    <target depends="init" if="netbeans.home+have.tests" name="-test-browse"/>
+    <target depends="init,compile-test,-pre-test-run,-do-test-run,test-report,-post-test-run,-test-browse" description="Run unit tests." name="test"/>
+    <target depends="init" if="have.tests" name="-pre-test-run-single">
+        <mkdir dir="${build.test.results.dir}"/>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single" if="have.tests" name="-do-test-run-single">
+        <fail unless="test.includes">Must select some files in the IDE or set test.includes</fail>
+        <j2seproject3:junit excludes="" includes="${test.includes}"/>
+    </target>
+    <target depends="init,compile-test-single,-pre-test-run-single,-do-test-run-single" if="have.tests" name="-post-test-run-single">
+        <fail if="tests.failed">Some tests failed; see details above.</fail>
+    </target>
+    <target depends="init,-do-not-recompile,compile-test-single,-pre-test-run-single,-do-test-run-single,-post-test-run-single" description="Run single unit test." name="test-single"/>
+    <!--
+                =======================
+                JUNIT DEBUGGING SECTION
+                =======================
+            -->
+    <target depends="init,compile-test" if="have.tests" name="-debug-start-debuggee-test">
+        <fail unless="test.class">Must select one file in the IDE or set test.class</fail>
+        <property location="${build.test.results.dir}/TEST-${test.class}.xml" name="test.report.file"/>
+        <delete file="${test.report.file}"/>
+        <mkdir dir="${build.test.results.dir}"/>
+        <j2seproject3:debug classname="org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner" classpath="${ant.home}/lib/ant.jar:${ant.home}/lib/ant-junit.jar:${debug.test.classpath}">
+            <customize>
+                <syspropertyset>
+                    <propertyref prefix="test-sys-prop."/>
+                    <mapper from="test-sys-prop.*" to="*" type="glob"/>
+                </syspropertyset>
+                <arg value="${test.class}"/>
+                <arg value="showoutput=true"/>
+                <arg value="formatter=org.apache.tools.ant.taskdefs.optional.junit.BriefJUnitResultFormatter"/>
+                <arg value="formatter=org.apache.tools.ant.taskdefs.optional.junit.XMLJUnitResultFormatter,${test.report.file}"/>
+            </customize>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile-test" if="netbeans.home+have.tests" name="-debug-start-debugger-test">
+        <j2seproject1:nbjpdastart classpath="${debug.test.classpath}" name="${test.class}"/>
+    </target>
+    <target depends="init,-do-not-recompile,compile-test-single,-debug-start-debugger-test,-debug-start-debuggee-test" name="debug-test"/>
+    <target depends="init,-pre-debug-fix,compile-test-single" if="netbeans.home" name="-do-debug-fix-test">
+        <j2seproject1:nbjpdareload dir="${build.test.classes.dir}"/>
+    </target>
+    <target depends="init,-pre-debug-fix,-do-debug-fix-test" if="netbeans.home" name="debug-fix-test"/>
+    <!--
+                =========================
+                APPLET EXECUTION SECTION
+                =========================
+            -->
+    <target depends="init,compile-single" name="run-applet">
+        <fail unless="applet.url">Must select one file in the IDE or set applet.url</fail>
+        <j2seproject1:java classname="sun.applet.AppletViewer">
+            <customize>
+                <arg value="${applet.url}"/>
+            </customize>
+        </j2seproject1:java>
+    </target>
+    <!--
+                =========================
+                APPLET DEBUGGING  SECTION
+                =========================
+            -->
+    <target depends="init,compile-single" if="netbeans.home" name="-debug-start-debuggee-applet">
+        <fail unless="applet.url">Must select one file in the IDE or set applet.url</fail>
+        <j2seproject3:debug classname="sun.applet.AppletViewer">
+            <customize>
+                <arg value="${applet.url}"/>
+            </customize>
+        </j2seproject3:debug>
+    </target>
+    <target depends="init,compile-single,-debug-start-debugger,-debug-start-debuggee-applet" if="netbeans.home" name="debug-applet"/>
+    <!--
+                ===============
+                CLEANUP SECTION
+                ===============
+            -->
+    <target depends="init" name="deps-clean" unless="no.deps"/>
+    <target depends="init" name="-do-clean">
+        <delete dir="${build.dir}"/>
+        <delete dir="${dist.dir}"/>
+    </target>
+    <target name="-post-clean">
+        <!-- Empty placeholder for easier customization. -->
+        <!-- You can override this target in the ../build.xml file. -->
+    </target>
+    <target depends="init,deps-clean,-do-clean,-post-clean" description="Clean build products." name="clean"/>
+</project>
diff --git a/src/share/projects/meth/nbproject/genfiles.properties b/src/share/projects/meth/nbproject/genfiles.properties
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/nbproject/genfiles.properties
@@ -0,0 +1,5 @@
+# This file is used by a NetBeans-based IDE to track changes in generated files such as build-impl.xml.
+# Do not edit this file. You may delete it but then the IDE will never regenerate such files for you.
+nbproject/build-impl.xml.data.CRC32=223b6cda
+nbproject/build-impl.xml.script.CRC32=eb82d5a1
+nbproject/build-impl.xml.stylesheet.CRC32=65b8de21
diff --git a/src/share/projects/meth/nbproject/project.properties b/src/share/projects/meth/nbproject/project.properties
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/nbproject/project.properties
@@ -0,0 +1,97 @@
+application.args=
+application.title=MethodHandle
+application.vendor=jrose
+auxiliary.org-netbeans-modules-editor-indent.CodeStyle.project.tab-size=8
+auxiliary.org-netbeans-modules-editor-indent.CodeStyle.project.text-limit-width=80
+auxiliary.org-netbeans-modules-editor-indent.CodeStyle.usedProfile=default
+build.classes.dir=${build.dir}/classes
+build.classes.excludes=**/*.java,**/*.form
+# This directory is removed when the project is cleaned:
+build.dir=build
+build.generated.dir=${build.dir}/generated
+# Only compile against the classpath explicitly listed here:
+build.sysclasspath=ignore
+build.test.classes.dir=${build.dir}/test/classes
+build.test.results.dir=${build.dir}/test/results
+debug.classpath=\
+    ${run.classpath}
+debug.test.classpath=\
+    ${run.test.classpath}
+# This directory is removed when the project is cleaned:
+dist.dir=dist
+dist.jar=${dist.dir}/MethodHandle.jar
+dist.javadoc.dir=${dist.dir}/javadoc
+excludes=java/dyn/Anonymous*.java,java/dyn/*ConstantPool*.java,jdk/java/dyn/Anonymous*.java,links/**
+file.reference.test-classes=build/test/classes
+includes=java/dyn/**,jdk/java/dyn/**,sun/dyn/**
+#includes=**
+jar.compress=true
+javac.classpath=
+# Space-separated list of extra javac options
+# assuming full JDK_7X:
+javac.compilerargs=-Xlint:unchecked -XDinvokedynamic
+# without full JDK_7X:
+#javac.compilerargs=-Xlint:unchecked -J-Xbootclasspath/p:${reference.langtools-javac.jar} -XDinvokedynamic
+javac.deprecation=false
+javac.source=1.6
+javac.target=1.6
+javac.test.classpath=\
+    ${javac.classpath}:\
+    ${build.classes.dir}:\
+    ${libs.junit_4.classpath}
+javadoc.additionalparam=
+javadoc.author=false
+javadoc.encoding=
+javadoc.noindex=true
+javadoc.nonavbar=true
+javadoc.notree=true
+javadoc.private=false
+javadoc.splitindex=false
+javadoc.use=true
+javadoc.version=false
+javadoc.windowtitle=
+jnlp.codebase.type=local
+jnlp.codebase.url=file:/Users/jrose/Projects/MethodHandle/dist/
+jnlp.descriptor=application
+jnlp.enabled=false
+jnlp.offline-allowed=false
+jnlp.signed=false
+manifest.file=manifest.mf
+meta.inf.dir=${src.dir}/META-INF
+platform.active=JDK_7X
+# ref http://ant.apache.org/manual/CoreTasks/javac.html (OpenJDK Notes)
+#was on run.classpath, now in bootstrapped JDK:
+#  reference.AnonymousClass.jar=${project.AnonymousClass}/dist/AnonymousClass.jar
+# was on javac.classpath, run.classpath: ${reference.AnonymousClass.jar}
+#project.AnonymousClass=../AnonymousClass
+run.classpath=\
+    ${javac.classpath}:\
+    ${build.classes.dir}:\
+    ${file.reference.test-classes}
+# Space-separated list of JVM arguments used when running the project
+# (you may also define separate properties like run-sys-prop.name=value instead of -Dname=value
+# or test-sys-prop.name=value to set system properties for unit tests):
+run.jvmargs=${config.run.jvmargs} -Xbootclasspath/p:"${run.classpath}:${libs.junit_4.classpath}"
+#manual hack: override ${config.run.jvmargs} in ${config}.properties
+config.run.jvmargs=-XX:+EnableInvokeDynamic
+run.test.classpath=\
+    ${javac.test.classpath}:\
+    ${build.test.classes.dir}
+source.encoding=UTF-8
+# One or more refs probably need fixing:
+file.reference.projects=${user.home}/Projects
+file.reference.davinci.sources.jdk=${file.reference.projects}/davinci/sources/jdk
+reference.langtools-javac.jar=${project.langtools}/dist/bootstrap/lib/javac.jar
+#was: reference.langtools-javac.jar=${project.langtools}/dist/bootstrap/lib/javac.jar
+src.src.dir=${file.reference.davinci.sources.jdk}/src/share/classes
+test.src.dir=test
+project.license=openjdk
+davinci.patch.name=meth
+# JDK_7X = an mlvm build, including JSR 292 javac from langtools, libjvm from hotspot, and rt.jar from jvm
+# these should be globally defined in most setups, but are given here locally for completeness:
+platforms.JDK_7X.bootclasspath=${platforms.JDK_7X.home}/jre/lib/resources.jar:${platforms.JDK_7X.home}/jre/lib/rt.jar:${platforms.JDK_7X.home}/jre/lib/sunrsasign.jar:${platforms.JDK_7X.home}/jre/lib/jsse.jar:${platforms.JDK_7X.home}/jre/lib/jce.jar:${platforms.JDK_7X.home}/jre/lib/charsets.jar:${platforms.JDK_7X.home}/jre/classes:${platforms.JDK_7X.home}/jre/lib/ext/dnsns.jar:${platforms.JDK_7X.home}/jre/lib/ext/localedata.jar:${platforms.JDK_7X.home}/jre/lib/ext/sunjce_provider.jar:${platforms.JDK_7X.home}/jre/lib/ext/sunpkcs11.jar
+platforms.JDK_7X.compiler=modern
+platforms.JDK_7X.home=${user.home}/env/JAVA7X_HOME
+platforms.JDK_7X.home=${project.davinci}/sources/build/bsd-i586
+project.davinci=${user.home}/Projects/davinci
+libs.junit_4.classpath=${user.home}/env/jars/junit-4.1.jar
diff --git a/src/share/projects/meth/nbproject/project.xml b/src/share/projects/meth/nbproject/project.xml
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/nbproject/project.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://www.netbeans.org/ns/project/1">
+    <type>org.netbeans.modules.java.j2seproject</type>
+    <configuration>
+        <data xmlns="http://www.netbeans.org/ns/j2se-project/3">
+            <name>MethodHandle</name>
+            <minimum-ant-version>1.6.5</minimum-ant-version>
+            <explicit-platform explicit-source-supported="true"/>
+            <source-roots>
+                <root id="src.src.dir" name="JDK Source Packages"/>
+            </source-roots>
+            <test-roots>
+                <root id="test.src.dir"/>
+            </test-roots>
+        </data>
+    </configuration>
+</project>
diff --git a/src/share/projects/meth/test/jdk/java/dyn/Hello.java b/src/share/projects/meth/test/jdk/java/dyn/Hello.java
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/test/jdk/java/dyn/Hello.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+/*
+ * @test
+ * @bug 6754038
+ * @summary Hello world, JSR 292 style
+ * @author jrose
+ *
+ * Standalone testing:
+ * <code>
+ * $ cd $MY_REPO_DIR/langtools
+ * $ (cd make; make)
+ * $ .../langtools/dist/bootstrap/bin/javac -d dist .../Hello.java
+ * $ javap -c -classpath dist jdk.java.dyn.Hello
+ * </code>
+ *
+ * @run Hello.java
+ */
+
+package jdk.java.dyn;
+import org.junit.*;
+
+import java.dyn.*;
+
+public class Hello {
+    @Test public void test() { main("Fred"); }
+
+    public static void main(String... av) {
+        if (av.length == 0)  av = new String[] { "world" };
+        greeter(av[0] + " (from a statically linked call site)");
+        greete5(av[0] + " (from a statically linked call site)");
+        for (String whom : av) {
+            greeter.<void>invoke(whom);  // strongly typed direct call
+            greete5.invoke(whom);        // strongly typed direct call
+            // previous line generates invokevirtual MethodHandle.invoke(String)void
+            Dynamic x = whom;
+            x.hail();                    // weakly typed invokedynamic
+            // previous line generates invokedynamic MethodHandle.invoke(Dynamic)Dynamic
+        }
+        System.out.println("Last call:");
+        try {
+            Dynamic loser = 911;
+            loser.hail();   // should fail in the adapter (Dynamic -> String cast)
+        } catch (RuntimeException ee) {
+            System.out.println("Caught the bullet: "+ee);
+        }
+        System.out.println("Bye!");
+    }
+
+    static void greeter(String x) { System.out.println("Hello, "+x); }
+    // intentionally pun between the method and its reified handle:
+    static MethodHandle greeter
+        = MethodHandles.findStatic(Hello.class, "greeter",
+                                   MethodType.make(void.class, String.class));
+    //might be nice: MethodHandle greeter = Hello#greeter;
+
+    static Dynamic greete5(String x) { System.out.println("H311o, "+x); return null; }
+    static MethodHandle greete5
+        = MethodHandles.findStatic(Hello.class, "greete5",
+                                   MethodType.make(Dynamic.class, String.class));
+    // Set up a class-local bootstrap method.
+    static { Linkage.registerBootstrapMethod("bootstrapDynamic"); }
+    private static Object bootstrapDynamic(CallSite site, Object... args) {
+        assert(args.length == 1 && site.name() == "hail");  // in lieu of MOP
+        System.out.println("set site target to "+greete5);
+        MethodHandle target = MethodHandles.convertArguments(greete5, site.type());
+        System.out.println("   with conversions: "+target);
+        site.setTarget(target);
+        System.out.println("calling the slow path; this should be the last time!");
+        return MethodHandles.invoke(target, args);
+    }
+}
diff --git a/src/share/projects/meth/test/jdk/java/dyn/InvokeDynamicDemo.java b/src/share/projects/meth/test/jdk/java/dyn/InvokeDynamicDemo.java
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/test/jdk/java/dyn/InvokeDynamicDemo.java
@@ -0,0 +1,298 @@
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ * 
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ * 
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package jdk.java.dyn;
+
+import java.dyn.*;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.regex.Pattern;
+import org.junit.*;
+//import static org.junit.Assert.*;
+import static jdk.java.dyn.JUnitAssert.*;
+
+public class InvokeDynamicDemo {
+
+    private interface FakeDynamic extends Dynamic {
+        int foo(int x);
+        String bar(String x, int y);
+    }
+
+    public static int myFoo(Object recv, int z) {
+        println("myFoo "+recv+" "+z);
+        return z * 1000000;
+    }
+
+    public static String myBar(Object recv, String x, int y) {
+        println("myBar "+recv+" "+x+" "+y);
+        return "myBar"+Arrays.asList(recv, x, y);
+    }
+
+    static class IDUser implements Runnable {
+        static String options = "FAKE_OPTIONS";
+        static boolean hasOption(String x) {
+            return options.indexOf(x) >= 0;
+        }
+
+        @Override
+        public void run() {
+            useit("baz", "bat", 123);
+        }
+
+        void useit(Object x, Object y, int z) {
+            int fooval = fakeIdentity(x).foo(z);
+            println("foo => "+fooval);
+            assertEquals(myFoo(x, z), fooval);
+            String barval = fakeIdentity(x).bar((String)y, z);
+            println("bar => "+barval);
+            assertEquals(myBar(x, (String)y, z), barval);
+        }
+
+        public // %%% FIXME: findStatic only finds public methods right now
+        static Object bootstrap(CallSite site, Object... args) {
+            println("bootstrap "+site+Arrays.asList(args));
+            // a bootstrap method can be very stupid:
+            if (hasOption("boot-gc"))
+                Runtime.getRuntime().gc();
+            if (hasOption("boot-null"))
+                return null;
+            if (hasOption("boot-bad"))
+                return Arrays.asList(args);   // neither a String nor an Integer
+            if (hasOption("boot-string"))
+                return "boot";
+            if (hasOption("boot-int"))
+                return 8007;
+            if (hasOption("boot-throw"))
+                throw new RuntimeException("boot-throw!");
+            // or it can actually look at the call site:
+            Object name = site.name();
+            if (name == "foo") {
+                if (hasOption("boot-con"))
+                    return 8007000;  // it does not need to set a target...
+                MethodHandle myFoo = MethodHandles.findStatic(InvokeDynamicDemo.class, "myFoo", site.type());
+                println("setTarget myFoo: "+myFoo);
+                site.setTarget(myFoo);
+                return myFoo(args[0], (Integer) args[1]);
+            }
+            if (name == "bar") {
+                if (hasOption("boot-con"))
+                    return "boot con!";  // it does not need to set a target...
+                MethodHandle myBar = MethodHandles.findStatic(InvokeDynamicDemo.class, "myBar", site.type());
+                println("setTarget myBar: "+myBar);
+                site.setTarget(myBar);
+                return myBar(args[0], (String) args[1], (Integer) args[2]);
+            }
+            throw new RuntimeException("name not recognized: "+name);
+        }
+
+        static {
+            println("options: "+options);
+            MethodType type = Linkage.BOOTSTRAP_METHOD_TYPE;
+            MethodHandle mh = MethodHandles.findStatic(IDUser.class, "bootstrap", type);
+            if (mh == null)
+                println("missing bootstrap"+type);
+            else
+                println("register bootstrap: "+mh);
+            Linkage.registerBootstrapMethod(IDUser.class, mh);
+        }
+    }
+    static FakeDynamic fakeIdentity(Object x) {
+        return (FakeDynamic)x;
+    }
+    static Object identity(Object x) {
+        return x;
+    }
+
+    static boolean verbose;
+    static void println(String x) {
+        if (verbose)  System.out.println(x);
+    }
+
+    @Test public void run() throws Exception { run(new String[0]); }
+
+    public static void run(String... av) throws Exception {
+        final HashMap<String,String> utf8Map = new HashMap<String,String>();
+        utf8Map.put("fakeIdentity", "identity");
+        String objbcn = Object.class.getName().replace('.', '/');
+        String objsig = "L"+objbcn+";";
+        String fdbcn = FakeDynamic.class.getName().replace('.', '/');
+        String rdbcn = Dynamic.class.getName().replace('.', '/');
+        utf8Map.put(fdbcn, rdbcn);
+        String fakesig = "("+objsig+")L"+fdbcn+";";
+        utf8Map.put(fakesig, fakesig.replaceAll(Pattern.quote(fdbcn), objbcn));
+        utf8Map.put("FAKE_OPTIONS", Arrays.asList(av).toString());
+        System.out.println("utf8Map: "+utf8Map);
+        final ConstantPoolPatch patch = new ConstantPoolPatch(IDUser.class);
+        patch.putPatches(utf8Map, null, null, true);
+        if (!utf8Map.isEmpty())
+            throw new AssertionError("Map not empty: "+utf8Map);
+        Class anonk = new AnonymousClassLoader(IDUser.class).loadClass(patch);
+        Object user = anonk.newInstance();
+        System.out.println("Running test on new object "+user);
+        int count = 1;
+        verbose = true;
+        for (String arg : av) {
+            if (arg.startsWith("count-"))
+                count = Integer.parseInt(arg.substring("count-".length(), arg.length()));
+        }
+        if (count != 1)  System.out.println("run count: "+count);
+        for (int i = 0; i < count; i++) {
+            if (i > 10) {
+                if (i > count - 10)
+                    verbose = true;
+                else if (verbose) {
+                    println("...shutting up...");
+                    verbose = false;
+                }
+            }
+            ((Runnable)user).run();
+        }
+    }
+
+    // Extra entry point for standalone use.  Use as follows:
+    //junit="$NetBeansResources/NetBeans/java2/modules/ext/junit-4.1.jar"
+    //anonk="../AnonymousClass/dist/AnonymousClass.jar"
+    //cpath="$anonk:build/classes:build/test/classes:$junit"
+    //java -Xbootclasspath/p:"$cpath" jdk.java.dyn.MethodHandleBytecodeTest
+    public static void main(String... av) throws Throwable {
+        System.out.println("running ID demo");
+        run(av);
+        //new JUnit4TestAdapter(InvokeDynamicDemo.class).run(null);
+    }
+}
+
+/* --- SAMPLE OUTPUT ---
+--------
+	./gamma -XX:+EnableInvokeDynamic -Xbootclasspath/p:"$cpath" jdk.java.dyn.InvokeDynamicDemo count-1000
+VM option '+PrintCompilation'
+VM option '+VerifyBeforeGC'
+VM option '+MethodHandles'
+VM option '+InvokeDynamic'
+[Verifying threads permgen tenured generation def new generation remset ref_proc syms strs zone dict hand C-heap ]
+running ID demo
+utf8Map: {fakeIdentity=identity, jdk/java/dyn/InvokeDynamicDemo$FakeDynamic=java/dyn/Dynamic, (Ljava/lang/Object;)Ljdk/java/dyn/InvokeDynamicDemo$FakeDynamic;=(Ljava/lang/Object;)Ljava/lang/Object;, FAKE_OPTIONS=[count-1000]}
+  1       java.lang.String::charAt (33 bytes)
+  2       java.lang.String::hashCode (60 bytes)
+Running test on new object jdk.java.dyn.InvokeDynamicDemo$IDUser/29596205@eb7859
+run count: 1000
+reporting bootstrap method to JVM: bootstrap:(java.dyn.CallSite,java.lang.Object...)java.lang.Object
+DynCallSite: CallSite#23491286[foo(java.lang.Object,int)int => null]
+bootstrap CallSite#23491286[foo(java.lang.Object,int)int => null][baz, 123]
+setTarget myFoo: myFoo:(java.lang.Object,int)int
+myFoo baz 123
+foo => 123000000
+DynCallSite: CallSite#21061094[bar(java.lang.Object,java.lang.String,int)java.lang.String => null]
+bootstrap CallSite#21061094[bar(java.lang.Object,java.lang.String,int)java.lang.String => null][baz, bat, 123]
+setTarget myBar: myBar:(java.lang.Object,java.lang.String,int)java.lang.String
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+...shutting up...
+  3       java.lang.Object::<init> (1 bytes)
+ VerifyBeforeGC:[Verifying threads permgen tenured generation def new generation remset ref_proc syms strs zone dict hand C-heap ]
+---   n   java.lang.System::arraycopy (static)
+  4       java.lang.String::getChars (66 bytes)
+  5       java.lang.AbstractStringBuilder::append (60 bytes)
+  6       java.lang.StringBuilder::append (8 bytes)
+  7       java.lang.Integer::getChars (131 bytes)
+  8       java.lang.AbstractStringBuilder::stringSizeOfInt (21 bytes)
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+myFoo baz 123
+foo => 123000000
+myBar baz bat 123
+bar => myBar[baz, bat, 123]
+--------
+ * --- */
diff --git a/src/share/projects/meth/test/jdk/java/dyn/JUnitAssert.java b/src/share/projects/meth/test/jdk/java/dyn/JUnitAssert.java
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/test/jdk/java/dyn/JUnitAssert.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ * 
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ * 
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package jdk.java.dyn;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * Local stub for running without junit.jar.
+ * To use, copy this file to your package, and add this to the per-file imports:
+ * <code>
+ * //import static org.junit.Assert.*;
+ * import static whatever.this.package.is.JUnitAssert.*;
+ * </code>
+ * @author jrose
+ */
+class JUnitAssert {
+    static void assertSame(Object expected, Object actual) {
+        Method m = findMethod("assertSame", Object.class, Object.class);
+        if (m != null) {
+            callMethod(m, expected, actual);
+        } else if (expected != actual) {
+            error("not same", expected, actual);
+        }
+    }
+
+    static void assertEquals(Object expected, Object actual) {
+        if (!equals(expected, actual))
+            assertSame(expected, actual);
+    }
+
+    static boolean equals(Object x, Object y) {
+        return (x == y) || (x != null && y != null && x.equals(y));
+    }
+    
+    static void error(String message, Object expected, Object actual) {
+        throw new AssertionError(message+": expected ["+expected+"]"+
+                                   ", but result was ["+actual+"]");
+    }
+    
+    /// the rest is brute hackery...
+
+    static final Class<?> JUNIT_ASSERT;
+    static {
+        Class <?> JUNIT_ASSERT_ = null;
+        final String cname = "org.junit.Assert";
+        try {
+            JUNIT_ASSERT_ = Class.forName(cname);
+        } catch (ClassNotFoundException ee) {
+            System.out.println("Using backup methods instead of "+cname);
+        }
+        JUNIT_ASSERT = JUNIT_ASSERT_;
+    }
+
+    static final HashMap<List<Object>, Method> methods
+            = new HashMap<List<Object>, Method>();
+    static final Method NO_METHOD;
+    static {
+        Method noMethod = null;
+        try {
+            noMethod = JUnitAssert.class.getDeclaredMethod("noMethod");
+        } catch (Exception ee) {
+        }
+        NO_METHOD = noMethod; 
+    }
+    static private void noMethod() { }
+    
+    static Method findMethod(String name, Class<?>... params) {
+        if (JUNIT_ASSERT == null)  return null;
+        ArrayList<Object> key = new ArrayList<Object>(Arrays.asList(params));
+        key.add(0, name);
+        Method m = methods.get(key);
+        if (m != null)  return (m == NO_METHOD ? null : m);
+        try {
+            m = JUNIT_ASSERT.getMethod(name, params);
+        } catch (NoSuchMethodException ee) {
+            System.out.println("Missing method: "+name+Arrays.asList(params));
+        }
+        methods.put(key, (m == null ? NO_METHOD : m));
+        return m;
+    }
+    static Object callMethod(Method m, Object... params) {
+        Throwable bad;
+        try {
+            return m.invoke(null, params);
+        } catch (InvocationTargetException ite) {
+            Throwable ee = ite.getTargetException();
+            if (ee instanceof RuntimeException)
+                throw (RuntimeException)ee;
+            if (ee instanceof Error)
+                throw (Error)ee;
+            bad = ee;
+        } catch (Exception ee) {
+            bad = ee;
+        }
+        throw new Error("unexpected reflection problem", bad);
+    }
+}
diff --git a/src/share/projects/meth/test/jdk/java/dyn/MethodHandleBytecodeTest.java b/src/share/projects/meth/test/jdk/java/dyn/MethodHandleBytecodeTest.java
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/test/jdk/java/dyn/MethodHandleBytecodeTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package jdk.java.dyn;
+
+import java.dyn.*;
+import sun.dyn.util.*;
+import java.lang.reflect.Method;
+import junit.framework.JUnit4TestAdapter;
+import junit.framework.TestCase;
+import org.junit.*;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author jrose
+ */
+public class MethodHandleBytecodeTest {
+    private Method toString, compareTo, getBytes;
+
+    @Before
+    public void setUp() throws Exception {
+        toString = Object.class.getDeclaredMethod("toString");
+        compareTo = Comparable.class.getDeclaredMethod("compareTo", Object.class);
+        getBytes = String.class.getDeclaredMethod("getBytes", String.class);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    /**
+     * Test of invoke pseudo-method, of class MethodHandle.
+     */
+    @Test
+    public void testToString() {
+        System.out.println("invoke toString");
+        MethodHandle instance = MethodHandles.findVirtual(
+                Object.class, "toString", MethodType.make(String.class) );
+        String foo = "foo";
+        String expResult = foo.toString();
+        String result = invokeToString(instance, foo);
+        System.out.println("result = "+result);
+        assertEquals(expResult, result);
+    }
+
+    private String invokeToString(MethodHandle mh, Object obj) {
+        MethodHandleInvoker inv = MethodHandleInvoker.make(mh.type());
+        System.out.println("invoke mh="+mh);
+        return (String) inv.invoke_1(mh, obj);
+    }
+
+    // Extra entry point for standalone use.  Use as follows:
+    //junit="$NetBeansResources/NetBeans/java2/modules/ext/junit-4.1.jar"
+    //anonk="../AnonymousClass/dist/AnonymousClass.jar"
+    //cpath="$anonk:build/classes:build/test/classes:$junit"
+    //java -Xbootclasspath/p:"$cpath" jdk.java.dyn.MethodHandleBytecodeTest
+    public static void main(String... av) throws Throwable {
+        new JUnit4TestAdapter(MethodHandleBytecodeTest.class).run(null);
+    }
+}
diff --git a/src/share/projects/meth/test/jdk/java/dyn/MethodHandleDemo.java b/src/share/projects/meth/test/jdk/java/dyn/MethodHandleDemo.java
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/test/jdk/java/dyn/MethodHandleDemo.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ * 
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ * 
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package jdk.java.dyn;
+
+import java.dyn.*;
+import sun.dyn.util.MethodHandleInvoker;
+
+import org.junit.*;
+//import static org.junit.Assert.*;
+import static jdk.java.dyn.JUnitAssert.*;
+
+public class MethodHandleDemo {
+    static String options = "";
+    static boolean hasOption(String x) {
+        return options.indexOf(x) >= 0;
+    }
+    static boolean verbose = true;
+    static void println(Object x) {
+        if (verbose)  System.out.println(x);
+    }
+
+    public static void main(String... av) {
+        assertSame("hello", "hello");  // exercise assertion stuff first
+
+        options = java.util.Arrays.asList(av).toString();
+        int count = 1;
+        verbose = true;
+        for (String arg : av) {
+            if (arg.startsWith("count-"))
+                count = Integer.parseInt(arg.substring("count-".length(), arg.length()));
+        }
+        if (count != 1)  println("run count: "+count);
+        for (int i = 0; i < count; i++) {
+            if (i > 10) {
+                if (i > count - 10)
+                    verbose = true;
+                else if (verbose) {
+                    println("...shutting up...");
+                    verbose = false;
+                }
+            }
+            test();
+        }
+    }
+
+    static void test() {
+        Class caller = MethodHandleDemo.class;
+        Class returnType = String.class;
+        Class[] signature = {String.class};
+        String result;
+        MethodHandle mh;
+        mh = MethodHandles.findVirtual(Object.class,
+                "toString", MethodType.make(String.class));
+        println("calling "+mh);
+        result = (String) MethodHandleInvoker.make(mh.type()).invoke_1(mh, "foo");
+        //result = mh.<String>invoke("foo");
+        assertSame("foo", result);
+
+        mh = MethodHandles.findStatic(MethodHandleDemo.class,
+                "test0", MethodType.make(String.class));
+        println("calling "+mh);
+        result = (String) MethodHandleInvoker.make(mh.type()).invoke_0(mh);
+        assertEquals("[test0]", result);
+
+        mh = MethodHandles.findStatic(MethodHandleDemo.class,
+                "test1", MethodType.make(String.class, String.class));
+        println("calling "+mh);
+        result = (String) MethodHandleInvoker.make(mh.type()).invoke_1(mh, "X");
+        assertEquals("[test1 X]", result);
+        
+        mh = MethodHandles.insertArgument(mh, "Bounderby");
+        println("calling bound "+mh);
+        result = (String) MethodHandleInvoker.make(mh.type()).invoke_0(mh);
+        assertEquals("[test1 Bounderby]", result);
+
+        mh = MethodHandles.findStatic(MethodHandleDemo.class,
+                "test2", MethodType.make(String.class, String.class, int.class));
+        println("calling "+mh);
+        result = (String) MethodHandleInvoker.make(mh.type()).invoke_2(mh, "X", 123);
+        assertEquals("[test2 X #123]", result);
+
+        mh = MethodHandles.insertArgument(mh, "Buster");
+        println("calling bound "+mh);
+        result = (String) MethodHandleInvoker.make(mh.type()).invoke_1(mh, 456);
+        assertEquals("[test2 Buster #456]", result);
+
+        Obj obj = new Obj("X");
+        mh = MethodHandles.findVirtual(I.class,
+                "test1", MethodType.make(String.class));
+        println("calling "+mh);
+        result = (String) MethodHandleInvoker.make(mh.type()).invoke_1(mh, obj);
+        assertEquals("[Obj.test1 X]", result);
+
+        mh = MethodHandles.findVirtual(I.class,
+                "test2", MethodType.make(String.class, int.class));
+        println("calling "+mh);
+        result = (String) MethodHandleInvoker.make(mh.type()).invoke_2(mh, obj, 123);
+        assertEquals("[Obj.test2 X #123]", result);
+    }
+
+    static void eachCall() {
+        if (hasOption("call-gc"))
+            Runtime.getRuntime().gc();
+    }
+
+    // static methods we make handles for:
+    public static String test0() {
+        eachCall();
+        return "[test0]";
+    }
+
+    public static String test1(String x) {
+        eachCall();
+        return "[test1 " + x + "]";
+    }
+
+    public static String test2(String x, int y) {
+        println("y == 0x"+Integer.toHexString(y));
+        eachCall();
+        return "[test2 " + x + " #" + y + "]";
+    }
+    
+    interface I {
+        String test1();
+        String test2(int y);
+    }
+
+    // virtual methods we make handles for:
+    static class Obj implements I {
+        String x;
+        Obj(String x) { this.x = x; }
+        public String test1() {
+            eachCall();
+            return "[Obj.test1 " + x + "]";
+        }
+        public String test2(int y) {
+            println("y == 0x"+Integer.toHexString(y));
+            eachCall();
+            return "[Obj.test2 " + x + " #" + y + "]";
+        }
+    }
+
+    // JUnit trimmings:
+    @Test
+    public void testMain() {
+        main();
+    }
+}
diff --git a/src/share/projects/meth/test/jdk/java/dyn/MethodHandlesTest.java b/src/share/projects/meth/test/jdk/java/dyn/MethodHandlesTest.java
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/test/jdk/java/dyn/MethodHandlesTest.java
@@ -0,0 +1,630 @@
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ * 
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ * 
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ * 
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package jdk.java.dyn;
+
+import sun.dyn.MemberName;
+import sun.dyn.util.Wrappers;
+import java.dyn.*;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Ignore;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author jrose
+ */
+public class MethodHandlesTest {
+
+    public MethodHandlesTest() {
+    }
+
+    @BeforeClass
+    public static void setUpClass() throws Exception {
+        calledLog.clear();
+        calledLog.add(null);
+        nextArg = 1000000;
+    }
+
+    @AfterClass
+    public static void tearDownClass() throws Exception {
+    }
+
+    static List<Object> calledLog = new ArrayList<Object>();
+    static Object logEntry(String name, Object... args) {
+        return Arrays.asList(name, Arrays.asList(args));
+    }
+    static Object called(String name, Object... args) {
+        Object entry = logEntry(name, args);
+        calledLog.add(entry);
+        return entry;
+    }
+    static void assertCalled(String name, Object... args) {
+        Object expected = logEntry(name, args);
+        Object actual   = calledLog.get(calledLog.size() - 1);
+        assertEquals("previous method call", expected, actual);
+    }
+    static void printCalled(MethodHandle target, String name, Object... args) {
+        System.out.println("calling "+logEntry(name, args)+" on "+target);
+    }
+
+    static int nextArg;
+    static Object randomArg(Class<?> param) {
+        if (param.isPrimitive() || Wrappers.isWrapperType(param))
+            return Wrappers.wrap(nextArg++, param);
+        else if (param.isInterface() || param.isAssignableFrom(String.class))
+            return "#"+(nextArg++);
+        else
+            try {
+                return param.newInstance();
+            } catch (InstantiationException ex) {
+            } catch (IllegalAccessException ex) {
+            }
+        return null;  // random class not Object, String, Integer, etc.
+    }
+    static Object[] randomArgs(Class<?>... params) {
+        Object[] args = new Object[params.length];
+        for (int i = 0; i < args.length; i++)
+            args[i] = randomArg(params[i]);
+        return args;
+    }
+
+    static <T, E extends T> T[] array(Class<T[]> atype, E... a) {
+        return Arrays.copyOf(a, a.length, atype);
+    }
+    static <T> T[] cat(T[] a, T... b) {
+        int alen = a.length, blen = b.length;
+        if (blen == 0)  return a;
+        T[] c = Arrays.copyOf(a, alen + blen);
+        System.arraycopy(b, 0, c, alen, blen);
+        return c;
+    }
+    static Integer[] boxAll(int... vx) {
+        Integer[] res = new Integer[vx.length];
+        for (int i = 0; i < res.length; i++) {
+            res[i] = vx[i];
+        }
+        return res;
+    }
+
+    // Subject methods...
+    static class Example implements IntExample {
+        final String name;
+        public Example() { name = "Example#"+(nextArg++); }
+        protected Example(String name) { this.name = name; }
+        protected Example(int x) { this(); called("protected <init>", this, x); }
+        @Override public String toString() { return name; }
+
+        public void            v0()     { called("v0", this); }
+        void                   pkg_v0() { called("pkg_v0", this); }
+        private void           pri_v0() { called("pri_v0", this); }
+        public static void     s0()     { called("s0"); }
+        static void            pkg_s0() { called("pkg_s0"); }
+        private static void    pri_s0() { called("pri_s0"); }
+
+        public Object          v1(Object x) { return called("v1", this, x); }
+        public Object          v2(Object x, Object y) { return called("v2", this, x, y); }
+        public Object          v2(Object x, int    y) { return called("v2", this, x, y); }
+        public Object          v2(int    x, Object y) { return called("v2", this, x, y); }
+        public Object          v2(int    x, int    y) { return called("v2", this, x, y); }
+        public static Object   s1(Object x) { return called("s1", x); }
+        public static Object   s2(int x)    { return called("s2", x); }
+        public static Object   s3(long x)   { return called("s3", x); }
+        public static Object   s4(int x, int y) { return called("s4", x, y); }
+        public static Object   s5(long x, int y) { return called("s5", x, y); }
+        public static Object   s6(int x, long y) { return called("s6", x, y); }
+
+        static MethodHandle findStatic(Class defc, String name, MethodType type) {
+            return MethodHandles.findStatic(defc, name, type);
+        }
+        static MethodHandle findVirtual(Class defc, String name, MethodType type) {
+            return MethodHandles.findVirtual(defc, name, type);
+        }
+        static MethodHandle unreflect(Method rmethod) {
+            return MethodHandles.unreflect(rmethod);
+        }
+    }
+    static class SubExample extends Example {
+        @Override public void  v0()     { called("Sub/v0", this); }
+        @Override void         pkg_v0() { called("Sub/pkg_v0", this); }
+        private      SubExample(int x)  { called("<init>", this, x); }
+        public SubExample() { super("SubExample#"+(nextArg++)); }
+        static MethodHandle findSpecial(Class defc, String name, MethodType type) {
+            return MethodHandles.findSpecial(defc, name, type, SubExample.class);
+        }
+    }
+    static interface IntExample {
+        public void            v0();
+        static class Impl implements IntExample {
+            public void        v0()     { called("Int/v0", this); }
+            final String name;
+            public Impl() { name = "Example#"+(nextArg++); }
+        }
+    }
+
+    static boolean CAN_SKIP_WORKING = false;
+
+    @Test
+    public void testFindStatic() {
+        if (CAN_SKIP_WORKING)  return;
+        System.out.println("findStatic");
+        testFindStatic(Example.class, void.class, "s0");
+        testFindStatic(Example.class, void.class, "pkg_s0");
+        testFindStatic(Example.class, void.class, "pri_s0");
+
+        testFindStatic(Example.class, Object.class, "s1", Object.class);
+        testFindStatic(Example.class, Object.class, "s2", int.class);
+        //testFindStatic(Example.class, Object.class, "s3", long.class);
+        //testFindStatic(Example.class, Object.class, "s4", int.class, int.class);
+        //testFindStatic(Example.class, Object.class, "s5", long.class, int.class);
+        //testFindStatic(Example.class, Object.class, "s6", int.class, long.class);
+
+        testFindStatic(false, Example.class, void.class, "bogus");
+    }
+
+    void testFindStatic(Class<?> defc, Class<?> ret, String name, Class<?>... params) {
+        testFindStatic(true, defc, ret, name, params);
+    }
+    void testFindStatic(boolean positive, Class<?> defc, Class<?> ret, String name, Class<?>... params) {
+        MethodType type = MethodType.make(ret, params);
+        MethodHandle target = null;
+        RuntimeException noAccess = null;
+        try {
+            target = Example.findStatic(defc, name, type);
+        } catch (NoAccessException ex) {
+            noAccess = ex;
+        }
+        System.out.println("findStatic "+defc+"."+name+"/"+type+" => "+target
+                +(noAccess == null ? "" : " !! "+noAccess));
+        if (positive && noAccess != null)  throw noAccess;
+        assertEquals(positive, target != null);
+        if (!positive)  return; // negative test failed as expected
+        assertEquals(type, target.type());
+        Object[] args = randomArgs(params);
+        printCalled(target, name, args);
+        MethodHandles.invoke(target, args);
+        assertCalled(name, args);
+        System.out.print(':');
+    }
+
+    @Test
+    public void testFindVirtual() {
+        if (CAN_SKIP_WORKING)  return;
+        System.out.println("findVirtual");
+        testFindVirtual(Example.class, void.class, "v0");
+        testFindVirtual(Example.class, void.class, "pkg_v0");
+        testFindVirtual(Example.class, void.class, "pri_v0");
+        testFindVirtual(Example.class, Object.class, "v1", Object.class);
+        testFindVirtual(Example.class, Object.class, "v2", Object.class, Object.class);
+        testFindVirtual(Example.class, Object.class, "v2", Object.class, int.class);
+        testFindVirtual(Example.class, Object.class, "v2", int.class, Object.class);
+        testFindVirtual(Example.class, Object.class, "v2", int.class, int.class);
+        testFindVirtual(false, Example.class, Example.class, void.class, "bogus");
+        // test dispatch
+        testFindVirtual(SubExample.class,      SubExample.class, void.class, "Sub/v0");
+        testFindVirtual(SubExample.class,         Example.class, void.class, "Sub/v0");
+        testFindVirtual(SubExample.class,      IntExample.class, void.class, "Sub/v0");
+        testFindVirtual(SubExample.class,      SubExample.class, void.class, "Sub/pkg_v0");
+        testFindVirtual(SubExample.class,         Example.class, void.class, "Sub/pkg_v0");
+        testFindVirtual(Example.class,         IntExample.class, void.class, "v0");
+        testFindVirtual(IntExample.Impl.class, IntExample.class, void.class, "Int/v0");
+    }
+
+    void testFindVirtual(Class<?> defc, Class<?> ret, String name, Class<?>... params) {
+        testFindVirtual(defc, defc, ret, name, params);
+    }
+    void testFindVirtual(Class<?> rcvc, Class<?> defc, Class<?> ret, String name, Class<?>... params) {
+        testFindVirtual(true, rcvc, defc, ret, name, params);
+    }
+    void testFindVirtual(boolean positive, Class<?> rcvc, Class<?> defc, Class<?> ret, String name, Class<?>... params) {
+        String methodName = name.substring(1 + name.indexOf('/'));  // foo/bar => foo
+        MethodType type = MethodType.make(ret, params);
+        MethodHandle target = null;
+        RuntimeException noAccess = null;
+        try {
+            target = MethodHandles.findVirtual(defc, methodName, type);
+        } catch (NoAccessException ex) {
+            noAccess = ex;
+        }
+        System.out.println("findVirtual "+defc+"."+name+"/"+type+" => "+target
+                +(noAccess == null ? "" : " !! "+noAccess));
+        if (positive && noAccess != null)  throw noAccess;
+        assertEquals(positive, target != null);
+        if (!positive)  return; // negative test failed as expected
+        Class<?>[] paramsWithSelf = cat(array(Class[].class, defc), params);
+        MethodType typeWithSelf = MethodType.make(ret, paramsWithSelf);
+        assertEquals(typeWithSelf, target.type());
+        Object[] argsWithSelf = randomArgs(paramsWithSelf);
+        if (rcvc != defc)  argsWithSelf[0] = randomArg(rcvc);
+        printCalled(target, name, argsWithSelf);
+        MethodHandles.invoke(target, argsWithSelf);
+        assertCalled(name, argsWithSelf);
+        System.out.print(':');
+    }
+
+    @Test
+    public void testFindSpecial() {
+        if (CAN_SKIP_WORKING)  return;
+        System.out.println("findSpecial");
+        testFindSpecial(Example.class, void.class, "v0");
+        testFindSpecial(Example.class, void.class, "pkg_v0");
+        testFindSpecial(SubExample.class, void.class, "<init>", int.class);
+        testFindSpecial(false, Example.class, void.class, "<init>", int.class);
+        testFindSpecial(false, Example.class, void.class, "bogus");
+    }
+
+    void testFindSpecial(Class<?> defc, Class<?> ret, String name, Class<?>... params) {
+        testFindSpecial(true, defc, ret, name, params);
+    }
+    void testFindSpecial(boolean positive, Class<?> defc, Class<?> ret, String name, Class<?>... params) {
+        MethodType type = MethodType.make(ret, params);
+        MethodHandle target = null;
+        RuntimeException noAccess = null;
+        try {
+            target = SubExample.findSpecial(defc, name, type);
+        } catch (NoAccessException ex) {
+            noAccess = ex;
+        }
+        System.out.println("findSpecial "+defc+"."+name+"/"+type+" => "+target
+                +(noAccess == null ? "" : " !! "+noAccess));
+        if (positive && noAccess != null)  throw noAccess;
+        assertEquals(positive, target != null);
+        if (!positive)  return; // negative test failed as expected
+        Class<?>[] paramsWithSelf = cat(array(Class[].class, defc), params);
+        MethodType typeWithSelf = MethodType.make(ret, paramsWithSelf);
+        assertEquals(typeWithSelf, target.type());
+        Object[] args = randomArgs(paramsWithSelf);
+        printCalled(target, name, args);
+        MethodHandles.invoke(target, args);
+        assertCalled(name, args);
+        System.out.print(':');
+    }
+
+    @Test
+    public void testBind() {
+        if (CAN_SKIP_WORKING)  return;
+        System.out.println("bind");
+        testBind(Example.class, void.class, "v0");
+        testBind(Example.class, void.class, "pkg_v0");
+        testBind(Example.class, void.class, "pri_v0");
+        testBind(Example.class, Object.class, "v1", Object.class);
+        testBind(Example.class, Object.class, "v2", Object.class, Object.class);
+        testBind(Example.class, Object.class, "v2", Object.class, int.class);
+        testBind(Example.class, Object.class, "v2", int.class, Object.class);
+        testBind(Example.class, Object.class, "v2", int.class, int.class);
+        testBind(false, Example.class, void.class, "bogus");
+        testBind(SubExample.class, void.class, "Sub/v0");
+        testBind(SubExample.class, void.class, "Sub/pkg_v0");
+        testBind(IntExample.Impl.class, void.class, "Int/v0");
+    }
+
+    void testBind(Class<?> defc, Class<?> ret, String name, Class<?>... params) {
+        testBind(true, defc, ret, name, params);
+    }
+    void testBind(boolean positive, Class<?> defc, Class<?> ret, String name, Class<?>... params) {
+        String methodName = name.substring(1 + name.indexOf('/'));  // foo/bar => foo
+        MethodType type = MethodType.make(ret, params);
+        Object receiver = randomArg(defc);
+        MethodHandle target = null;
+        RuntimeException noAccess = null;
+        try {
+            target = MethodHandles.bind(receiver, methodName, type);
+        } catch (NoAccessException ex) {
+            noAccess = ex;
+        }
+        System.out.println("bind "+receiver+"."+name+"/"+type+" => "+target
+                +(noAccess == null ? "" : " !! "+noAccess));
+        if (positive && noAccess != null)  throw noAccess;
+        assertEquals(positive, target != null);
+        if (!positive)  return; // negative test failed as expected
+        assertEquals(type, target.type());
+        Object[] args = randomArgs(params);
+        printCalled(target, name, args);
+        MethodHandles.invoke(target, args);
+        Object[] argsWithReceiver = cat(array(Object[].class, receiver), args);
+        assertCalled(name, argsWithReceiver);
+        System.out.print(':');
+    }
+
+    @Test
+    public void testUnreflect() {
+        if (CAN_SKIP_WORKING)  return;
+        System.out.println("unreflect");
+        testUnreflect(Example.class, true, void.class, "s0");
+        testUnreflect(Example.class, true, void.class, "pkg_s0");
+        testUnreflect(Example.class, true, void.class, "pri_s0");
+
+        testUnreflect(Example.class, true, Object.class, "s1", Object.class);
+        testUnreflect(Example.class, true, Object.class, "s2", int.class);
+        //testUnreflect(Example.class, true, Object.class, "s3", long.class);
+        //testUnreflect(Example.class, true, Object.class, "s4", int.class, int.class);
+        //testUnreflect(Example.class, true, Object.class, "s5", long.class, int.class);
+        //testUnreflect(Example.class, true, Object.class, "s6", int.class, long.class);
+
+        testUnreflect(Example.class, false, void.class, "v0");
+        testUnreflect(Example.class, false, void.class, "pkg_v0");
+        testUnreflect(Example.class, false, void.class, "pri_v0");
+        testUnreflect(Example.class, false, Object.class, "v1", Object.class);
+        testUnreflect(Example.class, false, Object.class, "v2", Object.class, Object.class);
+        testUnreflect(Example.class, false, Object.class, "v2", Object.class, int.class);
+        testUnreflect(Example.class, false, Object.class, "v2", int.class, Object.class);
+        testUnreflect(Example.class, false, Object.class, "v2", int.class, int.class);
+    }
+
+    void testUnreflect(Class<?> defc, boolean isStatic, Class<?> ret, String name, Class<?>... params) {
+        testUnreflect(true, defc, isStatic, ret, name, params);
+    }
+    void testUnreflect(boolean positive, Class<?> defc, boolean isStatic, Class<?> ret, String name, Class<?>... params) {
+        MethodType type = MethodType.make(ret, params);
+        Method rmethod = null;
+        MethodHandle target = null;
+        RuntimeException noAccess = null;
+        try {
+            rmethod = defc.getDeclaredMethod(name, params);
+        } catch (NoSuchMethodException ex) {
+            throw new NoAccessException(ex);
+        }
+        MemberName mname = new MemberName(rmethod);
+        assertEquals(isStatic, mname.isStatic());
+        try {
+            target = Example.unreflect(rmethod);
+        } catch (NoAccessException ex) {
+            noAccess = ex;
+        }
+        System.out.println("unreflect "+defc+"."+name+"/"+type+" => "+target
+                +(noAccess == null ? "" : " !! "+noAccess));
+        if (positive && noAccess != null)  throw noAccess;
+        assertEquals(positive, target != null);
+        if (!positive)  return; // negative test failed as expected
+        Class<?>[] paramsMaybeWithSelf = params;
+        if (!isStatic) {
+            paramsMaybeWithSelf = cat(array(Class[].class, defc), params);
+        }
+        MethodType typeMaybeWithSelf = MethodType.make(ret, paramsMaybeWithSelf);
+        assertEquals(typeMaybeWithSelf, target.type());
+        Object[] argsMaybeWithSelf = randomArgs(paramsMaybeWithSelf);
+        printCalled(target, name, argsMaybeWithSelf);
+        MethodHandles.invoke(target, argsMaybeWithSelf);
+        assertCalled(name, argsMaybeWithSelf);
+        System.out.print(':');
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testUnreflectSpecial() {
+        System.out.println("unreflectSpecial");
+        Method m = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.unreflectSpecial(m, Example.class);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testUnreflectGetter() {
+        System.out.println("unreflectGetter");
+        Field f = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.unreflectGetter(f);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testUnreflectSetter() {
+        System.out.println("unreflectSetter");
+        Field f = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.unreflectSetter(f);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testArrayElementGetter() {
+        System.out.println("arrayElementGetter");
+        Class<?> arrayClass = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.arrayElementGetter(arrayClass);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testArrayElementSetter() {
+        System.out.println("arrayElementSetter");
+        Class<?> arrayClass = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.arrayElementSetter(arrayClass);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    static class Callee {
+        static Object id() { return called("id"); }
+        static Object id(Object x) { return called("id", x); }
+        static Object id(Object x, Object y) { return called("id", x, y); }
+        static Object id(Object x, Object y, Object z) { return called("id", x, y, z); }
+        static Object id(Object... vx) { return called("id", vx); }
+        static MethodHandle ofType(int n) {
+            return ofType(Object.class, n);
+        }
+        static MethodHandle ofType(Class<?> rtype, int n) {
+            if (n == -1)
+                return ofType(MethodType.make(rtype, Object[].class));
+            return ofType(MethodType.makeGeneric(n).changeReturnType(rtype));
+        }
+        static MethodHandle ofType(Class<?> rtype, Class<?>... ptypes) {
+            return ofType(MethodType.make(rtype, ptypes));
+        }
+        static MethodHandle ofType(MethodType type) {
+            Class<?> rtype = type.returnType();
+            String pfx = "";
+            if (rtype != Object.class)
+                pfx = rtype.getSimpleName().substring(0, 1).toLowerCase();
+            String name = pfx+"id";
+            return MethodHandles.findStatic(Callee.class, name, type);
+        }
+    }
+
+    @Test
+    public void testConvertArguments_pairwise() {
+        System.out.println("convertArguments/pairwise");
+        testConvert(Callee.ofType(1), null, "id", String.class);
+        testConvert(Callee.ofType(1), null, "id", Integer.class);
+        testConvert(Callee.ofType(1), null, "id", int.class);
+        testConvert(Callee.ofType(1), null, "id", short.class);
+    }
+
+    void testConvert(MethodHandle id, Class<?> rtype, String name, Class<?>... params) {
+        testConvert(true, id, rtype, name, params);
+    }
+
+    void testConvert(boolean positive, MethodHandle id, Class<?> rtype, String name, Class<?>... params) {
+        MethodType idType = id.type();
+        if (rtype == null)  rtype = idType.returnType();
+        for (int i = 0; i < params.length; i++) {
+            if (params[i] == null)  params[i] = idType.parameterType(i);
+        }
+        MethodType type = MethodType.make(rtype, params);
+        MethodHandle target = null;
+        RuntimeException error = null;
+        try {
+            target = MethodHandles.convertArguments(id, type);
+        } catch (RuntimeException ex) {
+            error = ex;
+        }
+        System.out.println("convert "+id+ " to "+type+" => "+target
+                +(error == null ? "" : " !! "+error));
+        if (positive && error != null)  throw error;
+        assertEquals(positive, target != null);
+        if (!positive)  return; // negative test failed as expected
+        assertEquals(type, target.type());
+        Object[] args = randomArgs(type.parameterArray());
+        printCalled(target, id.toString(), args);
+        Object result = MethodHandles.invoke(target, args);
+        assertCalled(name, args);
+        System.out.print(':');
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testSpreadArguments() {
+        System.out.println("spreadArguments");
+        MethodHandle target = null;
+        MethodType newType = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.spreadArguments(target, newType);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testCollectArguments() {
+        System.out.println("collectArguments");
+        MethodHandle target = null;
+        MethodType newType = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.collectArguments(target, newType);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testInsertArgument_MethodHandle_Object() {
+        System.out.println("insertArgument");
+        MethodHandle target = null;
+        Object value = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.insertArgument(target, value);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testAppendArgument() {
+        System.out.println("appendArgument");
+        MethodHandle target = null;
+        Object value = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.appendArgument(target, value);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testInsertArgument_3args() {
+        System.out.println("insertArgument");
+        MethodHandle target = null;
+        Object value = null;
+        int pos = 0;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.insertArgument(target, value, pos);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testDropArguments() {
+        System.out.println("dropArguments");
+        MethodHandle target = null;
+        int pos = 0;
+        Class<?>[] valueTypes = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.dropArguments(target, pos, valueTypes);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testGuardWithTest() {
+        System.out.println("guardWithTest");
+        MethodHandle test = null;
+        MethodHandle target = null;
+        MethodHandle fallback = null;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.guardWithTest(test, target, fallback);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+    @Test @Ignore("unimplemented")
+    public void testCombineArguments() {
+        System.out.println("checkArguments");
+        MethodHandle target = null;
+        MethodHandle checker = null;
+        int pos = 0;
+        MethodHandle expResult = null;
+        MethodHandle result = MethodHandles.combineArguments(target, checker, pos);
+        assertEquals(expResult, result);
+        fail("The test case is a prototype.");
+    }
+
+}
\ No newline at end of file
diff --git a/src/share/projects/meth/test/jdk/java/dyn/MethodTypeTest.java b/src/share/projects/meth/test/jdk/java/dyn/MethodTypeTest.java
new file mode 100644
--- /dev/null
+++ b/src/share/projects/meth/test/jdk/java/dyn/MethodTypeTest.java
@@ -0,0 +1,412 @@
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package jdk.java.dyn;
+
+import sun.dyn.MemberName;
+import java.dyn.MethodType;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.junit.*;
+import static org.junit.Assert.*;
+
+/**
+ *
+ * @author jrose
+ */
+public class MethodTypeTest {
+
+    private Class<?> rtype;
+    private Class<?>[] ptypes;
+    private MethodType mt_viS, mt_OO2, mt_vv, mt_Vv, mt_Ov;
+    private MethodType mt_iSI, mt_ISi, mt_ISI, mt_iSi;
+    private MethodType mt_viO, mt_iO2, mt_OOi, mt_iOi;
+    private MethodType mt_VIO, mt_IO2, mt_OOI, mt_IOI, mt_VIS;
+    private Method compareTo;
+
+    @Before
+    public void setUp() throws Exception {
+        rtype = void.class;
+        ptypes = new Class<?>[] { int.class, String.class };
+
+        mt_viS = MethodType.make(void.class, int.class, String.class);
+        mt_OO2 = MethodType.make(Object.class, Object.class, Object.class);
+        mt_vv = MethodType.make(void.class);
+        mt_Vv = MethodType.make(Void.class);
+        mt_Ov = MethodType.make(Object.class);
+        mt_iSI = MethodType.make(int.class, String.class, Integer.class);
+        mt_ISi = MethodType.make(Integer.class, String.class, int.class);
+        mt_ISI = MethodType.make(Integer.class, String.class, Integer.class);
+        mt_iSi = MethodType.make(int.class, String.class, int.class);
+
+        compareTo = String.class.getDeclaredMethod("compareTo", String.class);
+
+        mt_viO = MethodType.make(void.class, int.class, Object.class);
+        mt_iO2 = MethodType.make(int.class, Object.class, Object.class);
+        mt_OOi = MethodType.make(Object.class, Object.class, int.class);
+        mt_iOi = MethodType.make(int.class, Object.class, int.class);
+
+        mt_VIO = MethodType.make(Void.class, Integer.class, Object.class);
+        mt_IO2 = MethodType.make(Integer.class, Object.class, Object.class);
+        mt_OOI = MethodType.make(Object.class, Object.class, Integer.class);
+        mt_IOI = MethodType.make(Integer.class, Object.class, Integer.class);
+        mt_VIS = MethodType.make(Void.class, Integer.class, String.class);
+
+    }
+
+    @After
+    public void tearDown() throws Exception {
+    }
+
+    /**
+     * Test of make method, of class MethodType.
+     */
+    @Test
+    public void testMake_Class_ClassArr() {
+        System.out.println("make (from type array)");
+        MethodType result = MethodType.make(rtype, ptypes);
+        assertEquals(mt_viS, result);
+    }
+
+    /**
+     * Test of make method, of class MethodType.
+     */
+    @Test
+    public void testMake_Class_List() {
+        System.out.println("make (from type list)");
+        MethodType result = MethodType.make(rtype, Arrays.asList(ptypes));
+        assertEquals(mt_viS, result);
+    }
+
+    /**
+     * Test of make method, of class MethodType.
+     */
+    @Test
+    public void testMake_3args() {
+        System.out.println("make (from type with varargs)");
+        MethodType result = MethodType.make(rtype, ptypes[0], ptypes[1]);
+        assertEquals(mt_viS, result);
+    }
+
+    /**
+     * Test of make method, of class MethodType.
+     */
+    @Test
+    public void testMake_Class() {
+        System.out.println("make (from single type)");
+        Class<?> rt = Integer.class;
+        MethodType expResult = MethodType.make(rt, new Class<?>[0]);
+        MethodType result = MethodType.make(rt);
+        assertEquals(expResult, result);
+    }
+
+    @Test
+    public void testMakeGeneric() {
+        System.out.println("makeGeneric");
+        int objectArgCount = 2;
+        MethodType expResult = mt_OO2;
+        MethodType result = MethodType.makeGeneric(objectArgCount);
+        assertEquals(expResult, result);
+    }
+
+    /**
+     * Test of make method, of class MethodType.
+     */
+    @Test
+    public void testMake_Method() {
+        System.out.println("make (via MemberName.getMethodType)");
+        MethodType expResult = MethodType.make(int.class, String.class);
+        MemberName name = new MemberName(compareTo);
+        MethodType result = name.getMethodType();
+        assertEquals(expResult, result);
+    }
+
+    /**
+     * Test of make method, of class MethodType.
+     */
+    @Test
+    public void testMake_MethodType() {
+        System.out.println("make (from rtype, MethodType)");
+        MethodType expResult = mt_iO2;
+        MethodType result = MethodType.make(int.class, mt_IO2);
+        assertEquals(expResult, result);
+    }
+
+    /**
+     * Test of make method, of class MethodType.
+     */
+    @Test
+    public void testMake_String_ClassLoader() {
+        System.out.println("make (from bytecode signature)");
+        ClassLoader loader = null;
+        MethodType[] instances = {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSI, mt_ISi, mt_ISI, mt_iSi};
+        String obj = "Ljava/lang/Object;";
+        assertEquals(obj, concat(Object.class));
+        String[] expResults = {
+            "(ILjava/lang/String;)V",
+            concat("(", obj, 2, ")", Object.class),
+            "()V", "()"+obj,
+            concat("(", String.class, Integer.class, ")I"),
+            concat("(", String.class, "I)", Integer.class),
+            concat("(", String.class, Integer.class, ")", Integer.class),
+            concat("(", String.class, "I)I")
+        };
+        for (int i = 0; i < instances.length; i++) {
+            MethodType instance = instances[i];
+            String result = instance.toBytecodeString();
+            assertEquals("#"+i, expResults[i], result);
+            MethodType parsed = MethodType.fromBytecodeString(result, loader);
+            assertEquals("--#"+i, instance, parsed);
+        }
+    }
+    private static String concat(Object... parts) {
+        StringBuilder sb = new StringBuilder();
+        Object prevPart = "";
+        for (Object part : parts) {
+            if (part instanceof Class) {
+                part = "L"+((Class)part).getName()+";";
+            }
+            if (part instanceof Integer) {
+                for (int n = (Integer) part; n > 1; n--)
+                    sb.append(prevPart);
+                part = "";
+            }
+            sb.append(part);
+            prevPart = part;
+        }
+        return sb.toString().replace('.', '/');
+    }
+
+    @Test
+    public void testHasPrimitives() {
+        System.out.println("hasPrimitives");
+        MethodType[] instances = {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSI, mt_ISi, mt_ISI, mt_iSi};
+        boolean[] expResults =   {true,   false,  true,  false, true,   true,   false,  true};
+        for (int i = 0; i < instances.length; i++) {
+            boolean result = instances[i].hasPrimitives();
+            assertEquals("#"+i, expResults[i], result);
+        }
+    }
+
+    @Test
+    public void testHasWrappers() {
+        System.out.println("hasWrappers");
+        MethodType[] instances = {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSI, mt_ISi, mt_ISI, mt_iSi};
+        boolean[] expResults =   {false,  false,  false, false, true,   true,   true,   false};
+        for (int i = 0; i < instances.length; i++) {
+            boolean result = instances[i].hasWrappers();
+            assertEquals("#"+i, expResults[i], result);
+        }
+    }
+
+    @Test
+    public void testErase() {
+        System.out.println("erase");
+        MethodType[] instances  = {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSI, mt_ISi, mt_ISI, mt_iSi};
+        MethodType[] expResults = {mt_viO, mt_OO2, mt_vv, mt_Ov, mt_iO2, mt_OOi, mt_OO2, mt_iOi};
+        for (int i = 0; i < instances.length; i++) {
+            MethodType result = instances[i].erase();
+            assertEquals("#"+i, expResults[i], result);
+        }
+    }
+
+    @Test
+    public void testEraseWrap() {
+        System.out.println("eraseWrap");
+        MethodType[] instances  = {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSI, mt_ISi, mt_ISI, mt_iSi};
+        MethodType[] expResults = {mt_VIO, mt_OO2, mt_Vv, mt_Ov, mt_IO2, mt_OOI, mt_OO2, mt_IOI};
+        for (int i = 0; i < instances.length; i++) {
+            MethodType result = instances[i].eraseWrap();
+            assertEquals("#"+i, expResults[i], result);
+        }
+    }
+
+    @Test
+    public void testGeneric() {
+        System.out.println("generic");
+        MethodType[] instances =  {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSI, mt_ISi, mt_ISI, mt_iSi};
+        MethodType[] expResults = {mt_OO2, mt_OO2, mt_Ov, mt_Ov, mt_OO2, mt_OO2, mt_OO2, mt_OO2};
+        for (int i = 0; i < instances.length; i++) {
+            MethodType result = instances[i].generic();
+            assertEquals("#"+i, expResults[i], result);
+        }
+    }
+
+    @Test
+    public void testWrap() {
+        System.out.println("wrap");
+        MethodType[] instances =  {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSI, mt_ISi, mt_ISI, mt_iSi};
+        MethodType[] expResults = {mt_VIS, mt_OO2, mt_Vv, mt_Ov, mt_ISI, mt_ISI, mt_ISI, mt_ISI};
+        for (int i = 0; i < instances.length; i++) {
+            MethodType result = instances[i].wrap();
+            assertEquals("#"+i, expResults[i], result);
+        }
+    }
+
+    @Test
+    public void testUnwrap() {
+        System.out.println("unwrap");
+        MethodType[] instances =  {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSI, mt_ISi, mt_ISI, mt_iSi};
+        MethodType[] expResults = {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSi, mt_iSi, mt_iSi, mt_iSi};
+        for (int i = 0; i < instances.length; i++) {
+            MethodType result = instances[i].unwrap();
+            assertEquals("#"+i, expResults[i], result);
+        }
+    }
+
+    /**
+     * Test of parameterType method, of class MethodType.
+     */
+    @Test
+    public void testParameterType() {
+        System.out.println("parameterType");
+        for (int num = 0; num < ptypes.length; num++) {
+            MethodType instance = mt_viS;
+            Class<?> expResult = ptypes[num];
+            Class<?> result = instance.parameterType(num);
+            assertEquals(expResult, result);
+        }
+    }
+
+    /**
+     * Test of parameterCount method, of class MethodType.
+     */
+    @Test
+    public void testParameterCount() {
+        System.out.println("parameterCount");
+        MethodType instance = mt_viS;
+        int expResult = 2;
+        int result = instance.parameterCount();
+        assertEquals(expResult, result);
+    }
+
+    /**
+     * Test of returnType method, of class MethodType.
+     */
+    @Test
+    public void testReturnType() {
+        System.out.println("returnType");
+        MethodType instance = mt_viS;
+        Class<?> expResult = void.class;
+        Class<?> result = instance.returnType();
+        assertEquals(expResult, result);
+    }
+
+    /**
+     * Test of parameterList method, of class MethodType.
+     */
+    @Test
+    public void testParameterList() {
+        System.out.println("parameterList");
+        MethodType instance = mt_viS;
+        List<Class<?>> expResult = Arrays.asList(ptypes);
+        List<Class<?>> result = instance.parameterList();
+        assertEquals(expResult, result);
+    }
+
+    /**
+     * Test of parameterArray method, of class MethodType.
+     */
+    @Test
+    public void testParameterArray() {
+        System.out.println("parameterArray");
+        MethodType instance = mt_viS;
+        Class<?>[] expResult = ptypes;
+        Class<?>[] result = instance.parameterArray();
+        assertEquals(Arrays.asList(expResult), Arrays.asList(result));
+    }
+
+    /**
+     * Test of equals method, of class MethodType.
+     */
+    @Test
+    public void testEquals_Object() {
+        System.out.println("equals");
+        Object x = null;
+        MethodType instance = mt_viS;
+        boolean expResult = false;
+        boolean result = instance.equals(x);
+        assertEquals(expResult, result);
+    }
+
+    /**
+     * Test of equals method, of class MethodType.
+     */
+    @Test
+    public void testEquals_MethodType() {
+        System.out.println("equals");
+        MethodType that = mt_viS;
+        MethodType instance = mt_viS;
+        boolean expResult = true;
+        boolean result = instance.equals(that);
+        assertEquals(expResult, result);
+    }
+
+    /**
+     * Test of hashCode method, of class MethodType.
+     */
+    @Test
+    public void testHashCode() {
+        System.out.println("hashCode");
+        MethodType instance = mt_viS;
+        ArrayList<Class<?>> types = new ArrayList<Class<?>>();
+        types.add(instance.returnType());
+        types.addAll(instance.parameterList());
+        int expResult = types.hashCode();
+        int result = instance.hashCode();
+        assertEquals(expResult, result);
+    }
+
+    /**
+     * Test of toString method, of class MethodType.
+     */
+    @Test
+    public void testToString() {
+        System.out.println("toString");
+        MethodType[] instances = {mt_viS, mt_OO2, mt_vv, mt_Ov, mt_iSI, mt_ISi, mt_ISI, mt_iSi};
+        //String expResult = "void[int, class java.lang.String]";
+        String[] expResults = {
+            "(int,java.lang.String)void",
+            "(java.lang.Object,java.lang.Object)java.lang.Object",
+            "()void",
+            "()java.lang.Object",
+            "(java.lang.String,java.lang.Integer)int",
+            "(java.lang.String,int)java.lang.Integer",
+            "(java.lang.String,java.lang.Integer)java.lang.Integer",
+            "(java.lang.String,int)int"
+        };
+        for (int i = 0; i < instances.length; i++) {
+            MethodType instance = instances[i];
+            String result = instance.toString();
+            System.out.println("#"+i+":"+result);
+            assertEquals("#"+i, expResults[i], result);
+        }
+    }
+
+
+}

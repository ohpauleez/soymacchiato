6982752: dynamic languages need to decorate types with runtime information
Summary: Add ClassValue
Reviewed-by: twisti

diff --git a/src/share/classes/java/dyn/ClassValue.java b/src/share/classes/java/dyn/ClassValue.java
new file mode 100644
--- /dev/null
+++ b/src/share/classes/java/dyn/ClassValue.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.dyn;
+
+import java.util.WeakHashMap;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+
+/**
+ * Associates a derived, lazily computed class-specific value
+ * with (potentially) every class.
+ * <p>
+ * For any given class, the method {@link #get get} is used to
+ * query the class-specific value associated by this object with that class.
+ * The given class is passed as the parameter to {@link #get get}.
+ * <p>
+ * The abstract method {@link #computeValue computeValue} is used to compute the value
+ * once per class, as each distinct class is encountered.
+ * The given class is also passed as the parameter to {@link #computeValue computeValue}.
+ * <p>
+ * For example, to memoize the number of members declared in each class:
+ * <blockquote><pre>
+public static int declaredMemberCount(Class&lt;?&gt; type) {
+  return COUNT_VALUE.get(type);
+}
+private static final ClassValue&lt;Integer&gt;
+  COUNT_VALUE = new ClassValue&lt;Integer&gt;() {
+    protected Integer computeValue(Class&lt;?&gt; type) {
+      int ndm = type.getDeclaredMethods().length;
+      ndm += type.getDeclaredConstructors().length;
+      int ndf = type.getDeclaredFields().length;
+      int ndc = type.getDeclaredClasses().length;
+      return ndm + ndf + ndc;
+    }
+  };
+ * </pre></blockquote>
+ * @author John Rose, JSR 292 EG
+ */
+public abstract class ClassValue<T> {
+    /**
+     * Computes the given class's derived value for this {@code ClassValue}.
+     * <p>
+     * For any particular class, this method will be invoked recursively within
+     * the first thread that {@linkplain #get gets}
+     * the class-specific value for that class.
+     * <p>
+     * Normally, this method is invoked at most once per class,
+     * but it may be invoked again in case of subsequent invocations
+     * of {@link #remove remove} followed by {@link #get get}.
+     *
+     * @return the computed value for this thread-local
+     */
+    protected abstract T computeValue(Class<?> type);
+
+    /**
+     * Creates a new class value.
+     */
+    protected ClassValue() {
+    }
+
+    /**
+     * Returns the value associated by this object with the given class.
+     * If no value has yet been computed for that class, it is obtained by
+     * by an invocation of {@link #computeValue}.
+     * <p>
+     * The actual installation of the value on the class
+     * is performed while the class's synchronization lock
+     * is held.  At that point, if racing threads have
+     * computed values, one is chosen, and returned to
+     * all the racing threads.
+     *
+     * @return the current thread's value of this thread-local
+     */
+    public T get(Class<?> type) {
+        ClassValueMap map = getMap(type);
+        if (map != null) {
+            Object x = map.get(this);
+            if (x != null) {
+                return (T) map.unmaskNull(x);
+            }
+        }
+        return setComputedValue(type);
+    }
+
+    /**
+     * Removes the associated value for the given class.
+     * If this value is subsequently {@linkplain #get gotten} for the same class,
+     * its value will be initialized again by invoking {@link #computeValue computeValue}.
+     */
+    public void remove(Class<?> type) {
+        ClassValueMap map = getMap(type);
+        if (map != null) {
+            synchronized (map) {
+                map.remove(this);
+            }
+        }
+    }
+
+    /// Implementation...
+
+    /** The hash code for this type is based on the identity of the object. */
+    // and the hash code happens to be well-dispersed for power-of-two tables
+    public final int hashCode() { return hashCode; }
+    private final int hashCode = HASH_CODES.getAndAdd(0x61c88647);
+    private static final AtomicInteger HASH_CODES = new AtomicInteger();
+
+    private static final AtomicInteger STORE_BARRIER = new AtomicInteger();
+
+    /** Slow path for {@link #get}. */
+    private T setComputedValue(Class<?> type) {
+        ClassValueMap map = getMap(type);
+        if (map == null) {
+            map = initializeMap(type);
+        }
+        T value = computeValue(type);
+        STORE_BARRIER.lazySet(0);
+        // All stores pending from computeValue are completed.
+        synchronized (map) {
+            // Warm up the table with a null entry.
+            map.preInitializeEntry(this);
+        }
+        // All stores pending from table expansion are completed.
+        synchronized (map) {
+            value = (T) map.initializeEntry(this, value);
+            // One might fear a possible race condition here
+            // if the code for map.put has flushed the write
+            // to map.table[*] before the writes to the Map.Entry
+            // are done.  This is not possible, since we have
+            // warmed up the table with an empty entry.
+        }
+        return value;
+    }
+
+    // Replace this map by a per-class slot.
+    private static final WeakHashMap<Class<?>, ClassValueMap> ROOT
+        = new WeakHashMap<Class<?>, ClassValueMap>();
+
+    private static ClassValueMap getMap(Class<?> type) {
+        return ROOT.get(type);
+    }
+
+    private static ClassValueMap initializeMap(Class<?> type) {
+        synchronized (ClassValue.class) {
+            ClassValueMap map = ROOT.get(type);
+            if (map == null)
+                ROOT.put(type, map = new ClassValueMap());
+            return map;
+        }
+    }
+
+    static class ClassValueMap extends WeakHashMap<ClassValue, Object> {
+        /** Make sure this table contains an Entry for the given key, even if it is empty. */
+        void preInitializeEntry(ClassValue key) {
+            if (!this.containsKey(key))
+                this.put(key, null);
+        }
+        /** Make sure this table contains a non-empty Entry for the given key. */
+        Object initializeEntry(ClassValue key, Object value) {
+            Object prior = this.get(key);
+            if (prior != null) {
+                return unmaskNull(prior);
+            }
+            this.put(key, maskNull(value));
+            return value;
+        }
+
+        Object maskNull(Object x) {
+            return x == null ? this : x;
+        }
+        Object unmaskNull(Object x) {
+            return x == this ? null : x;
+        }
+    }
+}
diff --git a/test/java/dyn/ClassValueTest.java b/test/java/dyn/ClassValueTest.java
new file mode 100644
--- /dev/null
+++ b/test/java/dyn/ClassValueTest.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+ * @summary tests for class-specific values
+ * @compile ClassValueTest.java
+ * @run junit/othervm test.java.dyn.ClassValueTest
+ */
+
+/*
+  Manually:
+   $ $JAVA7X_HOME/bin/javac -d foo -cp $JUNIT4_JAR test/java/dyn/ClassValueTest.java
+   $ $JAVA7X_HOME/bin/java -cp foo:$JUNIT4_JAR org.junit.runner.JUnitCore test.java.dyn.ClassValueTest
+  Output: .testAdd => 1000 : Integer
+ */
+
+package test.java.dyn;
+
+import java.util.*;
+
+import java.dyn.*;
+
+import org.junit.*;
+import static org.junit.Assert.*;
+
+/**
+ * @author jrose
+ */
+public class ClassValueTest {
+    static String nameForCV1(Class<?> type) {
+        return "CV1:" + type.getName();
+    }
+    static int countForCV1;
+    static final ClassValue<String> CV1 = new ClassValue<String>() {
+        protected String computeValue(Class<?> type) {
+            countForCV1++;
+            return nameForCV1(type);
+        }
+    };
+
+    static final Class[] CLASSES = {
+        String.class,
+        Integer.class,
+        int.class,
+        boolean[].class,
+        char[][].class,
+        ClassValueTest.class
+    };
+
+    @Test
+    public void testGet() {
+        countForCV1 = 0;
+        for (Class c : CLASSES) {
+            assertEquals(nameForCV1(c), CV1.get(c));
+        }
+        assertEquals(CLASSES.length, countForCV1);
+        for (Class c : CLASSES) {
+            assertEquals(nameForCV1(c), CV1.get(c));
+        }
+        assertEquals(CLASSES.length, countForCV1);
+    }
+
+    @Test
+    public void testRemove() {
+        for (Class c : CLASSES) {
+            CV1.get(c);
+        }
+        countForCV1 = 0;
+        int REMCOUNT = 3;
+        for (int i = 0; i < REMCOUNT; i++) {
+            CV1.remove(CLASSES[i]);
+        }
+        assertEquals(0, countForCV1);  // no change
+        for (Class c : CLASSES) {
+            assertEquals(nameForCV1(c), CV1.get(c));
+        }
+        assertEquals(REMCOUNT, countForCV1);
+    }
+
+    static String nameForCVN(Class<?> type, int n) {
+        return "CV[" + n + "]" + type.getName();
+    }
+    static int countForCVN;
+    static class CVN extends ClassValue<String> {
+        final int n;
+        CVN(int n) { this.n = n; }
+        protected String computeValue(Class<?> type) {
+            countForCVN++;
+            return nameForCVN(type, n);
+        }
+    };
+
+    @Test
+    public void testGetMany() {
+        int CVN_COUNT1 = 100, CVN_COUNT2 = 100;
+        CVN cvns[] = new CVN[CVN_COUNT1 * CVN_COUNT2];
+        for (int n = 0; n < cvns.length; n++) {
+            cvns[n] = new CVN(n);
+        }
+        countForCVN = 0;
+        for (int pass = 0; pass <= 2; pass++) {
+            for (int i1 = 0; i1 < CVN_COUNT1; i1++) {
+                eachClass:
+                for (Class c : CLASSES) {
+                    for (int i2 = 0; i2 < CVN_COUNT2; i2++) {
+                        int n = i1*CVN_COUNT2 + i2;
+                        assertEquals(0, countForCVN);
+                        assertEquals(nameForCVN(c, n), cvns[n].get(c));
+                        cvns[n].get(c);  //get it again
+                        //System.out.println("getting "+n+":"+cvns[n].get(c));
+                        boolean doremove = (((i1 + i2) & 3) == 0);
+                        switch (pass) {
+                        case 0:
+                            assertEquals(1, countForCVN);
+                            break;
+                        case 1:
+                            // remove on middle pass
+                            assertEquals(0, countForCVN);
+                            if (doremove) {
+                                //System.out.println("removing "+n+":"+cvns[n].get(c));
+                                cvns[n].remove(c);
+                                assertEquals(0, countForCVN);
+                            }
+                            break;
+                        case 2:
+                            assertEquals(doremove ? 1 : 0, countForCVN);
+                            break;
+                        }
+                        countForCVN = 0;
+                        if (i1 > i2 && i1 < i2+5)  continue eachClass;  // leave diagonal gap
+                    }
+                }
+            }
+        }
+        assertEquals(countForCVN, 0);
+        for (int n = 0; n < cvns.length; n++) {
+            for (Class c : CLASSES) {
+                assertEquals(nameForCVN(c, n), cvns[n].get(c));
+            }
+        }
+    }
+
+    static class MFC100 { MFC100(int x){} }
+    static class MFC110 { int x; MFC110(int x){this.x = x;} }
+    static class MFC101 { MFC101(){} interface I { } }
+
+    @Test
+    public void testJavaDoc() {
+        assertEquals(1, declaredMemberCount(MFC100.class));
+        assertEquals(2, declaredMemberCount(MFC110.class));
+        assertEquals(2, declaredMemberCount(MFC101.class));
+    }
+
+{} /*---JAVADOC---*/
+public static int declaredMemberCount(Class<?> type) {
+  return COUNT_VALUE.get(type);
+}
+private static final ClassValue<Integer>
+  COUNT_VALUE = new ClassValue<Integer>() {
+    protected Integer computeValue(Class<?> type) {
+      int ndm = type.getDeclaredMethods().length;
+      ndm += type.getDeclaredConstructors().length;
+      int ndf = type.getDeclaredFields().length;
+      int ndc = type.getDeclaredClasses().length;
+      return ndm + ndf + ndc;
+    }
+  };
+{} /*---JAVADOC---*/
+
+}

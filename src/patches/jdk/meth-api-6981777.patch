6981777: implement JSR 292 EG adjustments from summer 2010
Reviewed-by: twisti

diff --git a/src/share/classes/java/dyn/BootstrapMethod.java b/src/share/classes/java/dyn/BootstrapMethod.java
deleted file mode 100644
--- a/src/share/classes/java/dyn/BootstrapMethod.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.dyn;
-
-import java.lang.annotation.*;
-
-/**
- * Annotation on InvokeDynamic method calls which requests the JVM to use a specific
- * <a href="package-summary.html#bsm">bootstrap method</a>
- * to link the call.  This annotation is not retained as such in the class file,
- * but is transformed into a constant-pool entry for the invokedynamic instruction which
- * specifies the desired bootstrap method.
- * <p>
- * If only the <code>value</code> is given, it must name a subclass of {@link CallSite}
- * with a constructor which accepts a class, string, and method type.
- * If the <code>value</code> and <code>name</code> are both given, there must be
- * a static method in the given class of the given name which accepts a class, string,
- * and method type, and returns a reference coercible to {@link CallSite}.
- * <p>
- * This annotation can be placed either on the return type of a single {@link InvokeDynamic}
- * call (see examples) or else it can be placed on an enclosing class or method, where it
- * determines a default bootstrap method for any {@link InvokeDynamic} calls which are not
- * specifically annotated with a bootstrap method.
- * Every {@link InvokeDynamic} call must be given a bootstrap method.
- * <p>
- * Examples:
-<blockquote><pre>
-&#064;BootstrapMethod(value=MyLanguageRuntime.class, name="bootstrapDynamic")
-String x = (String) InvokeDynamic.greet();
-//BSM => MyLanguageRuntime.bootstrapDynamic(Here.class, "greet", methodType(String.class))
-&#064;BootstrapMethod(MyCallSite.class)
-void example() throws Throwable {
-    InvokeDynamic.greet();
-    //BSM => new MyCallSite(Here.class, "greet", methodType(void.class))
-}
-</pre></blockquote>
- * <p>
- */
-@Target({ElementType.TYPE_USE,
-            // For defaulting every indy site within a class or method; cf. @SuppressWarnings:
-            ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR
-            })
-@Retention(RetentionPolicy.SOURCE)
-public @interface BootstrapMethod {
-    /** The class containing the bootstrap method. */
-    Class<?> value();
-
-    /** The name of the bootstrap method.
-     *  If this is the empty string, an instance of the bootstrap class is created,
-     *  and a constructor is invoked.
-     *  Otherwise, there must be a static method of the required name.
-     */
-    String name() default "";  // empty string denotes a constructor with 'new'
-
-    /** The argument types of the bootstrap method, as passed out by the JVM.
-     *  There is usually no reason to override the default.
-     */
-    Class<?>[] arguments() default {Class.class, String.class, MethodType.class};
-}
diff --git a/src/share/classes/java/dyn/CallSite.java b/src/share/classes/java/dyn/CallSite.java
--- a/src/share/classes/java/dyn/CallSite.java
+++ b/src/share/classes/java/dyn/CallSite.java
@@ -26,40 +26,34 @@
 package java.dyn;
 
 import sun.dyn.*;
+import sun.dyn.empty.Empty;
+import sun.misc.Unsafe;
 import java.util.Collection;
 
 /**
  * A {@code CallSite} is a holder for a variable {@link MethodHandle},
  * which is called its {@code target}.
- * Every call to a {@code CallSite} is delegated to the site's current target.
+ * An {@code invokedynamic} instruction linked to a {@code CallSite} delegates
+ * all calls to the site's current target.
  * <p>
- * A call site is initially created in an <em>unlinked</em> state,
- * which is distinguished by a null target variable.
- * Before the call site may be invoked (and before certain other
- * operations are attempted), the call site must be linked to
- * a non-null target.
+ * If a mutable target is not required, the {@code invokedynamic} instruction
+ * should be linked to a {@linkplain ConstantCallSite constant call site}.
+ * If a volatile target is required, because updates to the target must be
+ * reliably witnessed by other threads, the {@code invokedynamic} instruction
+ * should be linked to a {@linkplain VolatileCallSite volatile call site}.
  * <p>
  * A call site may be <em>relinked</em> by changing its target.
- * The new target must be non-null and must have the same
- * {@linkplain MethodHandle#type() type}
+ * The new target must have the same {@linkplain MethodHandle#type() type}
  * as the previous target.
  * Thus, though a call site can be relinked to a series of
  * successive targets, it cannot change its type.
  * <p>
- * Linkage happens once in the lifetime of any given {@code CallSite} object.
- * Because of call site invalidation, this linkage can be repeated for
- * a single {@code invokedynamic} instruction, with multiple {@code CallSite} objects.
- * When a {@code CallSite} is unlinked from an {@code invokedynamic} instruction,
- * the instruction is reset so that it is no longer associated with
- * the {@code CallSite} object, but the {@code CallSite} does not change
- * state.
- * <p>
  * Here is a sample use of call sites and bootstrap methods which links every
  * dynamic call site to print its arguments:
 <blockquote><pre><!-- see indy-demo/src/PrintArgsDemo.java -->
-&#064;BootstrapMethod(value=PrintArgsDemo.class, name="bootstrapDynamic")
 static void test() throws Throwable {
-    InvokeDynamic.baz("baz arg", 2, 3.14);
+    // THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION
+    InvokeDynamic[#bootstrapDynamic].baz("baz arg", 2, 3.14);
 }
 private static void printArgs(Object... args) {
   System.out.println(java.util.Arrays.deepToString(args));
@@ -71,16 +65,14 @@
   printArgs = lookup.findStatic(thisClass,
       "printArgs", MethodType.methodType(void.class, Object[].class));
 }
-private static CallSite bootstrapDynamic(Class caller, String name, MethodType type) {
+private static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {
   // ignore caller and name, but match the type:
-  return new CallSite(MethodHandles.collectArguments(printArgs, type));
+  return new ConstantCallSite(MethodHandles.collectArguments(printArgs, type));
 }
 </pre></blockquote>
  * @author John Rose, JSR 292 EG
  */
-public class CallSite
-    implements MethodHandleProvider
-{
+public class CallSite {
     private static final Access IMPL_TOKEN = Access.getToken();
 
     // Fields used only by the JVM.  Do not use or change.
@@ -88,61 +80,44 @@
     private int        vmindex;  // supplied by the JVM (BCI within calling method)
 
     // The actual payload of this call site:
-    private MethodHandle target;
+    /*package-private*/
+    MethodHandle target;
 
     // Remove this field for PFD and delete deprecated methods:
     private MemberName calleeNameRemoveForPFD;
 
     /**
-     * Make a blank call site object.
-     * Before it is returned from a bootstrap method, this {@code CallSite} object
-     * must be provided with
-     * a target method via a call to {@link CallSite#setTarget(MethodHandle) setTarget},
-     * or by a subclass override of {@link CallSite#initialTarget(Class,String,MethodType) initialTarget}.
+     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * Make a blank call site object with the given method type.
+     * An initial target method is supplied which will throw
+     * an {@link IllegalStateException} if called.
+     * <p>
+     * Before this {@code CallSite} object is returned from a bootstrap method,
+     * it is usually provided with a more useful target method,
+     * via a call to {@link CallSite#setTarget(MethodHandle) setTarget}.
      */
-    public CallSite() {
+    public CallSite(MethodType type) {
+        target = MethodHandles.invokers(type).uninitializedCallSite();
     }
 
     /**
      * Make a blank call site object, possibly equipped with an initial target method handle.
-     * The initial target reference may be null, in which case the {@code CallSite} object
-     * must be provided with a target method via a call to {@link CallSite#setTarget},
-     * or by a subclass override of {@link CallSite#initialTarget}.
-     * @param target the method handle which will be the initial target of the call site, or null if there is none yet
+     * @param target the method handle which will be the initial target of the call site
      */
     public CallSite(MethodHandle target) {
+        target.type();  // null check
         this.target = target;
     }
 
-    /** @deprecated transitional form defined in EDR but removed in PFD */
-    public CallSite(Class<?> caller, String name, MethodType type) {
-        this.calleeNameRemoveForPFD = new MemberName(caller, name, type);
-    }
-    /** @deprecated transitional form defined in EDR but removed in PFD */
-    public Class<?> callerClass() {
-        MemberName callee = this.calleeNameRemoveForPFD;
-        return callee == null ? null : callee.getDeclaringClass();
-    }
-    /** @deprecated transitional form defined in EDR but removed in PFD */
-    public String name() {
-        MemberName callee = this.calleeNameRemoveForPFD;
-        return callee == null ? null : callee.getName();
-    }
-    /** @deprecated transitional form defined in EDR but removed in PFD */
+    /**
+     * Report the type of this call site's target.
+     * Although targets may change, the call site's type can never change.
+     * The {@code setTarget} method enforces this invariant by refusing any new target that does
+     * not have the previous target's type.
+     * @return the type of the current target, which is also the type of any future target
+     */
     public MethodType type() {
-        MemberName callee = this.calleeNameRemoveForPFD;
-        return callee == null ? (target == null ? null : target.type()) : callee.getMethodType();
-    }
-    /** @deprecated transitional form defined in EDR but removed in PFD */
-    protected MethodHandle initialTarget() {
-        return initialTarget(callerClass(), name(), type());
-    }
-
-    /** Report if the JVM has linked this {@code CallSite} object to a dynamic call site instruction.
-     *  Once it is linked, it is never unlinked.
-     */
-    private boolean isLinked() {
-        return vmmethod != null;
+        return target.type();
     }
 
     /** Called from JVM (or low-level Java code) after the BSM returns the newly created CallSite.
@@ -152,68 +127,66 @@
                            MethodType type,
                            MemberName callerMethod,
                            int        callerBCI) {
-        if (this.isLinked()) {
+        if (this.vmmethod != null) {
+            // FIXME
             throw new InvokeDynamicBootstrapError("call site has already been linked to an invokedynamic instruction");
         }
-        MethodHandle target = this.target;
-        if (target == null) {
-            this.target = target = this.initialTarget(callerMethod.getDeclaringClass(), name, type);
-        }
-        if (!target.type().equals(type)) {
+        if (!this.type().equals(type)) {
             throw wrongTargetType(target, type);
         }
         this.vmindex  = callerBCI;
         this.vmmethod = callerMethod;
-        assert(this.isLinked());
     }
 
     /**
-     * Just after a call site is created by a bootstrap method handle,
-     * if the target has not been initialized by the factory method itself,
-     * the method {@code initialTarget} is called to produce an initial
-     * non-null target.  (Live call sites must never have null targets.)
+     * Report the current linkage state of the call site, a value which may change over time.
      * <p>
-     * The arguments are the same as those passed to the bootstrap method.
-     * Thus, a bootstrap method is free to ignore the arguments and simply
-     * create a "blank" {@code CallSite} object of an appropriate subclass.
+     * If a {@code CallSite} object is returned
+     * from the bootstrap method of the {@code invokedynamic} instruction,
+     * the {@code CallSite} is permanently bound to that instruction.
+     * When the {@code invokedynamic} instruction is executed, the target method
+     * of its associated call site object is invoked directly.
+     * It is as if the instruction calls {@code getTarget} and then
+     * calls {@link MethodHandle#invokeExact invokeExact} on the result.
      * <p>
-     * If the bootstrap method itself does not initialize the call site,
-     * this method must be overridden, because it just raises an
-     * {@code InvokeDynamicBootstrapError}, which in turn causes the
-     * linkage of the {@code invokedynamic} instruction to terminate
-     * abnormally.
-     * @deprecated transitional form defined in EDR but removed in PFD
-     */
-    protected MethodHandle initialTarget(Class<?> callerClass, String name, MethodType type) {
-        throw new InvokeDynamicBootstrapError("target must be initialized before call site is linked: "+name+type);
-    }
-
-    /**
-     * Report the current linkage state of the call site.  (This is mutable.)
-     * The value may not be null after the {@code CallSite} object is returned
-     * from the bootstrap method of the {@code invokedynamic} instruction.
-     * When an {@code invokedynamic} instruction is executed, the target method
-     * of its associated {@code call site} object is invoked directly,
-     * as if via {@link MethodHandle}{@code .invoke}.
-     * <p>
-     * The interactions of {@code getTarget} with memory are the same
+     * Unless specified differently by a subclass,
+     * the interactions of {@code getTarget} with memory are the same
      * as of a read from an ordinary variable, such as an array element or a
      * non-volatile, non-final field.
      * <p>
      * In particular, the current thread may choose to reuse the result
      * of a previous read of the target from memory, and may fail to see
      * a recent update to the target by another thread.
-     * @return the current linkage state of the call site
+     * <p>
+     * In a {@linkplain ConstantCallSite constant call site}, the {@code getTarget} method behaves
+     * like a read from a {@code final} field of the {@code CallSite}.
+     * <p>
+     * In a {@linkplain VolatileCallSite volatile call site}, the {@code getTarget} method behaves
+     * like a read from a {@code volatile} field of the {@code CallSite}.
+     * <p>
+     * This method may not be overridden by application code.
+     * @return the current linkage state of the call site, its target method handle
+     * @see ConstantCallSite
+     * @see VolatileCallSite
      * @see #setTarget
      */
-    public MethodHandle getTarget() {
+    public final MethodHandle getTarget() {
+        return getTarget0();
+    }
+
+    /**
+     * Privileged implementations can override this to force final or volatile semantics on getTarget.
+     */
+    /*package-private*/
+    MethodHandle getTarget0() {
         return target;
     }
 
     /**
      * Set the target method of this call site.
      * <p>
-     * The interactions of {@code setTarget} with memory are the same
+     * Unless a subclass of CallSite documents otherwise,
+     * the interactions of {@code setTarget} with memory are the same
      * as of a write to an ordinary variable, such as an array element or a
      * non-volatile, non-final field.
      * <p>
@@ -224,27 +197,23 @@
      * at any given call site.
      * @param newTarget the new target
      * @throws NullPointerException if the proposed new target is null
-     * @throws WrongMethodTypeException if the call site is linked and the proposed new target
+     * @throws WrongMethodTypeException if the proposed new target
      *         has a method type that differs from the previous target
      */
     public void setTarget(MethodHandle newTarget) {
+        checkTargetChange(this.target, newTarget);
+        setTargetNormal(newTarget);
+    }
+
+    void checkTargetChange(MethodHandle oldTarget, MethodHandle newTarget) {
+        MethodType oldType = oldTarget.type();
         MethodType newType = newTarget.type();  // null check!
-        MethodHandle oldTarget = this.target;
-        if (oldTarget == null) {
-            // CallSite is not yet linked.
-            assert(!isLinked());
-            this.target = newTarget;  // might be null!
-            return;
-        }
-        MethodType oldType = oldTarget.type();
-        if (!newTarget.type().equals(oldType))
+        if (!newType.equals(oldType))
             throw wrongTargetType(newTarget, oldType);
-        if (oldTarget != newTarget)
-            CallSiteImpl.setCallSiteTarget(IMPL_TOKEN, this, newTarget);
     }
 
     private static WrongMethodTypeException wrongTargetType(MethodHandle target, MethodType type) {
-        return new WrongMethodTypeException(String.valueOf(target)+target.type()+" should be of type "+type);
+        return new WrongMethodTypeException(String.valueOf(target)+" should be of type "+type);
     }
 
     /** Produce a printed representation that displays information about this call site
@@ -252,15 +221,14 @@
      */
     @Override
     public String toString() {
-        return "CallSite"+(target == null ? "" : target.type());
+        return super.toString() + type();
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle equivalent to an invokedynamic instruction
      * which has been linked to this call site.
-     * <p>If this call site is a {@link ConstantCallSite}, this method
-     * simply returns the call site's target, since that will not change.
+     * <p>If this call site is a {@linkplain ConstantCallSite constant call site},
+     * this method simply returns the call site's target, since that will never change.
      * <p>Otherwise, this method is equivalent to the following code:
      * <p><blockquote><pre>
      * MethodHandle getTarget, invoker, result;
@@ -271,8 +239,9 @@
      * @return a method handle which always invokes this call site's current target
      */
     public final MethodHandle dynamicInvoker() {
-        if (this instanceof ConstantCallSite)
-            return getTarget();  // will not change dynamically
+        if (this instanceof ConstantCallSite) {
+            return target;  // will not change dynamically
+        }
         MethodHandle getTarget = MethodHandleImpl.bindReceiver(IMPL_TOKEN, GET_TARGET, this);
         MethodHandle invoker = MethodHandles.exactInvoker(this.type());
         return MethodHandles.foldArguments(invoker, getTarget);
@@ -287,9 +256,34 @@
         }
     }
 
-    /** Implementation of {@link MethodHandleProvider} which returns {@code this.dynamicInvoker()}. */
-    public final MethodHandle asMethodHandle() { return dynamicInvoker(); }
+    /** This guy is rolled into the default target if a MethodType is supplied to the constructor. */
+    /*package-private*/
+    static Empty uninitializedCallSite() {
+        throw new IllegalStateException("uninitialized call site");
+    }
 
-    /** Implementation of {@link MethodHandleProvider}, which returns {@code this.dynamicInvoker().asType(type)}. */
-    public final MethodHandle asMethodHandle(MethodType type) { return dynamicInvoker().asType(type); }
+    // unsafe stuff:
+    private static final Unsafe unsafe = Unsafe.getUnsafe();
+    private static final long TARGET_OFFSET;
+
+    static {
+        try {
+            TARGET_OFFSET = unsafe.objectFieldOffset(CallSite.class.getDeclaredField("target"));
+        } catch (Exception ex) { throw new Error(ex); }
+    }
+
+    /*package-private*/
+    void setTargetNormal(MethodHandle newTarget) {
+        target = newTarget;
+        //CallSiteImpl.setCallSiteTarget(IMPL_TOKEN, this, newTarget);
+    }
+    /*package-private*/
+    MethodHandle getTargetVolatile() {
+        return (MethodHandle) unsafe.getObjectVolatile(this, TARGET_OFFSET);
+    }
+    /*package-private*/
+    void setTargetVolatile(MethodHandle newTarget) {
+        unsafe.putObjectVolatile(this, TARGET_OFFSET, newTarget);
+        //CallSiteImpl.setCallSiteTarget(IMPL_TOKEN, this, newTarget);
+    }
 }
diff --git a/src/share/classes/java/dyn/ConstantCallSite.java b/src/share/classes/java/dyn/ConstantCallSite.java
--- a/src/share/classes/java/dyn/ConstantCallSite.java
+++ b/src/share/classes/java/dyn/ConstantCallSite.java
@@ -27,8 +27,8 @@
 
 /**
  * A {@code ConstantCallSite} is a {@link CallSite} whose target is permanent, and can never be changed.
- * The only way to relink an {@code invokedynamic} instruction bound to a {@code ConstantCallSite} is
- * to invalidate the instruction as a whole.
+ * An {@code invokedynamic} instruction linked to a {@code ConstantCallSite} is permanently
+ * bound to the call site's target.
  * @author John Rose, JSR 292 EG
  */
 public class ConstantCallSite extends CallSite {
@@ -36,7 +36,9 @@
     public ConstantCallSite(MethodHandle target) {
         super(target);
     }
-    /** Throw an {@link IllegalArgumentException}, because this kind of call site cannot change its target. */
+    /**
+     * Throw an {@link IllegalArgumentException}, because this kind of call site cannot change its target.
+     */
     @Override public final void setTarget(MethodHandle ignore) {
         throw new IllegalArgumentException("ConstantCallSite");
     }
diff --git a/src/share/classes/java/dyn/InvokeDynamic.java b/src/share/classes/java/dyn/InvokeDynamic.java
deleted file mode 100644
--- a/src/share/classes/java/dyn/InvokeDynamic.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.dyn;
-
-/**
- * {@code InvokeDynamic} is a class with neither methods nor instances,
- * which serves only as a syntactic marker in Java source code for
- * an {@code invokedynamic} instruction.
- * (See <a href="package-summary.html#jvm_mods">the package information</a> for specifics on this instruction.)
- * <p>
- * The {@code invokedynamic} instruction is incomplete without a target method.
- * The target method is a property of the reified {@linkplain CallSite call site object}
- * which is linked to each active {@code invokedynamic} instruction.
- * The call site object is initially produced by a
- * {@linkplain BootstrapMethod bootstrap method}
- * associated with the class whose bytecodes include the dynamic call site.
- * <p>
- * The type {@code InvokeDynamic} has no particular meaning as a
- * class or interface supertype, or an object type; it can never be instantiated.
- * Logically, it denotes a source of all dynamically typed methods.
- * It may be viewed as a pure syntactic marker of static calls.
- * It may be imported for ease of use.
- * <p>
- * Here are some examples:
-<blockquote><pre><!-- see indy-demo/src/JavaDocExamples.java -->
-&#064;BootstrapMethod(value=Here.class, name="bootstrapDynamic")
-static void example() throws Throwable {
-    Object x; String s; int i;
-    x = InvokeDynamic.greet("world"); // greet(Ljava/lang/String;)Ljava/lang/Object;
-    s = (String) InvokeDynamic.hail(x); // hail(Ljava/lang/Object;)Ljava/lang/String;
-    InvokeDynamic.cogito(); // cogito()V
-    i = (int) InvokeDynamic.#"op:+"(2, 3); // "op:+"(II)I
-}
-static MethodHandle bootstrapDynamic(Class caller, String name, MethodType type) { ... }
-</pre></blockquote>
- * Each of the above calls generates a single invokedynamic instruction
- * with the name-and-type descriptors indicated in the comments.
- * <p>
- * The argument types are taken directly from the actual arguments,
- * while the return type corresponds to the target of the assignment.
- * (Currently, the return type must be given as a false type parameter.
- * This type parameter is an irregular use of the generic type syntax,
- * and is likely to change in favor of a convention based on target typing.)
- * <p>
- * The final example uses a special syntax for uttering non-Java names.
- * Any name legal to the JVM may be given between the double quotes.
- * <p>
- * None of these calls is complete without a bootstrap method,
- * which must be declared for the enclosing class or method.
- * @author John Rose, JSR 292 EG
- */
-@MethodHandle.PolymorphicSignature
-public final class InvokeDynamic {
-    private InvokeDynamic() { throw new InternalError(); }  // do not instantiate
-
-    // no statically defined static methods
-}
diff --git a/src/share/classes/java/dyn/Linkage.java b/src/share/classes/java/dyn/Linkage.java
--- a/src/share/classes/java/dyn/Linkage.java
+++ b/src/share/classes/java/dyn/Linkage.java
@@ -29,15 +29,16 @@
 import java.util.WeakHashMap;
 import sun.dyn.Access;
 import sun.dyn.MethodHandleImpl;
+import sun.dyn.util.VerifyAccess;
 import sun.reflect.Reflection;
-import static sun.dyn.util.VerifyAccess.checkBootstrapPrivilege;
 import static sun.dyn.MemberName.newIllegalArgumentException;
 
 /**
- * This class consists exclusively of static methods that control
- * the linkage of {@code invokedynamic} instructions, and specifically
- * their reification as {@link CallSite} objects.
+ * <em>CLASS WILL BE REMOVED FOR PFD:</em>
+ * Static routines for controlling invokedynamic behavior.
+ * Replaced by non-static APIs.
  * @author John Rose, JSR 292 EG
+ * @deprecated This class will be removed in the Public Final Draft.
  */
 public class Linkage {
     private static final Access IMPL_TOKEN = Access.getToken();
@@ -45,68 +46,24 @@
     private Linkage() {}  // do not instantiate
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * <em>METHOD WILL BE REMOVED FOR PFD:</em>
      * Register a <em>bootstrap method</em> to use when linking dynamic call sites within
      * a given caller class.
-     * <p>
-     * A bootstrap method must be a method handle with a return type of {@link CallSite}
-     * and the following arguments:
-     * <ul>
-     * <li>the class containing the {@code invokedynamic} instruction, for which the bootstrap method was registered
-     * <li>the name of the method being invoked (a {@link String})
-     * <li>the type of the method being invoked (a {@link MethodType})
-     * </ul>
-     * The bootstrap method acts as a factory method which accepts the given arguments
-     * and returns a {@code CallSite} object (possibly of a subclass of {@code CallSite}).
-     * <p>
-     * The registration must take place exactly once, either before the class has begun
-     * being initialized, or from within the class's static initializer.
-     * Registration will fail with an exception if any of the following conditions hold:
-     * <ul>
-     * <li>The immediate caller of this method is in a different package than the given caller class,
-     *     and there is a security manager, and its {@code checkPermission} call throws
-     *     when passed {@link LinkagePermission}("registerBootstrapMethod",callerClass).
-     * <li>The given caller class already has a bootstrap method registered.
-     * <li>The given caller class is already fully initialized.
-     * <li>The given caller class is in the process of initialization, in another thread.
-     * </ul>
-     * Because of these rules, a class may install its own bootstrap method in
-     * a static initializer.
-     * @param callerClass a class that may have {@code invokedynamic} sites
-     * @param bootstrapMethod the method to use to bootstrap all such sites
-     * @exception IllegalArgumentException if the class argument is null or
-     *            a primitive class, or if the bootstrap method is the wrong type
-     * @exception IllegalStateException if the class already has a bootstrap
-     *            method, or if the its static initializer has already run
-     *            or is already running in another thread
-     * @exception SecurityException if there is a security manager installed,
-     *            and a {@link LinkagePermission} check fails for "registerBootstrapMethod"
-     * @deprecated Use @{@link BootstrapMethod} annotations instead
+     * @deprecated Use @{@link BootstrapMethod} annotations instead.
      */
     public static
     void registerBootstrapMethod(Class callerClass, MethodHandle bootstrapMethod) {
         Class callc = Reflection.getCallerClass(2);
-        checkBootstrapPrivilege(callc, callerClass, "registerBootstrapMethod");
-        checkBSM(bootstrapMethod);
+        if (callc != null && !VerifyAccess.isSamePackage(callerClass, callc))
+            throw new IllegalArgumentException("cannot set bootstrap method on "+callerClass);
         MethodHandleImpl.registerBootstrap(IMPL_TOKEN, callerClass, bootstrapMethod);
     }
 
-    static private void checkBSM(MethodHandle mh) {
-        if (mh == null)  throw newIllegalArgumentException("null bootstrap method");
-        if (mh.type() == BOOTSTRAP_METHOD_TYPE)  return;
-        throw new WrongMethodTypeException(mh.toString());
-    }
-
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * <em>METHOD WILL BE REMOVED FOR PFD:</em>
      * Simplified version of {@code registerBootstrapMethod} for self-registration,
      * to be called from a static initializer.
-     * Finds a static method of the required type in the
-     * given runtime class, and installs it on the caller class.
-     * @throws NoSuchMethodException if there is no such method
-     * @throws IllegalStateException if the caller class's static initializer
-     *         has already run, or is already running in another thread
-     * @deprecated Use @{@link BootstrapMethod} annotations instead
+     * @deprecated Use @{@link BootstrapMethod} annotations instead.
      */
     public static
     void registerBootstrapMethod(Class<?> runtime, String name) {
@@ -115,15 +72,9 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * <em>METHOD WILL BE REMOVED FOR PFD:</em>
      * Simplified version of {@code registerBootstrapMethod} for self-registration,
-     * to be called from a static initializer.
-     * Finds a static method of the required type in the
-     * caller class itself, and installs it on the caller class.
-     * @throws IllegalArgumentException if there is no such method
-     * @throws IllegalStateException if the caller class's static initializer
-     *         has already run, or is already running in another thread
-     * @deprecated Use @{@link BootstrapMethod} annotations instead
+     * @deprecated Use @{@link BootstrapMethod} annotations instead.
      */
     public static
     void registerBootstrapMethod(String name) {
@@ -140,82 +91,33 @@
         } catch (NoAccessException ex) {
             throw new IllegalArgumentException("no such bootstrap method in "+runtime+": "+name, ex);
         }
-        checkBSM(bootstrapMethod);
         MethodHandleImpl.registerBootstrap(IMPL_TOKEN, callerClass, bootstrapMethod);
     }
 
-    /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
-     * Report the bootstrap method registered for a given caller class.
-     * Returns null if the class has never yet registered a bootstrap method.
-     * Only callers privileged to set the bootstrap method may inquire
-     * about it, because a bootstrap method is potentially a back-door entry
-     * point into its class.
-     * @exception IllegalArgumentException if the argument is null or
-     *            a primitive class
-     * @exception SecurityException if there is a security manager installed,
-     *            and the immediate caller of this method is not in the same
-     *            package as the caller class
-     *            and a {@link LinkagePermission} check fails for "getBootstrapMethod"
-     * @deprecated
-     */
-    public static
-    MethodHandle getBootstrapMethod(Class callerClass) {
-        Class callc = Reflection.getCallerClass(2);
-        checkBootstrapPrivilege(callc, callerClass, "getBootstrapMethod");
-        return MethodHandleImpl.getBootstrap(IMPL_TOKEN, callerClass);
-    }
-
-    /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
-     * The type of any bootstrap method is a three-argument method
-     * {@code (Class, String, MethodType)} returning a {@code CallSite}.
-     */
-    public static final MethodType BOOTSTRAP_METHOD_TYPE
+    private static final MethodType BOOTSTRAP_METHOD_TYPE
             = MethodType.methodType(CallSite.class,
                                     Class.class, String.class, MethodType.class);
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * <em>METHOD WILL BE REMOVED FOR PFD:</em>
      * Invalidate all <code>invokedynamic</code> call sites everywhere.
-     * <p>
-     * When this method returns, every <code>invokedynamic</code> instruction
-     * will invoke its bootstrap method on next call.
-     * <p>
-     * It is unspecified whether call sites already known to the Java
-     * code will continue to be associated with <code>invokedynamic</code>
-     * instructions.  If any call site is still so associated, its
-     * {@link CallSite#getTarget()} method is guaranteed to return null
-     * the invalidation operation completes.
-     * <p>
-     * Invalidation operations are likely to be slow.  Use them sparingly.
+     * @deprecated Use {@linkplain CallSite#setTarget call site target setting}
+     * and {@link VolatileCallSite#invalidateAll call site invalidation} instead.
      */
     public static
     Object invalidateAll() {
-        SecurityManager security = System.getSecurityManager();
-        if (security != null) {
-            security.checkPermission(new LinkagePermission("invalidateAll"));
-        }
-        throw new UnsupportedOperationException("NYI");
+        throw new UnsupportedOperationException();
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * <em>METHOD WILL BE REMOVED FOR PFD:</em>
      * Invalidate all {@code invokedynamic} call sites in the bytecodes
      * of any methods of the given class.
-     * <p>
-     * When this method returns, every matching <code>invokedynamic</code>
-     * instruction will invoke its bootstrap method on next call.
-     * <p>
-     * For additional semantics of call site invalidation,
-     * see {@link #invalidateAll()}.
+     * @deprecated Use {@linkplain CallSite#setTarget call site target setting}
+     * and {@link VolatileCallSite#invalidateAll call site invalidation} instead.
      */
     public static
     Object invalidateCallerClass(Class<?> callerClass) {
-        SecurityManager security = System.getSecurityManager();
-        if (security != null) {
-            security.checkPermission(new LinkagePermission("invalidateAll", callerClass));
-        }
-        throw new UnsupportedOperationException("NYI");
+        throw new UnsupportedOperationException();
     }
 }
diff --git a/src/share/classes/java/dyn/LinkagePermission.java b/src/share/classes/java/dyn/LinkagePermission.java
deleted file mode 100644
--- a/src/share/classes/java/dyn/LinkagePermission.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.dyn;
-
-import java.security.*;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.StringTokenizer;
-
-/**
- * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
- * This class is for managing runtime permission checking for
- * operations performed by methods in the {@link Linkage} class.
- * Like a {@link RuntimePermission}, on which it is modeled,
- * a {@code LinkagePermission} contains a target name but
- * no actions list; you either have the named permission
- * or you don't.
- * <p>
- * The following table lists all the possible {@code LinkagePermission} target names,
- * and for each provides a description of what the permission allows
- * and a discussion of the risks of granting code the permission.
- * <p>
- *
- * <table border=1 cellpadding=5 summary="permission target name,
- *  what the target allows,and associated risks">
- * <tr>
- * <th>Permission Target Name</th>
- * <th>What the Permission Allows</th>
- * <th>Risks of Allowing this Permission</th>
- * </tr>
- *
- * <tr>
- *   <td>invalidateAll</td>
- *   <td>Force the relinking of invokedynamic call sites everywhere.</td>
- *   <td>This could allow an attacker to slow down the system,
- *       or perhaps expose timing bugs in a dynamic language implementations,
- *       by forcing redundant relinking operations.</td>
- * </tr>
- *
- *
- * <tr>
- *   <td>invalidateCallerClass.{class name}</td>
- *   <td>Force the relinking of invokedynamic call sites in the given class.</td>
- *   <td>See {@code invalidateAll}.</td>
- * </tr>
- * </table>
- * <p>ISSUE: Is this still needed?
- *
- * @see java.lang.RuntimePermission
- * @see java.lang.SecurityManager
- *
- * @author John Rose, JSR 292 EG
- */
-
-public final class LinkagePermission extends BasicPermission {
-    private static final long serialVersionUID = 292L;
-
-    /**
-     * Create a new LinkagePermission with the given name.
-     * The name is the symbolic name of the LinkagePermission, such as
-     * "invalidateCallerClass.*", etc. An asterisk
-     * may appear at the end of the name, following a ".", or by itself, to
-     * signify a wildcard match.
-     *
-     * @param name the name of the LinkagePermission
-     */
-    public LinkagePermission(String name) {
-        super(name);
-    }
-
-    /**
-     * Create a new LinkagePermission with the given name on the given class.
-     * Equivalent to {@code LinkagePermission(name+"."+clazz.getName())}.
-     *
-     * @param name the name of the LinkagePermission
-     * @param clazz the class affected by the permission
-     */
-    public LinkagePermission(String name, Class<?> clazz) {
-        super(name + "." + clazz.getName());
-    }
-}
diff --git a/src/share/classes/java/dyn/MethodHandle.java b/src/share/classes/java/dyn/MethodHandle.java
--- a/src/share/classes/java/dyn/MethodHandle.java
+++ b/src/share/classes/java/dyn/MethodHandle.java
@@ -37,20 +37,29 @@
  * A method handle is a typed, directly executable reference to a method,
  * constructor, field, or similar low-level operation, with optional
  * transformations of arguments or return values.
- * (These transformations include conversion, insertion, deletion,
- * substitution.  See the methods of this class and of {@link MethodHandles}.)
+ * These transformations are quite general, and include such patterns as
+ * {@linkplain #asType conversion},
+ * {@linkplain #bindTo insertion},
+ * {@linkplain java.dyn.MethodHandles#dropArguments deletion},
+ * and {@linkplain java.dyn.MethodHandles#filterArguments substitution}.
+ * <p>
+ * <em>Note: The super-class of MethodHandle is Object.
+ *     Any other super-class visible in the Reference Implementation
+ *     will be removed before the Proposed Final Draft.
+ *     Also, the final version will not include any public or
+ *     protected constructors.</em>
  * <p>
  * Method handles are strongly typed according to signature.
  * They are not distinguished by method name or enclosing class.
  * A method handle must be invoked under a signature which matches
- * the method handle's own {@link MethodType method type}.
+ * the method handle's own {@linkplain MethodType method type}.
  * <p>
- * Every method handle confesses its type via the {@code type} accessor.
+ * Every method handle reports its type via the {@link #type type} accessor.
  * The structure of this type is a series of classes, one of which is
  * the return type of the method (or {@code void.class} if none).
  * <p>
  * Every method handle appears as an object containing a method named
- * {@code invoke}, whose signature exactly matches
+ * {@link #invokeExact invokeExact}, whose signature exactly matches
  * the method handle's type.
  * A Java method call expression, which compiles to an
  * {@code invokevirtual} instruction,
@@ -61,15 +70,29 @@
  * (The type is specified in the {@code invokevirtual} instruction,
  * via a {@code CONSTANT_NameAndType} constant pool entry.)
  * The call looks within the receiver object for a method
- * named {@code invoke} of the intended method type.
+ * named {@code invokeExact} of the intended method type.
  * The call fails with a {@link WrongMethodTypeException}
- * if the method does not exist, even if there is an {@code invoke}
+ * if the method does not exist, even if there is an {@code invokeExact}
  * method of a closely similar signature.
  * As with other kinds
  * of methods in the JVM, signature matching during method linkage
  * is exact, and does not allow for language-level implicit conversions
  * such as {@code String} to {@code Object} or {@code short} to {@code int}.
  * <p>
+ * Each individual method handle also contains a method named
+ * {@link #invokeGeneric invokeGeneric}, whose type is the same
+ * as {@code invokeExact}, and is therefore also reported by
+ * the {@link #type type} accessor.
+ * A call to {@code invokeGeneric} works the same as a call to
+ * {@code invokeExact}, if the signature specified by the caller
+ * exactly matches the method handle's own type.
+ * If there is a type mismatch, {@code invokeGeneric} attempts
+ * to adjust the type of the target method handle
+ * (as if by a call to {@link #asType asType})
+ * to obtain an exactly invokable target.
+ * This allows a more powerful negotiation of method type
+ * between caller and callee.
+ * <p>
  * A method handle is an unrestricted capability to call a method.
  * A method handle can be formed on a non-public method by a class
  * that has access to that method; the resulting handle can be used
@@ -77,31 +100,44 @@
  * checking is performed when the method handle is created, not
  * (as in reflection) every time it is called.  Handles to non-public
  * methods, or in non-public classes, should generally be kept secret.
- * They should not be passed to untrusted code.
+ * They should not be passed to untrusted code unless their use from
+ * the untrusted code would be harmless.
  * <p>
- * Bytecode in an extended JVM can directly call a method handle's
- * {@code invoke} from an {@code invokevirtual} instruction.
+ * Bytecode in the JVM can directly call a method handle's
+ * {@code invokeExact} method from an {@code invokevirtual} instruction.
  * The receiver class type must be {@code MethodHandle} and the method name
- * must be {@code invoke}.  The signature of the invocation
+ * must be {@code invokeExact}.  The signature of the invocation
  * (after resolving symbolic type names) must exactly match the method type
  * of the target method.
+ * Similarly, bytecode can directly call a method handle's {@code invokeGeneric}
+ * method.  The signature of the invocation (after resolving symbolic type names)
+ * must either exactly match the method type or be a valid argument to
+ * the target's {@link #asType asType} method.
  * <p>
- * Every {@code invoke} method always throws {@link Exception},
+ * Every {@code invokeExact} and {@code invokeGeneric} method always
+ * throws {@link java.lang.Throwable Throwable},
  * which is to say that there is no static restriction on what a method handle
  * can throw.  Since the JVM does not distinguish between checked
  * and unchecked exceptions (other than by their class, of course),
  * there is no particular effect on bytecode shape from ascribing
  * checked exceptions to method handle invocations.  But in Java source
  * code, methods which perform method handle calls must either explicitly
- * throw {@code Exception}, or else must catch all checked exceptions locally.
+ * throw {@code java.lang.Throwable Throwable}, or else must catch all
+ * throwables locally, rethrowing only those which are legal in the context,
+ * and wrapping ones which are illegal.
  * <p>
- * Bytecode in an extended JVM can directly obtain a method handle
+ * Bytecode in the JVM can directly obtain a method handle
  * for any accessible method from a {@code ldc} instruction
  * which refers to a {@code CONSTANT_Methodref} or
  * {@code CONSTANT_InterfaceMethodref} constant pool entry.
  * <p>
- * All JVMs can also use a reflective API called {@code MethodHandles}
+ * Java code can also use a reflective API called
+ * {@link java.dyn.MethodHandles.Lookup MethodHandles.Lookup}
  * for creating and calling method handles.
+ * For example, a static method handle can be obtained
+ * from {@link java.dyn.MethodHandles.Lookup#findStatic Lookup.findStatic}.
+ * There are also bridge methods from Core Reflection API objects,
+ * such as {@link java.dyn.MethodHandles.Lookup#unreflect Lookup.ureflect}.
  * <p>
  * A method reference may refer either to a static or non-static method.
  * In the non-static case, the method handle type includes an explicit
@@ -131,7 +167,7 @@
 s = mh.&lt;String&gt;invokeExact("daddy",'d','n');
 assert(s.equals("nanny"));
 // weakly typed invocation (using MHs.invoke)
-s = (String) mh.invokeVarargs("sappy", 'p', 'v');
+s = (String) mh.invokeWithArguments("sappy", 'p', 'v');
 assert(s.equals("savvy"));
 // mt is {Object[] =&gt; List}
 mt = MethodType.methodType(java.util.List.class, Object[].class);
@@ -162,7 +198,7 @@
  * Java types.
  * <ol>
  * <li>Method types range over all possible arities,
- * from no arguments to an arbitrary number of arguments.
+ * from no arguments to up to 255 of arguments (a limit imposed by the JVM).
  * Generics are not variadic, and so cannot represent this.</li>
  * <li>Method types can specify arguments of primitive types,
  * which Java generic types cannot range over.</li>
@@ -189,7 +225,6 @@
         // Note: This is an implementation inheritance hack, and will be removed
         // with a JVM change which moves the required hidden state onto this class.
         extends MethodHandleImpl
-        implements MethodHandleProvider
 {
     private static Access IMPL_TOKEN = Access.getToken();
 
@@ -208,7 +243,7 @@
 
     /**
      * Report the type of this method handle.
-     * Every invocation of this method handle must exactly match this type.
+     * Every invocation of this method handle via {@code invokeExact} must exactly match this type.
      * @return the method handle type
      */
     public final MethodType type() {
@@ -216,12 +251,16 @@
     }
 
     /**
-     * The constructor for MethodHandle may only be called by privileged code.
-     * Subclasses may be in other packages, but must possess
-     * a token which they obtained from MH with a security check.
-     * @param token non-null object which proves access permission
-     * @param type type (permanently assigned) of the new method handle
+     * <em>CONSTRUCTOR WILL BE REMOVED FOR PFD:</em>
+     * Temporary constructor in early versions of the Reference Implementation.
+     * Method handle inheritance (if any) will be contained completely within
+     * the {@code java.dyn} package.
      */
+    // The constructor for MethodHandle may only be called by privileged code.
+    // Subclasses may be in other packages, but must possess
+    // a token which they obtained from MH with a security check.
+    // @param token non-null object which proves access permission
+    // @param type type (permanently assigned) of the new method handle
     protected MethodHandle(Access token, MethodType type) {
         super(token);
         Access.check(token);
@@ -243,93 +282,104 @@
         });
     }
 
-    /** The string of a direct method handle is the simple name of its target method.
-     * The string of an adapter or bound method handle is the string of its
-     * target method handle.
-     * The string of a Java method handle is the string of its entry point method,
-     * unless the Java method handle overrides the toString method.
+    /** Produce a printed representation that displays information about this call site
+     *  that may be useful to the human reader.
      */
     @Override
     public String toString() {
         return MethodHandleImpl.getNameString(IMPL_TOKEN, this);
     }
 
-    //// This is the "Method Handle Kernel API" discussed at the JVM Language Summit, 9/2009.
-    //// Implementations here currently delegate to statics in MethodHandles.  Some of those statics
-    //// will be deprecated.  Others will be kept as "algorithms" to supply degrees of freedom
-    //// not present in the Kernel API.
-
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Invoke the method handle, allowing any caller signature, but requiring an exact signature match.
      * The signature at the call site of {@code invokeExact} must
-     * exactly match this method handle's {@code type}.
+     * exactly match this method handle's {@link #type type}.
      * No conversions are allowed on arguments or return values.
+     * @throws WrongMethodTypeException if the target's type is not identical with the caller's type signature
+     * @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call
      */
     public final native @PolymorphicSignature <R,A> R invokeExact(A... args) throws Throwable;
 
-    // FIXME: remove this transitional form
-    /** @deprecated transitional form defined in EDR but removed in PFD */
-    public final native @PolymorphicSignature <R,A> R invoke(A... args) throws Throwable;
-
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Invoke the method handle, allowing any caller signature,
-     * and performing simple conversions for arguments and return types.
-     * The signature at the call site of {@code invokeGeneric} must
-     * have the same arity as this method handle's {@code type}.
+     * and optionally performing conversions for arguments and return types.
      * <p>
-     * If the call site signature exactly matches this method handle's {@code type},
-     * the call proceeds as if by {@link #invokeExact}.
+     * If the call site signature exactly matches this method handle's {@link #type type},
+     * the call proceeds as if by {@link #invokeExact invokeExact}.
      * <p>
      * Otherwise, the call proceeds as if this method handle were first
-     * adjusted by calling {@link #asType} to adjust this method handle
+     * adjusted by calling {@link #asType asType} to adjust this method handle
      * to the required type, and then the call proceeds as if by
-     * {@link #invokeExact} on the adjusted method handle.
+     * {@link #invokeExact invokeExact} on the adjusted method handle.
+     * <p>
+     * There is no guarantee that the {@code asType} call is actually made.
+     * If the JVM can predict the results of making the call, it may perform
+     * adaptations directly on the caller's arguments,
+     * and call the target method handle according to its own exact type.
+     * <p>
+     * If the method handle is equipped with a
+     * {@linkplain #withTypeHandler type handler}, the handler must produce
+     * an entry point of the call site's exact type.
+     * Otherwise, the signature at the call site of {@code invokeGeneric} must
+     * be a valid argument to the standard {@code asType} method.
+     * In particular, the caller must specify the same argument arity
+     * as the callee's type.
+     * @throws WrongMethodTypeException if the target's type cannot be adjusted to the caller's type signature
+     * @throws Throwable anything thrown by the underlying method propagates unchanged through the method handle call
      */
     public final native @PolymorphicSignature <R,A> R invokeGeneric(A... args) throws Throwable;
 
-    // ?? public final native @PolymorphicSignature <R,A,V> R invokeVarargs(A args, V[] varargs) throws Throwable;
-
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Perform a varargs invocation, passing the arguments in the given array
-     * to the method handle, as if via {@link #invokeGeneric} from a call site
+     * to the method handle, as if via {@link #invokeGeneric invokeGeneric} from a call site
      * which mentions only the type {@code Object}, and whose arity is the length
      * of the argument array.
      * <p>
-     * The length of the arguments array must equal the parameter count
-     * of the target's type.
-     * The arguments array is spread into separate arguments.
+     * Specifically, execution proceeds as if by the following steps,
+     * although the methods are not guaranteed to be called if the JVM
+     * can predict their effects.
+     * <ul>
+     * <li>Determine the length of the argument array as {@code N}.
+     *     For a null reference, {@code N=0}. </li>
+     * <li>Determine the generic type {@code TN} of {@code N} arguments as
+     *     as {@code TN=MethodType.genericMethodType(N)}.</li>
+     * <li>Force the original target method handle {@code MH0} to the
+     *     required type, as {@code MH1 = MH0.asType(TN)}. </li>
+     * <li>Spread the array into {@code N} separate arguments {@code A0, ...}. </li>
+     * <li>Invoke the type-adjusted method handle on the unpacked arguments:
+     *     MH1.invokeExact(A0, ...). </li>
+     * <li>Take the return value as an {@code Object} reference. </li>
+     * </ul>
      * <p>
-     * In order to match the type of the target, the following argument
+     * Because of the action of the {@code asType} step, the following argument
      * conversions are applied as necessary:
      * <ul>
      * <li>reference casting
      * <li>unboxing
+     * <li>widening primitive conversions
      * </ul>
-     * The following conversions are not applied:
-     * <ul>
-     * <li>primitive conversions (e.g., {@code byte} to {@code int}
-     * <li>varargs conversions other than the initial spread
-     * <li>any application-specific conversions (e.g., string to number)
-     * </ul>
+     * <p>
      * The result returned by the call is boxed if it is a primitive,
      * or forced to null if the return type is void.
      * <p>
      * This call is equivalent to the following code:
      * <p><blockquote><pre>
-     *   MethodHandle invoker = MethodHandles.genericInvoker(this.type(), 0, true);
-     *   Object result = invoker.invokeExact(this, arguments);
+     * MethodHandle invoker = MethodHandles.varargsInvoker(this.type(), 0);
+     * Object result = invoker.invokeExact(this, arguments);
      * </pre></blockquote>
      * @param arguments the arguments to pass to the target
      * @return the result returned by the target
-     * @see MethodHandles#genericInvoker
+     * @throws WrongMethodTypeException if the target's type cannot be adjusted to take the arguments
+     * @throws Throwable anything thrown by the target method invocation
+     * @see MethodHandles#varargsInvoker
      */
-    public final Object invokeVarargs(Object... arguments) throws Throwable {
+    public final Object invokeWithArguments(Object... arguments) throws Throwable {
         int argc = arguments == null ? 0 : arguments.length;
         MethodType type = type();
-        if (type.parameterCount() != argc)  throw badParameterCount(type, argc);
+        if (type.parameterCount() != argc) {
+            // simulate invokeGeneric
+            return asType(MethodType.genericMethodType(argc)).invokeWithArguments(arguments);
+        }
         if (argc <= 10) {
             MethodHandle invoker = MethodHandles.invokers(type).genericInvoker();
             switch (argc) {
@@ -373,82 +423,48 @@
         MethodHandle invoker = MethodHandles.invokers(type).varargsInvoker(0);
         return invoker.invokeExact(this, arguments);
     }
-    /** Equivalent to {@code invokeVarargs(arguments.toArray())}. */
+    /** Equivalent to {@code invokeWithArguments(arguments.toArray())}. */
+    public final Object invokeWithArguments(java.util.List<?> arguments) throws Throwable {
+        return invokeWithArguments(arguments.toArray());
+    }
+    @Deprecated
+    public final Object invokeVarargs(Object... arguments) throws Throwable {
+        return invokeWithArguments(arguments);
+    }
+    @Deprecated
     public final Object invokeVarargs(java.util.List<?> arguments) throws Throwable {
-        return invokeVarargs(arguments.toArray());
+        return invokeWithArguments(arguments.toArray());
     }
 
-    private static WrongMethodTypeException badParameterCount(MethodType type, int argc) {
-        return new WrongMethodTypeException(type+" does not take "+argc+" parameters");
-    }
-
-    /*  --- this is intentionally NOT a javadoc yet ---
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+    /**
      * Produce an adapter method handle which adapts the type of the
-     * current method handle to a new type by pairwise argument conversion.
-     * The original type and new type must have the same number of arguments.
-     * The resulting method handle is guaranteed to confess a type
+     * current method handle to a new type
+     * The resulting method handle is guaranteed to report a type
      * which is equal to the desired new type.
      * <p>
      * If the original type and new type are equal, returns {@code this}.
      * <p>
-     * The following conversions are applied as needed both to
-     * arguments and return types.  Let T0 and T1 be the differing
-     * new and old parameter types (or old and new return types)
-     * for corresponding values passed by the new and old method types.
-     * Given those types T0, T1, one of the following conversions is applied
-     * if possible:
-     * <ul>
-     * <li>If T0 and T1 are references, and T1 is not an interface type,
-     *     then a cast to T1 is applied.
-     *     (The types do not need to be related in any particular way.)
-     * <li>If T0 and T1 are references, and T1 is an interface type,
-     *     then the value of type T0 is passed as a T1 without a cast.
-     *     (This treatment of interfaces follows the usage of the bytecode verifier.)
-     * <li>If T0 and T1 are primitives, then a Java casting
-     *     conversion (JLS 5.5) is applied, if one exists.
-     * <li>If T0 and T1 are primitives and one is boolean,
-     *     the boolean is treated as a one-bit unsigned integer.
-     *     (This treatment follows the usage of the bytecode verifier.)
-     *     A conversion from another primitive type behaves as if
-     *     it first converts to byte, and then masks all but the low bit.
-     * <li>If T0 is a primitive and T1 a reference, a boxing
-     *     conversion is applied if one exists, possibly followed by
-     *     an reference conversion to a superclass.
-     *     T1 must be a wrapper class or a supertype of one.
-     *     If T1 is a wrapper class, T0 is converted if necessary
-     *     to T1's primitive type by one of the preceding conversions.
-     *     Otherwise, T0 is boxed, and its wrapper converted to T1.
-     * <li>If T0 is a reference and T1 a primitive, an unboxing
-     *     conversion is applied if one exists, possibly preceded by
-     *     a reference conversion to a wrapper class.
-     *     T0 must be a wrapper class or a supertype of one.
-     *     If T0 is a wrapper class, its primitive value is converted
-     *     if necessary to T1 by one of the preceding conversions.
-     *     Otherwise, T0 is converted directly to the wrapper type for T1,
-     *     which is then unboxed.
-     * <li>If the return type T1 is void, any returned value is discarded
-     * <li>If the return type T0 is void and T1 a reference, a null value is introduced.
-     * <li>If the return type T0 is void and T1 a primitive, a zero value is introduced.
-     * </ul>
+     * This method provides the crucial behavioral difference between
+     * {@link #invokeExact invokeExact} and {@link #invokeGeneric invokeGeneric}.  The two methods
+     * perform the same steps when the caller's type descriptor is identical
+     * with the callee's, but when the types differ, {@link #invokeGeneric invokeGeneric}
+     * also calls {@code asType} (or some internal equivalent) in order
+     * to match up the caller's and callee's types.
      * <p>
-     */
-    /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
-     * Produce an adapter method handle which adapts the type of the
-     * current method handle to a new type by pairwise argument conversion.
-     * The original type and new type must have the same number of arguments.
-     * The resulting method handle is guaranteed to confess a type
-     * which is equal to the desired new type.
+     * This method is equivalent to {@link MethodHandles#convertArguments convertArguments},
+     * except for method handles produced by {@link #withTypeHandler withTypeHandler},
+     * in which case the specified type handler is used for calls to {@code asType}.
      * <p>
-     * If the original type and new type are equal, returns {@code this}.
-     * <p>
-     * This method is equivalent to {@link MethodHandles#convertArguments}.
+     * Note that the default behavior of {@code asType} only performs
+     * pairwise argument conversion and return value conversion.
+     * Because of this, unless the method handle has a type handler,
+     * the original type and new type must have the same number of arguments.
+     *
      * @param newType the expected type of the new method handle
      * @return a method handle which delegates to {@code this} after performing
      *           any necessary argument conversions, and arranges for any
      *           necessary return value conversions
-     * @throws IllegalArgumentException if the conversion cannot be made
+     * @throws WrongMethodTypeException if the conversion cannot be made
      * @see MethodHandles#convertArguments
      */
     public MethodHandle asType(MethodType newType) {
@@ -456,20 +472,21 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle which adapts, as its <i>target</i>,
      * the current method handle.  The type of the adapter will be
-     * the same as the type of the target, except that all but the first
-     * {@code keepPosArgs} parameters of the target's type are replaced
-     * by a single array parameter of type {@code Object[]}.
-     * Thus, if {@code keepPosArgs} is zero, the adapter will take all
-     * arguments in a single object array.
+     * the same as the type of the target, except that the final
+     * {@code arrayLength} parameters of the target's type are replaced
+     * by a single array parameter of type {@code arrayType}.
+     * <p>
+     * If the array element type differs from any of the corresponding
+     * argument types on original target,
+     * the original target is adapted to take the array elements directly,
+     * as if by a call to {@link #asType asType}.
      * <p>
      * When called, the adapter replaces a trailing array argument
      * by the array's elements, each as its own argument to the target.
      * (The order of the arguments is preserved.)
      * They are converted pairwise by casting and/or unboxing
-     * (as if by {@link MethodHandles#convertArguments})
      * to the types of the trailing parameters of the target.
      * Finally the target is called.
      * What the target eventually returns is returned unchanged by the adapter.
@@ -478,54 +495,67 @@
      * contains exactly enough elements to provide a correct argument count
      * to the target method handle.
      * (The array may also be null when zero elements are required.)
-     * @param keepPosArgs the number of leading positional arguments to preserve
-     * @return a new method handle which spreads its final argument,
+     * @param arrayType usually {@code Object[]}, the type of the array argument from which to extract the spread arguments
+     * @param arrayLength the number of arguments to spread from an incoming array argument
+     * @return a new method handle which spreads its final array argument,
      *         before calling the original method handle
+     * @throws IllegalArgumentException if {@code arrayType} is not an array type
      * @throws IllegalArgumentException if target does not have at least
-     *         {@code keepPosArgs} parameter types
+     *         {@code arrayLength} parameter types
+     * @throws WrongMethodTypeException if the implied {@code asType} call fails
      */
-    public final MethodHandle asSpreader(int keepPosArgs) {
+    public final MethodHandle asSpreader(Class<?> arrayType, int arrayLength) {
+        Class<?> arrayElement = arrayType.getComponentType();
+        if (arrayElement == null)  throw newIllegalArgumentException("not an array type");
         MethodType oldType = type();
         int nargs = oldType.parameterCount();
+        if (nargs < arrayLength)  throw newIllegalArgumentException("bad spread array length");
+        int keepPosArgs = nargs - arrayLength;
         MethodType newType = oldType.dropParameterTypes(keepPosArgs, nargs);
-        newType = newType.insertParameterTypes(keepPosArgs, Object[].class);
+        newType = newType.insertParameterTypes(keepPosArgs, arrayElement);
         return MethodHandles.spreadArguments(this, newType);
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle which adapts, as its <i>target</i>,
      * the current method handle.  The type of the adapter will be
      * the same as the type of the target, except that a single trailing
-     * array parameter of type {@code Object[]} is replaced by
-     * {@code spreadArrayArgs} parameters of type {@code Object}.
+     * parameter (usually of type {@code arrayType}) is replaced by
+     * {@code arrayLength} parameters whose type is element type of {@code arrayType}.
      * <p>
-     * When called, the adapter replaces its trailing {@code spreadArrayArgs}
-     * arguments by a single new {@code Object} array, whose elements
+     * If the array type differs from the final argument type on original target,
+     * the original target is adapted to take the array type directly,
+     * as if by a call to {@link #asType asType}.
+     * <p>
+     * When called, the adapter replaces its trailing {@code arrayLength}
+     * arguments by a single new array of type {@code arrayType}, whose elements
      * comprise (in order) the replaced arguments.
      * Finally the target is called.
      * What the target eventually returns is returned unchanged by the adapter.
      * <p>
-     * (The array may also be a shared constant when {@code spreadArrayArgs} is zero.)
-     * @param spreadArrayArgs the number of arguments to spread from the trailing array
+     * (The array may also be a shared constant when {@code arrayLength} is zero.)
+     * @param arrayType usually {@code Object[]}, the type of the array argument which will collect the arguments
+     * @param arrayLength the number of arguments to collect into a new array argument
      * @return a new method handle which collects some trailing argument
      *         into an array, before calling the original method handle
-     * @throws IllegalArgumentException if the last argument of the target
-     *         is not {@code Object[]}
-     * @throws IllegalArgumentException if {@code spreadArrayArgs} is not
+     * @throws IllegalArgumentException if {@code arrayType} is not an array type
+               or {@code arrayType} is not assignable to this method handle's trailing parameter type
+     * @throws IllegalArgumentException if {@code arrayLength} is not
      *         a legal array size
-     * @deprecated Provisional and unstable; use {@link MethodHandles#collectArguments}.
+     * @throws WrongMethodTypeException if the implied {@code asType} call fails
      */
-    public final MethodHandle asCollector(int spreadArrayArgs) {
+    public final MethodHandle asCollector(Class<?> arrayType, int arrayLength) {
+        Class<?> arrayElement = arrayType.getComponentType();
+        if (arrayElement == null)  throw newIllegalArgumentException("not an array type");
         MethodType oldType = type();
         int nargs = oldType.parameterCount();
         MethodType newType = oldType.dropParameterTypes(nargs-1, nargs);
-        newType = newType.insertParameterTypes(nargs-1, MethodType.genericMethodType(spreadArrayArgs).parameterArray());
+        newType = newType.insertParameterTypes(nargs-1,
+                    java.util.Collections.<Class<?>>nCopies(arrayLength, arrayElement));
         return MethodHandles.collectArguments(this, newType);
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle which binds the given argument
      * to the current method handle as <i>target</i>.
      * The type of the bound handle will be
@@ -546,15 +576,73 @@
      *         leading parameter type that is a reference type
      * @throws ClassCastException if {@code x} cannot be converted
      *         to the leading parameter type of the target
-     * @deprecated Provisional and unstable; use {@link MethodHandles#insertArguments}.
+     * @see MethodHandles#insertArguments
      */
     public final MethodHandle bindTo(Object x) {
         return MethodHandles.insertArguments(this, 0, x);
     }
 
-    /** Implementation of {@link MethodHandleProvider}, which returns {@code this}. */
-    public final MethodHandle asMethodHandle() { return this; }
+    /**
+     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * Create a new method handle with the same type as this one,
+     * but whose {@code asType} method invokes the given
+     * {@code typeHandler} on this method handle,
+     * instead of the standard {@code MethodHandles.convertArguments}.
+     * <p>
+     * The new method handle will have the same behavior as the
+     * old one when invoked by {@code invokeExact}.
+     * For {@code invokeGeneric} calls which exactly match
+     * the method type, the two method handles will also
+     * have the same behavior.
+     * For other {@code invokeGeneric} calls, the {@code typeHandler}
+     * will control the behavior of the new method handle.
+     * <p>
+     * Thus, a method handle with an {@code asType} handler can
+     * be configured to accept more than one arity of {@code invokeGeneric}
+     * call, and potentially every possible arity.
+     * It can also be configured to supply default values for
+     * optional arguments, when the caller does not specify them.
+     * <p>
+     * The given method handle must take two arguments and return
+     * one result.  The result it returns must be a method handle
+     * of exactly the requested type.  If the result returned by
+     * the target is null, a {@link NullPointerException} is thrown,
+     * else if the type of the target does not exactly match
+     * the requested type, a {@link WrongMethodTypeException} is thrown.
+     * <p>
+     * Therefore, the type handler is invoked as if by this code:
+     * <blockquote><pre>
+     * MethodHandle target = this;      // original method handle
+     * MethodHandle adapter = ...;      // adapted method handle
+     * MethodType requestedType = ...;  // argument to asType()
+     * if (type().equals(requestedType))
+     *    return adapter;
+     * MethodHandle result = (MethodHandle)
+     *    typeHandler.invokeGeneric(target, requestedType);
+     * if (!result.type().equals(requestedType))
+     *    throw new WrongMethodTypeException();
+     * return result;
+     * </pre></blockquote>
+     * <p>
+     * For example, here is a list-making variable-arity method handle:
+     * <blockquote><pre>
+MethodHandle makeEmptyList = MethodHandles.constant(List.class, Arrays.asList());
+MethodHandle asList = lookup()
+  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class));
+static MethodHandle collectingTypeHandler(MethodHandle base, MethodType newType) {
+  return asList.asCollector(Object[].class, newType.parameterCount()).asType(newType);
+}
+MethodHandle collectingTypeHandler = lookup()
+  .findStatic(lookup().lookupClass(), "collectingTypeHandler",
+     methodType(MethodHandle.class, MethodHandle.class, MethodType.class));
+MethodHandle makeAnyList = makeEmptyList.withTypeHandler(collectingTypeHandler);
 
-    /** Implementation of {@link MethodHandleProvider}, which returns {@code this.asType(type)}. */
-    public final MethodHandle asMethodHandle(MethodType type) { return this.asType(type); }
+System.out.println(makeAnyList.invokeGeneric()); // prints []
+System.out.println(makeAnyList.invokeGeneric(1)); // prints [1]
+System.out.println(makeAnyList.invokeGeneric("two", "too")); // prints [two, too]
+     * <pre><blockquote>
+     */
+    public MethodHandle withTypeHandler(MethodHandle typeHandler) {
+        return MethodHandles.withTypeHandler(this, typeHandler);
+    }
 }
diff --git a/src/share/classes/java/dyn/MethodHandleProvider.java b/src/share/classes/java/dyn/MethodHandleProvider.java
deleted file mode 100644
--- a/src/share/classes/java/dyn/MethodHandleProvider.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package java.dyn;
-
-/**
- * An interface for an object to provide a target {@linkplain MethodHandle method handle} to a {@code invokedynamic} instruction.
- * There are many function-like objects in various Java APIs.
- * This interface provides a standard way for such function-like objects to be bound
- * to a dynamic call site, by providing a view of their behavior in the form of a low-level method handle.
- * <p>
- * The type {@link MethodHandle} is a concrete class whose implementation
- * hierarchy (if any) may be tightly coupled to the underlying JVM implementation.
- * It cannot also serve as a base type for user-defined functional APIs.
- * For this reason, {@code MethodHandle} cannot be subclassed to add new
- * behavior to method handles.  But this interface can be used to provide
- * a link between a user-defined function and the {@code invokedynamic}
- * instruction and the method handle API.
- */
-public interface MethodHandleProvider {
-    /** Produce a method handle which will serve as a behavioral proxy for the current object.
-     *  The type and invocation behavior of the proxy method handle are user-defined,
-     *  and should have some relation to the intended meaning of the original object itself.
-     *  <p>
-     *  The current object may have a changeable behavior.
-     *  For example, {@link CallSite} has a {@code setTarget} method which changes its invocation.
-     *  In such a case, it is <em>incorrect</em> for {@code asMethodHandle} to return
-     *  a method handle whose behavior may diverge from that of the current object.
-     *  Rather, the returned method handle must stably and permanently access
-     *  the behavior of the current object, even if that behavior is changeable.
-     *  <p>
-     *  The reference identity of the proxy method handle is not guaranteed to
-     *  have any particular relation to the reference identity of the object.
-     *  In particular, several objects with the same intended meaning could
-     *  share a common method handle, or the same object could return different
-     *  method handles at different times.  In the latter case, the different
-     *  method handles should have the same type and invocation behavior,
-     *  and be usable from any thread at any time.
-     *  In particular, if a MethodHandleProvider is bound to an <code>invokedynamic</code>
-     *  call site, the proxy method handle extracted at the time of binding
-     *  will be used for an unlimited time, until the call site is rebound.
-     *  <p>
-     *  The type {@link MethodHandle} itself implements {@code MethodHandleProvider}, and
-     *  for this method simply returns {@code this}.
-     */
-    public MethodHandle asMethodHandle();
-
-    /** Produce a method handle of a given type which will serve as a behavioral proxy for the current object.
-     *  As for the no-argument version {@link #asMethodHandle()}, the invocation behavior of the
-     *  proxy method handle is user-defined.  But the type must be the given type,
-     *  or else a {@link WrongMethodTypeException} must be thrown.
-     *  <p>
-     *  If the current object somehow represents a variadic or overloaded behavior,
-     *  the method handle returned for a given type might represent only a subset of
-     *  the current object's repertoire of behaviors, which correspond to that type.
-     */
-    public MethodHandle asMethodHandle(MethodType type) throws WrongMethodTypeException;
-}
diff --git a/src/share/classes/java/dyn/MethodHandles.java b/src/share/classes/java/dyn/MethodHandles.java
--- a/src/share/classes/java/dyn/MethodHandles.java
+++ b/src/share/classes/java/dyn/MethodHandles.java
@@ -29,6 +29,7 @@
 import sun.dyn.Access;
 import sun.dyn.MemberName;
 import sun.dyn.MethodHandleImpl;
+import sun.dyn.util.ValueConversions;
 import sun.dyn.util.VerifyAccess;
 import sun.dyn.util.Wrapper;
 import java.util.List;
@@ -135,12 +136,19 @@
      * In general, the conditions under which a method handle may be
      * created for a method {@code M} are exactly as restrictive as the conditions
      * under which the lookup class could have compiled a call to {@code M}.
-     * This rule is applied even if the Java compiler might have created
+     * <p>
+     * In some cases, this access is obtained by the Java compiler by creating
      * an wrapper method to access a private method of another class
      * in the same top-level declaration.
-     * For example, a lookup object created for a nested class {@code C.D}
+     * For example, a nested class {@code C.D}
      * can access private members within other related classes such as
-     * {@code C}, {@code C.D.E}, or {@code C.B}.
+     * {@code C}, {@code C.D.E}, or {@code C.B},
+     * but the Java compiler may need to generate wrapper methods in
+     * those related classes.  In such cases, a {@code Lookup} object on
+     * {@code C.E} would be unable to those private members.
+     * A workaround for this limitation is the {@link Lookup#in Lookup.in} method,
+     * which can transform a lookup on {@code C.E} into one on any of those other
+     * classes, without special elevation of privilege.
      */
     public static final
     class Lookup {
@@ -181,13 +189,23 @@
         }
 
         /** Which types of members can this lookup object produce?
-         *  The result is a bit-mask of the {@link Modifier} bits
-         *  {@linkplain Modifier#PUBLIC PUBLIC (0x01)},
-         *  {@linkplain Modifier#PROTECTED PROTECTED (0x02)},
-         *  {@linkplain Modifier#PRIVATE PRIVATE (0x04)},
-         *  and {@linkplain Modifier#STATIC STATIC (0x08)}.
+         *  The result is a bit-mask of the {@link java.lang.reflect.Modifier Modifier} bits
+         *  {@linkplain java.lang.reflect.Modifier#PUBLIC PUBLIC (0x01)},
+         *  {@linkplain java.lang.reflect.Modifier#PROTECTED PROTECTED (0x02)},
+         *  {@linkplain java.lang.reflect.Modifier#PRIVATE PRIVATE (0x04)},
+         *  and {@linkplain java.lang.reflect.Modifier#STATIC STATIC (0x08)}.
          *  The modifier bit {@code STATIC} stands in for the package protection mode,
          *  which does not have an explicit modifier bit.
+         *  <p>
+         *  A freshly-created lookup object
+         *  on the {@linkplain java.dyn.MethodHandles#lookup() caller's class}
+         *  has all possible bits set, since the caller class can access all its own members.
+         *  A lookup object on a new lookup class
+         *  {@linkplain java.dyn.MethodHandles.Lookup#in created from a previous lookup object}
+         *  may have some mode bits set to zero.
+         *  The purpose of this is to restrict access via the new lookup object,
+         *  so that it can access only names which can be reached by the original
+         *  lookup object, and also by the new lookup class.
          */
         public int lookupModes() {
             return allowedModes & ALL_MODES;
@@ -224,14 +242,17 @@
          * <p>
          * However, the resulting {@code Lookup} object is guaranteed
          * to have no more access capabilities than the original.
-         * In particular:<ul>
+         * In particular, access capabilities can be lost as follows:<ul>
          * <li>If the new lookup class differs from the old one,
          * protected members will not be accessible by virtue of inheritance.
+         * (Protected members may continue to be accessible because of package sharing.)
          * <li>If the new lookup class is in a different package
          * than the old one, protected and default (package) members will not be accessible.
          * <li>If the new lookup class is not within the same package member
          * as the old one, private members will not be accessible.
-         * <li>In all cases, public members will continue to be accessible.
+         * <li>If the new lookup class is not accessible to the old lookup class,
+         * then no members, not even public members, will be accessible.
+         * (In all other cases, public members will continue to be accessible.)
          * </ul>
          */
         public Lookup in(Class<?> requestedLookupClass) {
@@ -245,10 +266,17 @@
                 && !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
                 newModes &= ~(PACKAGE|PRIVATE);
             }
+            // Allow nestmate lookups to be created without special privilege:
             if ((newModes & PRIVATE) != 0
                 && !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {
                 newModes &= ~PRIVATE;
             }
+            if (newModes == PUBLIC
+                && !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass)) {
+                // The requested class it not accessible from the lookup class.
+                // No permissions.
+                newModes = 0;
+            }
             checkUnprivilegedlookupClass(requestedLookupClass);
             return new Lookup(requestedLookupClass, newModes);
         }
@@ -290,8 +318,8 @@
                 break;
             case PUBLIC|PACKAGE:
                 return cname + "/package";
-            case 0:  // should not happen
-                return cname + "/empty";
+            case 0:  // no privileges
+                return cname + "/noaccess";
             case ALL_MODES:
                 return cname;
             }
@@ -326,7 +354,6 @@
          * @param name the name of the method
          * @param type the type of the method
          * @return the desired method handle
-         * @exception SecurityException <em>TBD</em>
          * @exception NoAccessException if the method does not exist or access checking fails
          */
         public
@@ -358,7 +385,6 @@
          * @param name the name of the method
          * @param type the type of the method, with the receiver argument omitted
          * @return the desired method handle
-         * @exception SecurityException <em>TBD</em>
          * @exception NoAccessException if the method does not exist or access checking fails
          */
         public MethodHandle findVirtual(Class<?> refc, String name, MethodType type) throws NoAccessException {
@@ -382,7 +408,6 @@
          * @param refc the class or interface from which the method is accessed
          * @param type the type of the method, with the receiver argument omitted, and a void return type
          * @return the desired method handle
-         * @exception SecurityException <em>TBD</em>
          * @exception NoAccessException if the method does not exist or access checking fails
          */
         public MethodHandle findConstructor(Class<?> refc, MethodType type) throws NoAccessException {
@@ -409,13 +434,13 @@
          * {@code invokespecial} instruction.)
          * <p>
          * If the explicitly specified caller class is not identical with the
-         * lookup class, a security check TBD is performed.
+         * lookup class, or if this lookup object does not have private access
+         * privileges, the access fails.
          * @param refc the class or interface from which the method is accessed
          * @param name the name of the method (which must not be "&lt;init&gt;")
          * @param type the type of the method, with the receiver argument omitted
          * @param specialCaller the proposed calling class to perform the {@code invokespecial}
          * @return the desired method handle
-         * @exception SecurityException <em>TBD</em>
          * @exception NoAccessException if the method does not exist or access checking fails
          */
         public MethodHandle findSpecial(Class<?> refc, String name, MethodType type,
@@ -428,7 +453,6 @@
         }
 
         /**
-         * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
          * Produce a method handle giving read access to a non-static field.
          * The type of the method handle will have a return type of the field's
          * value type.
@@ -445,7 +469,6 @@
         }
 
         /**
-         * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
          * Produce a method handle giving write access to a non-static field.
          * The type of the method handle will have a void return type.
          * The method handle will take two arguments, the instance containing
@@ -462,7 +485,6 @@
         }
 
         /**
-         * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
          * Produce a method handle giving read access to a static field.
          * The type of the method handle will have a return type of the field's
          * value type.
@@ -478,7 +500,6 @@
         }
 
         /**
-         * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
          * Produce a method handle giving write access to a static field.
          * The type of the method handle will have a void return type.
          * The method handle will take a single
@@ -515,7 +536,6 @@
          * @param name the name of the method
          * @param type the type of the method, with the receiver argument omitted
          * @return the desired method handle
-         * @exception SecurityException <em>TBD</em>
          * @exception NoAccessException if the method does not exist or access checking fails
          */
         public MethodHandle bind(Object receiver, String name, MethodType type) throws NoAccessException {
@@ -530,7 +550,6 @@
         }
 
         /**
-         * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
          * Make a direct method handle to <i>m</i>, if the lookup class has permission.
          * If <i>m</i> is non-static, the receiver argument is treated as an initial argument.
          * If <i>m</i> is virtual, overriding is respected on every call.
@@ -554,7 +573,6 @@
         }
 
         /**
-         * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
          * Produce a method handle for a reflected method.
          * It will bypass checks for overriding methods on the receiver,
          * as if by a {@code invokespecial} instruction from within the {@code specialCaller}.
@@ -579,7 +597,6 @@
         }
 
         /**
-         * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
          * Produce a method handle for a reflected constructor.
          * The type of the method handle will be that of the constructor,
          * with the return type changed to the declaring class.
@@ -602,7 +619,6 @@
         }
 
         /**
-         * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
          * Produce a method handle giving read access to a reflected field.
          * The type of the method handle will have a return type of the field's
          * value type.
@@ -620,7 +636,6 @@
         }
 
         /**
-         * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
          * Produce a method handle giving write access to a reflected field.
          * The type of the method handle will have a void return type.
          * If the field is static, the method handle will take a single
@@ -681,7 +696,7 @@
             int allowedModes = this.allowedModes;
             if (allowedModes == TRUSTED)  return;
             int mods = m.getModifiers();
-            if (Modifier.isPublic(mods) && Modifier.isPublic(refc.getModifiers()))
+            if (Modifier.isPublic(mods) && Modifier.isPublic(refc.getModifiers()) && allowedModes != 0)
                 return;  // common case
             int requestedModes = fixmods(mods);  // adjust 0 => PACKAGE
             if ((requestedModes & allowedModes) != 0
@@ -706,6 +721,8 @@
                 return "access to public member failed";  // (how?)
             else if (allowedModes == PUBLIC)
                 return "member is not public";
+            else if (allowedModes == 0)
+                return "attempted member access through a non-public class";
             if (Modifier.isPrivate(mods))
                 return "member is private";
             if (Modifier.isProtected(mods))
@@ -713,9 +730,14 @@
             return "member is private to package";
         }
 
+        private static final boolean ALLOW_NESTMATE_ACCESS = false;
+
         void checkSpecialCaller(Class<?> specialCaller) throws NoAccessException {
             if (allowedModes == TRUSTED)  return;
-            if (!VerifyAccess.isSamePackageMember(specialCaller, lookupClass()))
+            if ((allowedModes & PRIVATE) == 0
+                || (specialCaller != lookupClass()
+                    && !(ALLOW_NESTMATE_ACCESS &&
+                         VerifyAccess.isSamePackageMember(specialCaller, lookupClass()))))
                 throw newNoAccessException("no private access for invokespecial",
                                            new MemberName(specialCaller), lookupClass());
         }
@@ -725,7 +747,9 @@
             // on itself or a subclass.  Enforce that restriction, from JVMS 5.4.4, etc.
             if (!method.isProtected() || method.isStatic()
                 || allowedModes == TRUSTED
-                || VerifyAccess.isSamePackageMember(method.getDeclaringClass(), lookupClass()))
+                || method.getDeclaringClass() == lookupClass()
+                || (ALLOW_NESTMATE_ACCESS &&
+                    VerifyAccess.isSamePackageMember(method.getDeclaringClass(), lookupClass())))
                 return mh;
             else
                 return restrictReceiver(method, mh, lookupClass());
@@ -765,7 +789,6 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle giving read access to elements of an array.
      * The type of the method handle will have a return type of the array's
      * element type.  Its first argument will be the array type,
@@ -780,7 +803,6 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle giving write access to elements of an array.
      * The type of the method handle will have a void return type.
      * Its last argument will be the array's element type.
@@ -796,25 +818,6 @@
     /// method handle invocation (reflective style)
 
     /**
-     * @deprecated Alias for MethodHandle.invokeVarargs.
-     */
-    @Deprecated
-    public static
-    Object invokeVarargs(MethodHandle target, Object... arguments) throws Throwable {
-        return target.invokeVarargs(arguments);
-    }
-
-    /**
-     * @deprecated Alias for MethodHandle.invokeVarargs.
-     */
-    @Deprecated
-    public static
-    Object invoke(MethodHandle target, Object... arguments) throws Throwable {
-        return target.invokeVarargs(arguments);
-    }
-
-    /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle which will invoke any method handle of the
      * given type on a standard set of {@code Object} type arguments.
      * The resulting invoker will be a method handle with the following
@@ -823,18 +826,28 @@
      * <li>a single {@code MethodHandle} target
      * <li>zero or more {@code Object} values (one for each argument in {@code type})
      * </ul>
-     * The invoker will apply reference casts as necessary and unbox primitive arguments,
-     * as if by {@link #convertArguments}.
+     * <p>
+     * The invoker will behave like a call to {@link MethodHandle.invokeGeneric} with
+     * the indicated {@code type}.
+     * That is, if the target is exactly of the given {@code type}, it will behave
+     * like {@code invokeExact}; otherwise it behave as if {@link MethodHandle.asType}
+     * is used to convert the target to the required {@code type}.
+     * <p>
+     * The type of the returned invoker will not be the given {@code type}, but rather
+     * will have all parameter and return types replaced by {@code Object}.
+     * <p>
+     * Before invoking its target, the invoker will apply reference casts as
+     * necessary and unbox and widen primitive arguments, as if by {@link #convertArguments}.
      * The return value of the invoker will be an {@code Object} reference,
      * boxing a primitive value if the original type returns a primitive,
      * and always null if the original type returns void.
      * <p>
      * This method is equivalent to the following code (though it may be more efficient):
      * <p><blockquote><pre>
-     * MethodHandle invoker = exactInvoker(type);
+     * MethodHandle invoker = lookup().findVirtual(MethodHandle.class, "invokeGeneric", type);
      * MethodType genericType = type.generic();
      * genericType = genericType.insertParameterType(0, MethodHandle.class);
-     * return convertArguments(invoker, genericType);
+     * return invoker.asType(genericType);
      * </pre></blockquote>
      * @param type the type of target methods which the invoker will apply to
      * @return a method handle suitable for invoking any method handle of the given type
@@ -845,9 +858,8 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle which will invoke any method handle of the
-     * given type on a standard set of {@code Object} type arguments
+     * given {@code type} on a standard set of {@code Object} type arguments
      * and a single trailing {@code Object[]} array.
      * The resulting invoker will be a method handle with the following
      * arguments:
@@ -856,18 +868,31 @@
      * <li>zero or more {@code Object} values (counted by {@code objectArgCount})
      * <li>an {@code Object[]} array containing more arguments
      * </ul>
-     * The invoker will spread the varargs array, apply
-     * reference casts as necessary, and unbox primitive arguments.
+     * <p>
+     * The invoker will behave like a call to {@link MethodHandle.invokeGeneric} with
+     * the indicated {@code type}.
+     * That is, if the target is exactly of the given {@code type}, it will behave
+     * like {@code invokeExact}; otherwise it behave as if {@link MethodHandle.asType}
+     * is used to convert the target to the required {@code type}.
+     * <p>
+     * The type of the returned invoker will not be the given {@code type}, but rather
+     * will have all parameter and return types replaced by {@code Object}, except for
+     * the last parameter type, which will be the array type {@code Object[]}.
+     * <p>
+     * Before invoking its target, the invoker will spread the varargs array, apply
+     * reference casts as necessary, and unbox and widen primitive arguments.
      * The return value of the invoker will be an {@code Object} reference,
      * boxing a primitive value if the original type returns a primitive,
      * and always null if the original type returns void.
      * <p>
      * This method is equivalent to the following code (though it may be more efficient):
      * <p><blockquote><pre>
-     * MethodHandle invoker = exactInvoker(type);
-     * MethodType vaType = MethodType.makeGeneric(objectArgCount, true);
+     * MethodHandle invoker = lookup().findVirtual(MethodHandle.class, "invokeGeneric", type);
+     * MethodType vaType = MethodType.genericMethodType(objectArgCount, true);
      * vaType = vaType.insertParameterType(0, MethodHandle.class);
-     * return spreadArguments(invoker, vaType);
+     * int spreadArgCount = type.parameterCount - objectArgCount;
+     * invoker = invoker.asSpreader(Object.class, spreadArgCount);
+     * return invoker.asType(vaType);
      * </pre></blockquote>
      * @param type the desired target type
      * @param objectArgCount number of fixed (non-varargs) {@code Object} arguments
@@ -881,7 +906,6 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle which will take a invoke any method handle of the
      * given type.  The resulting invoker will have a type which is
      * exactly equal to the desired type, except that it will accept
@@ -889,7 +913,7 @@
      * <p>
      * This method is equivalent to the following code (though it may be more efficient):
      * <p><blockquote><pre>
-     * lookup().findVirtual(MethodHandle.class, "invoke", type);
+     * lookup().findVirtual(MethodHandle.class, "invokeExact", type);
      * </pre></blockquote>
      * @param type the desired target type
      * @return a method handle suitable for invoking any method handle of the given type
@@ -900,37 +924,16 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * <em>METHOD WILL BE REMOVED FOR PFD:</em>
      * Produce a method handle equivalent to an invokedynamic instruction
      * which has been linked to the given call site.
-     * Along with {@link Lookup#findVirtual}, {@link Lookup#findStatic},
-     * and {@link Lookup#findSpecial}, this completes the emulation
-     * of the JVM's {@code invoke} instructions.
-     * <p>This method is equivalent to the following code:
-     * <p><blockquote><pre>
-     * MethodHandle getTarget, invoker, result;
-     * getTarget = lookup().bind(site, "getTarget", methodType(MethodHandle.class));
-     * invoker = exactInvoker(site.type());
-     * result = foldArguments(invoker, getTarget)
-     * </pre></blockquote>
      * @return a method handle which always invokes the call site's target
+     * @deprecated Use {@link CallSite#dynamicInvoker} instead.
      */
     public static
     MethodHandle dynamicInvoker(CallSite site) throws NoAccessException {
-        MethodHandle getCSTarget = GET_TARGET;
-        if (getCSTarget == null) {
-            try {
-                GET_TARGET = getCSTarget = Lookup.IMPL_LOOKUP.
-                    findVirtual(CallSite.class, "getTarget", MethodType.methodType(MethodHandle.class));
-            } catch (NoAccessException ex) {
-                throw new InternalError();
-            }
-        }
-        MethodHandle getTarget = MethodHandleImpl.bindReceiver(IMPL_TOKEN, getCSTarget, site);
-        MethodHandle invoker = exactInvoker(site.type());
-        return foldArguments(invoker, getTarget);
+        return site.dynamicInvoker();
     }
-    private static MethodHandle GET_TARGET = null;  // link this lazily, not eagerly
 
     static Invokers invokers(MethodType type) {
         return MethodTypeImpl.invokers(IMPL_TOKEN, type);
@@ -974,23 +977,23 @@
             if (t0.isPrimitive())
                 return Wrapper.asPrimitiveType(t1).cast(value);
             else
-                return Wrapper.OBJECT.cast(value, t1);
+                return Wrapper.OBJECT.convert(value, t1);
         }
         boolean prim0 = t0.isPrimitive(), prim1 = t1.isPrimitive();
         if (!prim0) {
             // check contract with caller
-            Wrapper.OBJECT.cast(value, t0);
+            Wrapper.OBJECT.convert(value, t0);
             if (!prim1) {
-                return Wrapper.OBJECT.cast(value, t1);
+                return Wrapper.OBJECT.convert(value, t1);
             }
             // convert reference to primitive by unboxing
             Wrapper w1 = Wrapper.forPrimitiveType(t1);
-            return w1.cast(value, t1);
+            return w1.convert(value, t1);
         }
         // check contract with caller:
         Wrapper.asWrapperType(t0).cast(value);
         Wrapper w1 = Wrapper.forPrimitiveType(t1);
-        return w1.cast(value, t1);
+        return w1.convert(value, t1);
     }
 
     static
@@ -1011,7 +1014,7 @@
      * Produce a method handle which adapts the type of the
      * given method handle to a new type by pairwise argument conversion.
      * The original type and new type must have the same number of arguments.
-     * The resulting method handle is guaranteed to confess a type
+     * The resulting method handle is guaranteed to report a type
      * which is equal to the desired new type.
      * <p>
      * If the original type and new type are equal, returns target.
@@ -1023,34 +1026,21 @@
      * Given those types T0, T1, one of the following conversions is applied
      * if possible:
      * <ul>
-     * <li>If T0 and T1 are references, and T1 is not an interface type,
-     *     then a cast to T1 is applied.
+     * <li>If T0 and T1 are references, then a cast to T1 is applied.
      *     (The types do not need to be related in any particular way.)
-     * <li>If T0 and T1 are references, and T1 is an interface type,
-     *     then the value of type T0 is passed as a T1 without a cast.
-     *     (This treatment of interfaces follows the usage of the bytecode verifier.)
-     * <li>If T0 and T1 are primitives, then a Java casting
-     *     conversion (JLS 5.5) is applied, if one exists.
-     * <li>If T0 and T1 are primitives and one is boolean,
-     *     the boolean is treated as a one-bit unsigned integer.
-     *     (This treatment follows the usage of the bytecode verifier.)
-     *     A conversion from another primitive type behaves as if
-     *     it first converts to byte, and then masks all but the low bit.
+     * <li>If T0 and T1 are primitives, then a Java method invocation
+     *     conversion (JLS 5.3) is applied, if one exists.
      * <li>If T0 is a primitive and T1 a reference, a boxing
      *     conversion is applied if one exists, possibly followed by
-     *     an reference conversion to a superclass.
+     *     a reference conversion to a superclass.
      *     T1 must be a wrapper class or a supertype of one.
-     *     If T1 is a wrapper class, T0 is converted if necessary
-     *     to T1's primitive type by one of the preceding conversions.
-     *     Otherwise, T0 is boxed, and its wrapper converted to T1.
      * <li>If T0 is a reference and T1 a primitive, an unboxing
-     *     conversion is applied if one exists, possibly preceded by
-     *     a reference conversion to a wrapper class.
+     *     conversion will be applied at runtime, possibly followed
+     *     by a Java method invocation conversion (JLS 5.3)
+     *     on the primitive value.  (These are the widening conversions.)
      *     T0 must be a wrapper class or a supertype of one.
-     *     If T0 is a wrapper class, its primitive value is converted
-     *     if necessary to T1 by one of the preceding conversions.
-     *     Otherwise, T0 is converted directly to the wrapper type for T1,
-     *     which is then unboxed.
+     *     (In the case where T0 is Object, these are the conversions
+     *     allowed by java.lang.reflect.Method.invoke.)
      * <li>If the return type T1 is void, any returned value is discarded
      * <li>If the return type T0 is void and T1 a reference, a null value is introduced.
      * <li>If the return type T0 is void and T1 a primitive, a zero value is introduced.
@@ -1060,8 +1050,9 @@
      * @return a method handle which delegates to {@code target} after performing
      *           any necessary argument conversions, and arranges for any
      *           necessary return value conversions
-     * @throws IllegalArgumentException if the conversion cannot be made
+     * @throws WrongMethodTypeException if the conversion cannot be made
      * @see MethodHandle#asType
+     * @see MethodHandles#explicitCastArguments
      */
     public static
     MethodHandle convertArguments(MethodHandle target, MethodType newType) {
@@ -1081,9 +1072,88 @@
 
     /**
      * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * Produce a method handle which adapts the type of the
+     * given method handle to a new type by pairwise argument conversion.
+     * The original type and new type must have the same number of arguments.
+     * The resulting method handle is guaranteed to report a type
+     * which is equal to the desired new type.
+     * <p>
+     * If the original type and new type are equal, returns target.
+     * <p>
+     * The same conversions are allowed as for {@link #convertArguments convertArguments},
+     * and some additional conversions are also applied if those conversions fail.
+     * Given types T0, T1, one of the following conversions is applied
+     * in addition, if the conversions specified for {@code convertArguments}
+     * would be insufficient:
+     * <ul>
+     * <li>If T0 and T1 are references, and T1 is an interface type,
+     *     then the value of type T0 is passed as a T1 without a cast.
+     *     (This treatment of interfaces follows the usage of the bytecode verifier.)
+     * <li>If T0 and T1 are primitives and one is boolean,
+     *     the boolean is treated as a one-bit unsigned integer.
+     *     (This treatment follows the usage of the bytecode verifier.)
+     *     A conversion from another primitive type behaves as if
+     *     it first converts to byte, and then masks all but the low bit.
+     * <li>If a primitive value would be converted by {@code convertArguments}
+     *     using Java method invocation conversion (JLS 5.3),
+     *     Java casting conversion (JLS 5.5) may be used also.
+     *     This allows primitives to be narrowed as well as widened.
+     * </ul>
+     * @param target the method handle to invoke after arguments are retyped
+     * @param newType the expected type of the new method handle
+     * @return a method handle which delegates to {@code target} after performing
+     *           any necessary argument conversions, and arranges for any
+     *           necessary return value conversions
+     * @throws WrongMethodTypeException if the conversion cannot be made
+     * @see MethodHandle#asType
+     * @see MethodHandles#convertArguments
+     */
+    public static
+    MethodHandle explicitCastArguments(MethodHandle target, MethodType newType) {
+        return convertArguments(target, newType);  // FIXME!
+    }
+
+    /*
+      FIXME: Reconcile javadoc with 10/22/2010 EG notes on conversion:
+
+      Both converters arrange for their method handles to convert arguments
+      and return values.  The conversion rules are the same for arguments
+      and return values, and depend only on source and target types, S and
+      T.  The conversions allowed by castConvertArguments are a strict
+      superset of those performed by convertArguments.
+
+      In all cases, if S and T are references, a simple checkcast is done.
+      If neither S nor T is a primitive, no attempt is made to unbox and
+      box.  A failed conversion throws ClassCastException.
+
+      If T is void, the value is dropped.
+
+      For compatibility with reflection, if S is void and T is a reference,
+      a null value is produced.
+
+      For compatibility with reflection, if S is a reference and T is a
+      primitive, S is first unboxed and then undergoes primitive conversion.
+      In the case of 'convertArguments', only assignment conversion is
+      performed (no narrowing primitive conversion).
+
+      If S is a primitive, S is boxed, and then the above rules are applied.
+      If S and T are both primitives, the boxing will be undetectable; only
+      the primitive conversions will be apparent to the user.  The key point
+      is that if S is a primitive type, the implementation may box it and
+      treat is as Object, without loss of information, or it may use a "fast
+      path" which does not use boxing.
+
+      Notwithstanding the rules above, for compatibility with the verifier,
+      if T is an interface, it is treated as if it were Object.  [KEEP THIS?]
+
+      Also, for compatibility with the verifier, a boolean may be undergo
+      widening or narrowing conversion to any other primitive type.  [KEEP THIS?]
+    */
+
+    /**
      * Produce a method handle which adapts the calling sequence of the
      * given method handle to a new type, by reordering the arguments.
-     * The resulting method handle is guaranteed to confess a type
+     * The resulting method handle is guaranteed to report a type
      * which is equal to the desired new type.
      * <p>
      * The given array controls the reordering.
@@ -1096,22 +1166,42 @@
      * outgoing argument will be taken from the {@code I}-th incoming
      * argument, where {@code I} is {@code reorder[N]}.
      * <p>
+     * No argument or return value conversions are applied.
+     * The type of each incoming argument, as determined by {@code newType},
+     * must be identical to the type of the corresponding outgoing argument
+     * or arguments in the target method handle.
+     * The return type of {@code newType} must be identical to the return
+     * type of the original target.
+     * <p>
      * The reordering array need not specify an actual permutation.
      * An incoming argument will be duplicated if its index appears
      * more than once in the array, and an incoming argument will be dropped
      * if its index does not appear in the array.
-     * <p>
-     * Pairwise conversions are applied as needed to arguments and return
-     * values, as with {@link #convertArguments}.
+     * As in the case of {@link #dropArguments(MethodHandle,int,List) dropArguments},
+     * incoming arguments which are not mentioned in the reordering array
+     * are may be any type, as determined only by {@code newType}.
+     * <blockquote><pre>
+MethodType intfn1 = MethodType.methodType(int.class, int.class);
+MethodType intfn2 = MethodType.methodType(int.class, int.class, int.class);
+MethodHandle sub = ... {int x, int y => x-y} ...;
+assert(sub.type().equals(intfn2));
+MethodHandle sub1 = MethodHandles.permuteArguments(sub, intfn2, 0, 1);
+MethodHandle rsub = MethodHandles.permuteArguments(sub, intfn2, 1, 0);
+assert((int)rsub.invokeExact(1, 100) == 99);
+MethodHandle add = ... {int x, int y => x+y} ...;
+assert(add.type().equals(intfn2));
+MethodHandle twice = MethodHandles.permuteArguments(add, intfn1, 0, 0);
+assert(twice.type().equals(intfn1));
+assert((int)twice.invokeExact(21) == 42);
+     * </pre></blockquote>
      * @param target the method handle to invoke after arguments are reordered
      * @param newType the expected type of the new method handle
      * @param reorder a string which controls the reordering
-     * @return a method handle which delegates to {@code target} after performing
-     *           any necessary argument motion and conversions, and arranges for any
-     *           necessary return value conversions
+     * @return a method handle which delegates to {@code target} after it
+     *           drops unused arguments and moves and/or duplicates the other arguments
      */
     public static
-    MethodHandle permuteArguments(MethodHandle target, MethodType newType, int[] reorder) {
+    MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {
         MethodType oldType = target.type();
         checkReorder(reorder, newType, oldType);
         return MethodHandleImpl.convertArguments(IMPL_TOKEN, target,
@@ -1134,33 +1224,21 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
-     * Produce a method handle which adapts the type of the
-     * given method handle to a new type, by spreading the final argument.
-     * The resulting method handle is guaranteed to confess a type
-     * which is equal to the desired new type.
-     * <p>
-     * The final parameter type of the new type must be an array type T[].
-     * This is the type of what is called the <i>spread</i> argument.
-     * All other arguments of the new type are called <i>ordinary</i> arguments.
-     * <p>
-     * The ordinary arguments of the new type are pairwise converted
-     * to the initial parameter types of the old type, according to the
-     * rules in {@link #convertArguments}.
-     * Any additional arguments in the old type
-     * are converted from the array element type T,
-     * again according to the rules in {@link #convertArguments}.
-     * The return value is converted according likewise.
-     * <p>
-     * The call verifies that the spread argument is in fact an array
-     * of exactly the type length, i.e., the excess number of
-     * arguments in the old type over the ordinary arguments in the new type.
-     * If there are no excess arguments, the spread argument is also
-     * allowed to be null.
-     * @param target the method handle to invoke after the argument is prepended
+     * <em>METHOD WILL BE REMOVED FOR PFD:</em>
+     * Equivalent to the following code:
+     * <p><blockquote><pre>
+     * int spreadPos = newType.parameterCount() - 1;
+     * Class<?> spreadType = newType.parameterType(spreadPos);
+     * int spreadCount = target.type().parameterCount() - spreadPos;
+     * MethodHandle adapter = target.asSpreader(spreadType, spreadCount);
+     * adapter = adapter.asType(newType);
+     * return adapter;
+     * </pre></blockquote>
+     * @param target the method handle to invoke after argument spreading
      * @param newType the expected type of the new method handle
-     * @return a new method handle which spreads its final argument,
+     * @return a method handle which spreads its final argument,
      *         before calling the original method handle
+     * @deprecated Use {@link MethodHandle#asSpreader}
      */
     public static
     MethodHandle spreadArguments(MethodHandle target, MethodType newType) {
@@ -1180,21 +1258,22 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
-     * Produce a method handle which adapts the type of the
-     * given method handle to a new type, by collecting a series of
-     * trailing arguments as elements to a single argument array.
-     * <p>
-     * This method may be used as an inverse to {@link #spreadArguments}.
-     * The final parameter type of the old type must be an array type T[],
-     * which is the type of what is called the <i>spread</i> argument.
-     * The trailing arguments of the new type which correspond to
-     * the spread argument are all converted to type T and collected
-     * into an array before the original method is called.
-     * @param target the method handle to invoke after the argument is prepended
+     * <em>METHOD WILL BE REMOVED FOR PFD:</em>
+     * Equivalent to the following code:
+     * <p><blockquote><pre>
+     * int collectPos = target.type().parameterCount() - 1;
+     * Class<?> collectType = target.type().parameterType(collectPos);
+     * if (!collectType.isArray())  collectType = Object[].class;
+     * int collectCount = newType.parameterCount() - collectPos;
+     * MethodHandle adapter = target.asCollector(collectType, collectCount);
+     * adapter = adapter.asType(newType);
+     * return adapter;
+     * </pre></blockquote>
+     * @param target the method handle to invoke after argument collection
      * @param newType the expected type of the new method handle
-     * @return a new method handle which collects some trailing argument
+     * @return a method handle which collects some trailing argument
      *         into an array, before calling the original method handle
+     * @deprecated Use {@link MethodHandle#asCollector} instead.
      */
     public static
     MethodHandle collectArguments(MethodHandle target, MethodType newType) {
@@ -1214,6 +1293,92 @@
 
     /**
      * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * Produce a method handle of the requested return type which returns the given
+     * constant value every time it is invoked.
+     * <p>
+     * Before the method handle is returned, the passed-in value is converted to the requested type.
+     * If the requested type is primitive, widening primitive conversions are attempted,
+     * else reference conversions are attempted.
+     * <p>The returned method handle is equivalent to {@code identity(type).bindTo(value)},
+     * unless the type is {@code void}, in which case it is {@code identity(type)}.
+     * @param type the return type of the desired method handle
+     * @param value the value to return
+     * @return a method handle of the given return type and no arguments, which always returns the given value
+     * @throws WrongMethodTypeException if the value cannot be converted to the required return type
+     */
+    public static
+    MethodHandle constant(Class<?> type, Object value) {
+        if (type.isPrimitive()) {
+            if (type == void.class)  return identity(type);
+            Wrapper w = Wrapper.forPrimitiveType(type);
+            return identity(type).bindTo(w.convert(value, type));
+        } else {
+            return identity(type).bindTo(type.cast(value));
+        }
+    }
+
+    /**
+     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * Produce a method handle of the requested type which returns the given
+     * constant value every time it is invoked.
+     * <p>
+     * Before the method handle is returned, the passed-in value is converted to the requested return type,
+     * as if by {@link #explicitCastArguments #explicitCastArguments}.
+     * That is, if the return type is primitive, the value is unboxed,
+     * and the primitive value is widened and/or narrowed.
+     * Otherwise, reference conversions are attempted.
+     * @param type the type of the desired method handle
+     * @param value the value to return
+     * @return a method handle of the given return type and no arguments, which always returns the given value
+     * @throws WrongMethodTypeException if the value cannot be converted to the required return type
+     */
+    public static
+    MethodHandle constant(MethodType type, Object value) {
+        MethodHandle target = constant(type.returnType(), value);
+        int len = type.parameterCount();
+        if (len == 0)
+            return target.asType(type);
+        target = target.asType(type.dropParameterTypes(0, len));
+        return dropArguments(target, 0, type.parameterList().subList(0, len));
+    }
+
+     /**
+      * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+      * Produce a method handle which returns its sole argument when invoked.
+      * <p>The identity function for {@code void} takes no arguments and returns no values.
+      * @param type the type of the sole parameter and return value of the desired method handle
+      * @return a unary method handle which accepts and returns the given type
+      */
+    public static
+    MethodHandle identity(Class<?> type) {
+        return ValueConversions.identity(type);
+    }
+
+     /**
+      * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+      * Produce a method handle of the requested type which returns its argument when invoked.
+      * If the return type differs from the first argument type, the argument will be
+      * converted as if by {@link #explicitCastArguments explicitCastArguments}.
+      * All other arguments are discarded.
+      * <p>The identity function for {@code void} discards all its arguments.
+      * <p>
+      * @param type the type of the desired method handle
+      * @return a method handle of the given type, which always returns its first argument
+      * @throws WrongMethodTypeException if the first argument cannot be converted to the required return type
+      */
+    public static
+    MethodHandle identity(MethodType type) {
+        MethodHandle target = identity(type.returnType());
+        int len = type.parameterCount();
+        if (len == 1)
+            return explicitCastArguments(target, type);
+        if (len == 0)
+            throw new IllegalArgumentException("not enough arguments");
+        target = explicitCastArguments(target, type.dropParameterTypes(1, len));
+        return dropArguments(target, 1, type.parameterList().subList(1, len));
+    }
+
+    /**
      * Produce a method handle which calls the original method handle {@code target},
      * after inserting the given argument(s) at the given position.
      * The formal parameters to {@code target} which will be supplied by those
@@ -1233,8 +1398,9 @@
      * @param target the method handle to invoke after the argument is inserted
      * @param pos where to insert the argument (zero for the first)
      * @param values the series of arguments to insert
-     * @return a new method handle which inserts an additional argument,
+     * @return a method handle which inserts an additional argument,
      *         before calling the original method handle
+     * @see MethodHandle#bindTo
      */
     public static
     MethodHandle insertArguments(MethodHandle target, int pos, Object... values) {
@@ -1267,14 +1433,7 @@
         return result;
     }
 
-    @Deprecated // "use MethodHandles.insertArguments instead"
-    public static
-    MethodHandle insertArgument(MethodHandle target, int pos, Object value) {
-        return insertArguments(target, pos, value);
-    }
-
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a method handle which calls the original method handle,
      * after dropping the given argument(s) at the given position.
      * The type of the new method handle will insert the given argument
@@ -1302,10 +1461,10 @@
      *   MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
      *   System.out.println((String) d12.invokeExact("x", 12, true, "z")); // xz
      * </pre></blockquote>
-     * @param target the method handle to invoke after the argument is dropped
-     * @param valueTypes the type(s) of the argument to drop
-     * @param pos which argument to drop (zero for the first)
-     * @return a new method handle which drops an argument of the given type,
+     * @param target the method handle to invoke after the arguments are dropped
+     * @param valueTypes the type(s) of the argument(s) to drop
+     * @param pos position of first argument to drop (zero for the leftmost)
+     * @return a method handle which drops arguments of the given types,
      *         before calling the original method handle
      */
     public static
@@ -1323,23 +1482,36 @@
         return MethodHandleImpl.dropArguments(IMPL_TOKEN, target, newType, pos);
     }
 
+    /**
+     * Produce a method handle which calls the original method handle,
+     * after dropping the given argument(s) at the given position.
+     * The type of the new method handle will insert the given argument
+     * type(s), at that position, into the original handle's type.
+     * This method is equivalent to the following code:
+     * <code>
+     * {@link #dropArguments(MethodHandle,int,List) dropArguments}(target, pos, Arrays.asList(valueTypes))
+     * </code>
+     * @param target the method handle to invoke after the arguments are dropped
+     * @param valueTypes the type(s) of the argument(s) to drop
+     * @param pos position of first argument to drop (zero for the leftmost)
+     * @return a method handle which drops arguments of the given types,
+     *         before calling the original method handle
+     */
     public static
     MethodHandle dropArguments(MethodHandle target, int pos, Class<?>... valueTypes) {
         return dropArguments(target, pos, Arrays.asList(valueTypes));
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Adapt a target method handle {@code target} by pre-processing
      * one or more of its arguments, each with its own unary filter function,
      * and then calling the target with each pre-processed argument
      * replaced by the result of its corresponding filter function.
      * <p>
      * The pre-processing is performed by one or more method handles,
-     * specified in the non-null elements of the {@code filters} array.
-     * (If there are no such elements, the original target is returned.)
-     * Each filter (that is, each non-null element of {@code filters})
-     * is applied to the corresponding argument of the adapter.
+     * specified in the elements of the {@code filters} array.
+     * (If there are no elements in the array, the original target is returned.)
+     * Each filter is applied to the corresponding argument of the adapter.
      * <p>
      * If a filter {@code F} applies to the {@code N}th argument of
      * the method handle, then {@code F} must be a method handle which
@@ -1349,46 +1521,49 @@
      * The return type of {@code F} must be identical to the corresponding
      * parameter type of the target.
      * <p>
-     * It is an error if there are non-null elements of {@code filters}
+     * It is an error if there are elements of {@code filters}
      * which do not correspond to argument positions in the target.
-     * The actual length of the target array may be any number, it need
-     * not be the same as the parameter count of the target type.
-     * (This provides an easy way to filter just the first argument or two
-     * of a target method handle.)
-     * <p> Here is pseudocode for the resulting adapter:
-     * <blockquote><pre>
-     * // there are N arguments in the A sequence
-     * T target(A[N]...);
-     * [i&lt;N] V[i] filter[i](B[i]) = filters[i] ?: identity;
-     * T adapter(B[N]... b) {
-     *   A[N] a...;
-     *   [i&lt;N] a[i] = filter[i](b[i]);
-     *   return target(a...);
-     * }
+     * <b>Example:</b>
+     * <p><blockquote><pre>
+import static java.dyn.MethodHandles.*;
+import static java.dyn.MethodType.*;
+...
+MethodHandle cat = lookup().findVirtual(String.class,
+  "concat", methodType(String.class, String.class));
+MethodHandle upcase = lookup().findVirtual(String.class,
+  "toUpperCase", methodType(String.class));
+System.out.println((String) cat.invokeExact("x", "y")); // xy
+MethodHandle f0 = filterArguments(cat, 0, upcase);
+System.out.println((String) f0.invokeExact("x", "y")); // Xy
+MethodHandle f1 = filterArguments(cat, 1, upcase);
+System.out.println((String) f1.invokeExact("x", "y")); // xY
+MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
+System.out.println((String) f2.invokeExact("x", "y")); // XY
      * </pre></blockquote>
      * @param target the method handle to invoke after arguments are filtered
+     * @param pos the position of the first argument to filter
      * @param filters method handles to call initially on filtered arguments
      * @return method handle which incorporates the specified argument filtering logic
-     * @throws IllegalArgumentException if a non-null element of {@code filters}
-     *          does not match a corresponding argument type of {@code target}
+     * @throws IllegalArgumentException if an element of {@code filters} is null or
+     *          does not match a corresponding argument type of {@code target} as described above
      */
     public static
-    MethodHandle filterArguments(MethodHandle target, MethodHandle... filters) {
+    MethodHandle filterArguments(MethodHandle target, int pos, MethodHandle... filters) {
         MethodType targetType = target.type();
         MethodHandle adapter = target;
         MethodType adapterType = targetType;
-        int pos = -1, maxPos = targetType.parameterCount();
+        int maxPos = targetType.parameterCount();
+        int curPos = pos;
         for (MethodHandle filter : filters) {
-            pos += 1;
-            if (filter == null)  continue;
-            if (pos >= maxPos)
+            if (curPos >= maxPos)
                 throw newIllegalArgumentException("too many filters");
             MethodType filterType = filter.type();
             if (filterType.parameterCount() != 1
-                || filterType.returnType() != targetType.parameterType(pos))
+                || filterType.returnType() != targetType.parameterType(curPos))
                 throw newIllegalArgumentException("target and filter types do not match");
-            adapterType = adapterType.changeParameterType(pos, filterType.parameterType(0));
-            adapter = MethodHandleImpl.filterArgument(IMPL_TOKEN, adapter, pos, filter);
+            adapterType = adapterType.changeParameterType(curPos, filterType.parameterType(0));
+            adapter = MethodHandleImpl.filterArgument(IMPL_TOKEN, adapter, curPos, filter);
+            curPos += 1;
         }
         MethodType midType = adapter.type();
         if (midType != adapterType)
@@ -1396,9 +1571,37 @@
         return adapter;
     }
 
-    /** Apply the given filter function to the return value of the given target.
+    /** <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * Adapt a target method handle {@code target} by post-processing
+     * its return value with a unary filter function.
+     * <p>
+     * If a filter {@code F} applies to the return value of
+     * the target method handle, then {@code F} must be a method handle which
+     * takes exactly one argument.  The return type of {@code F}
+     * replaces the return type of the target
+     * in the resulting adapted method handle.
+     * The argument type of {@code F} must be identical to the
+     * return type of the target.
+     * <b>Example:</b>
+     * <p><blockquote><pre>
+import static java.dyn.MethodHandles.*;
+import static java.dyn.MethodType.*;
+...
+MethodHandle cat = lookup().findVirtual(String.class,
+  "concat", methodType(String.class, String.class));
+MethodHandle length = lookup().findVirtual(String.class,
+  "length", methodType(int.class));
+System.out.println((String) cat.invokeExact("x", "y")); // xy
+MethodHandle f0 = filterReturnValue(cat, length);
+System.out.println((int) f0.invokeExact("x", "y")); // 2
+     * </pre></blockquote>
+     * @param target the method handle to invoke before filtering the return value
+     * @param filter method handle to call on the return value
+     * @return method handle which incorporates the specified return value filtering logic
+     * @throws IllegalArgumentException if {@code filter} is null or
+     *          does not match the return type of {@code target} as described above
      */
-    /*public*/ static
+    public static
     MethodHandle filterReturnValue(MethodHandle target, MethodHandle filter) {
         MethodType targetType = target.type();
         MethodType filterType = filter.type();
@@ -1411,7 +1614,6 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Adapt a target method handle {@code target} by pre-processing
      * some of its arguments, and then calling the target with
      * the result of the pre-processing, plus all original arguments.
@@ -1428,10 +1630,10 @@
      * The resulting adapter is the same type as the target, except that the
      * initial argument type of the target is dropped.
      * <p>
-     * (Note that {@link #dropArguments} can be used to remove any arguments
+     * (Note that {@link #dropArguments(MethodHandle,int,List) dropArguments} can be used to remove any arguments
      * that either the {@code combiner} or {@code target} does not wish to receive.
      * If some of the incoming arguments are destined only for the combiner,
-     * consider using {@link #collectArguments} instead, since those
+     * consider using {@link MethodHandle#asCollector} instead, since those
      * arguments will not need to be live on the stack on entry to the
      * target.)
      * <p>
@@ -1471,31 +1673,7 @@
         return MethodHandleImpl.foldArguments(IMPL_TOKEN, target, newType, combiner);
     }
 
-    // /**
-    //  * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
-    //  * Adapt a target method handle {@code target} by pre-processing
-    //  * some of its arguments to derive a new target method handle.
-    //  * Call the new target on the original arguments.
-    //  * @param combined method handle to call initially on the incoming arguments
-    //  * @return method handle which incorporates the specified dispatching logic
-    //  * @throws IllegalArgumentException if the first argument type of
-    //  *          {@code combiner}'s return type is not {@link MethodHandle},
-    //  *          or if the next argument types of {@code target}
-    //  *          are not identical with the argument types of {@code combiner}
-    //  */
-    // public static
-    // MethodHandle dispatchArguments(MethodType targetType, MethodHandle dispatcher) {
-    //     MethodType dispatcherType = dispatcher.type();
-    //     int foldArgs = dispatcherType.parameterCount();
-    //     boolean ok = (targetType.parameterCount() >= foldArgs);
-    //     if (!ok)
-    //         throw misMatchedTypes("target and dispatcher types", targetType, dispatcherType);
-    //     MethodHandle target = exactInvoker(targetType);
-    //     return MethodHandleImpl.foldArguments(IMPL_TOKEN, target, targetType, dispatcher);
-    // }
-
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Make a method handle which adapts a target method handle,
      * by guarding it with a test, a boolean-valued method handle.
      * If the guard fails, a fallback handle is called instead.
@@ -1572,7 +1750,6 @@
     }
 
     /**
-     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Make a method handle which adapts a target method handle,
      * by running it inside an exception handler.
      * If the target returns normally, the adapter returns that value.
@@ -1635,6 +1812,7 @@
     }
 
     /**
+     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
      * Produce a wrapper instance of the given "SAM" type which redirects its calls to the given method handle.
      * A SAM type is a type which declares a single abstract method.
      * Additionally, it must have either no constructor (as an interface)
@@ -1663,7 +1841,6 @@
      * <li>the SAM type itself and any methods in the SAM type
      * <li>the supertypes of the SAM type (if any) and their methods
      * <li>{@link Object} and its methods
-     * <li>{@link MethodHandleProvider} and its methods
      * </ul>
      * <p>
      * No stable mapping is promised between the SAM type and
@@ -1684,9 +1861,9 @@
      */
     // ISSUE: Should we delegate equals/hashCode to the targets?
     // Not useful unless there is a stable equals/hashCode behavior
-    // for MethodHandle, and for MethodHandleProvider.asMethodHandle.
+    // for MethodHandle, but there isn't.
     public static
-    <T> T asInstance(MethodHandle target, Class<T> samType) {
+    <T> T asInstance(final MethodHandle target, final Class<T> samType) {
         // POC implementation only; violates the above contract several ways
         final Method sam = getSamMethod(samType);
         if (sam == null)
@@ -1694,21 +1871,42 @@
         MethodType samMT = MethodType.methodType(sam.getReturnType(), sam.getParameterTypes());
         if (!samMT.equals(target.type()))
             throw new IllegalArgumentException("wrong method type");
-        final MethodHandle mh = target;
         return samType.cast(Proxy.newProxyInstance(
                 samType.getClassLoader(),
-                new Class[]{ samType, MethodHandleProvider.class },
+                new Class[]{ samType, AsInstanceObject.class },
                 new InvocationHandler() {
+                    private Object getArg(String name) {
+                        if ((Object)name == "getAsInstanceTarget")  return target;
+                        if ((Object)name == "getAsInstanceType")    return samType;
+                        throw new AssertionError();
+                    }
                     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-                        if (method.getDeclaringClass() == MethodHandleProvider.class) {
-                            return method.invoke(mh, args);
-                        }
+                        if (method.getDeclaringClass() == AsInstanceObject.class)
+                            return getArg(method.getName());
                         assert method.equals(sam) : method;
-                        return mh.invokeVarargs(args);
+                        return target.invokeVarargs(args);
                     }
                 }));
     }
 
+    /**
+     * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+     * Interface implemented by every object which is produced by {@link #asInstance asInstance}.
+     * The methods of this interface allow a caller to recover the parameters
+     * to {@code asInstance}.
+     * This allows applications to repeatedly convert between method handles
+     * and SAM objects, without the risk of creating unbounded delegation chains.
+     */
+    public interface AsInstanceObject {
+        /** Produce or recover a target method handle which is behaviorally
+         *  equivalent to the SAM method of this object.
+         */
+        public MethodHandle getAsInstanceTarget();
+        /** Recover the SAM type for which this object was created.
+         */
+        public Class<?> getAsInstanceType();
+    }
+
     private static
     Method getSamMethod(Class<?> samType) {
         Method sam = null;
diff --git a/src/share/classes/java/dyn/MethodType.java b/src/share/classes/java/dyn/MethodType.java
--- a/src/share/classes/java/dyn/MethodType.java
+++ b/src/share/classes/java/dyn/MethodType.java
@@ -119,7 +119,7 @@
         for (Class<?> ptype : ptypes) {
             ptype.equals(ptype);  // null check
             if (ptype == void.class)
-                throw newIllegalArgumentException("void parameter: "+this);
+                throw newIllegalArgumentException("parameter type cannot be void");
         }
     }
 
@@ -139,10 +139,6 @@
     MethodType methodType(Class<?> rtype, Class<?>[] ptypes) {
         return makeImpl(rtype, ptypes, false);
     }
-    @Deprecated public static
-    MethodType make(Class<?> rtype, Class<?>[] ptypes) {
-        return methodType(rtype, ptypes);
-    }
 
     /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}. */
     public static
@@ -150,10 +146,6 @@
         boolean notrust = false;  // random List impl. could return evil ptypes array
         return makeImpl(rtype, ptypes.toArray(NO_PTYPES), notrust);
     }
-    @Deprecated public static
-    MethodType make(Class<?> rtype, List<? extends Class<?>> ptypes) {
-        return methodType(rtype, ptypes);
-    }
 
     /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}.
      *  The leading parameter type is prepended to the remaining array.
@@ -165,10 +157,6 @@
         System.arraycopy(ptypes, 0, ptypes1, 1, ptypes.length);
         return makeImpl(rtype, ptypes1, true);
     }
-    @Deprecated public static
-    MethodType make(Class<?> rtype, Class<?> ptype0, Class<?>... ptypes) {
-        return methodType(rtype, ptype0, ptypes);
-    }
 
     /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}.
      *  The resulting method has no parameter types.
@@ -177,10 +165,6 @@
     MethodType methodType(Class<?> rtype) {
         return makeImpl(rtype, NO_PTYPES, true);
     }
-    @Deprecated public static
-    MethodType make(Class<?> rtype) {
-        return methodType(rtype);
-    }
 
     /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}.
      *  The resulting method has the single given parameter type.
@@ -189,10 +173,6 @@
     MethodType methodType(Class<?> rtype, Class<?> ptype0) {
         return makeImpl(rtype, new Class<?>[]{ ptype0 }, true);
     }
-    @Deprecated public static
-    MethodType make(Class<?> rtype, Class<?> ptype0) {
-        return methodType(rtype, ptype0);
-    }
 
     /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}.
      *  The resulting method has the same parameter types as {@code ptypes},
@@ -202,10 +182,6 @@
     MethodType methodType(Class<?> rtype, MethodType ptypes) {
         return makeImpl(rtype, ptypes.ptypes, true);
     }
-    @Deprecated public static
-    MethodType make(Class<?> rtype, MethodType ptypes) {
-        return methodType(rtype, ptypes);
-    }
 
     /**
      * Sole factory method to find or create an interned method type.
@@ -275,10 +251,6 @@
         }
         return mt;
     }
-    @Deprecated public static
-    MethodType makeGeneric(int objectArgCount, boolean varargs) {
-        return genericMethodType(objectArgCount, varargs);
-    }
 
     /**
      * All parameters and the return type will be Object.
@@ -290,10 +262,6 @@
     MethodType genericMethodType(int objectArgCount) {
         return genericMethodType(objectArgCount, false);
     }
-    @Deprecated public static
-    MethodType makeGeneric(int objectArgCount) {
-        return genericMethodType(objectArgCount);
-    }
 
     /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}.
      * @param num    the index (zero-based) of the parameter type to change
@@ -307,18 +275,6 @@
         return makeImpl(rtype, nptypes, true);
     }
 
-    /** Convenience method for {@link #insertParameterTypes}.
-     * @deprecated Use {@link #insertParameterTypes} instead.
-     */
-    @Deprecated
-    public MethodType insertParameterType(int num, Class<?> nptype) {
-        int len = ptypes.length;
-        Class<?>[] nptypes = Arrays.copyOfRange(ptypes, 0, len+1);
-        System.arraycopy(nptypes, num, nptypes, num+1, len-num);
-        nptypes[num] = nptype;
-        return makeImpl(rtype, nptypes, true);
-    }
-
     /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}.
      * @param num    the position (zero-based) of the inserted parameter type(s)
      * @param ptypesToInsert zero or more a new parameter types to insert into the parameter list
@@ -337,6 +293,14 @@
     }
 
     /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}.
+     * @param ptypesToInsert zero or more a new parameter types to insert after the end of the parameter list
+     * @return the same type, except with the selected parameter(s) appended
+     */
+    public MethodType appendParameterTypes(Class<?>... ptypesToInsert) {
+        return insertParameterTypes(parameterCount(), ptypesToInsert);
+    }
+
+    /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}.
      * @param num    the position (zero-based) of the inserted parameter type(s)
      * @param ptypesToInsert zero or more a new parameter types to insert into the parameter list
      * @return the same type, except with the selected parameter(s) inserted
@@ -377,14 +341,6 @@
         return makeImpl(rtype, nptypes, true);
     }
 
-    /** Convenience method for {@link #dropParameterTypes}.
-     * @deprecated Use {@link #dropParameterTypes} instead.
-     */
-    @Deprecated
-    public MethodType dropParameterType(int num) {
-        return dropParameterTypes(num, num+1);
-    }
-
     /** Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[])}.
      * @param nrtype a return parameter type to replace the old one with
      * @return the same type, except with the return type change
@@ -690,14 +646,4 @@
     public String toMethodDescriptorString() {
         return BytecodeDescriptor.unparse(this);
     }
-
-    /** Temporary alias for toMethodDescriptorString; delete after M3. */
-    public String toBytecodeString() {
-        return toMethodDescriptorString();
-    }
-    /** Temporary alias for fromMethodDescriptorString; delete after M3. */
-    public static MethodType fromBytecodeString(String descriptor, ClassLoader loader)
-        throws IllegalArgumentException, TypeNotPresentException {
-        return fromMethodDescriptorString(descriptor, loader);
-    }
 }
diff --git a/src/share/classes/java/dyn/ConstantCallSite.java b/src/share/classes/java/dyn/VolatileCallSite.java
copy from src/share/classes/java/dyn/ConstantCallSite.java
copy to src/share/classes/java/dyn/VolatileCallSite.java
--- a/src/share/classes/java/dyn/ConstantCallSite.java
+++ b/src/share/classes/java/dyn/VolatileCallSite.java
@@ -25,19 +25,120 @@
 
 package java.dyn;
 
+import java.util.List;
+
 /**
- * A {@code ConstantCallSite} is a {@link CallSite} whose target is permanent, and can never be changed.
- * The only way to relink an {@code invokedynamic} instruction bound to a {@code ConstantCallSite} is
- * to invalidate the instruction as a whole.
+ * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+ * A {@code VolatileCallSite} is a {@link CallSite} whose target acts like a volatile variable.
+ * An {@code invokedynamic} instruction linked to a {@code VolatileCallSite} sees updates
+ * to its call site target immediately, even if the update occurs in another thread.
+ * <p>
+ * Also, a volatile call site has the ability to be <em>invalidated</em>,
+ * or reset to a well-defined fallback state.
+ * <p>
+ * A volatile call site can be used as a switch to control the behavior
+ * of another method handle.  For example:
+ * <blockquote><pre>
+MethodHandle strcat = MethodHandles.lookup()
+  .findVirtual(String.class, "concat", MethodType.methodType(String.class, String.class));
+MethodHandle trueCon  = MethodHandles.constant(boolean.class, true);
+MethodHandle falseCon = MethodHandles.constant(boolean.class, false);
+VolatileCallSite switcher = new VolatileCallSite(trueCon, falseCon);
+// following steps may be repeated to re-use the same switcher:
+MethodHandle worker1 = strcat;
+MethodHandle worker2 = MethodHandles.permuteArguments(strcat, strcat.type(), 1, 0);
+MethodHandle worker = MethodHandles.guardWithTest(switcher.dynamicInvoker(), worker1, worker2);
+System.out.println((String) worker.invokeExact("met", "hod"));  // method
+switcher.invalidate();
+System.out.println((String) worker.invokeExact("met", "hod"));  // hodmet
+ * </pre></blockquote>
+ * In this case, the fallback path (worker2) does not cause a state change.
+ * In a real application, the fallback path could cause call sites to relink
+ * themselves in response to a global data structure change.
+ * Thus, volatile call sites can be used to build dependency mechanisms.
  * @author John Rose, JSR 292 EG
  */
-public class ConstantCallSite extends CallSite {
-    /** Create a call site with a permanent target. */
-    public ConstantCallSite(MethodHandle target) {
+public class VolatileCallSite extends CallSite {
+    volatile MethodHandle fallback;
+
+    /** Create a call site with a volatile target.
+     *  The initial target and fallback are both set to a method handle
+     *  of the given type which will throw {@code IllegalStateException}.
+     */
+    public VolatileCallSite(MethodType type) {
+        super(type);
+        fallback = target;
+    }
+
+    /** Create a call site with a volatile target.
+     *  The fallback and target are both set to the same initial value.
+     */
+    public VolatileCallSite(MethodHandle target) {
         super(target);
+        fallback = target;
     }
-    /** Throw an {@link IllegalArgumentException}, because this kind of call site cannot change its target. */
-    @Override public final void setTarget(MethodHandle ignore) {
-        throw new IllegalArgumentException("ConstantCallSite");
+
+    /** Create a call site with a volatile target.
+     *  The fallback and target are set to the given initial values.
+     */
+    public VolatileCallSite(MethodHandle target, MethodHandle fallback) {
+        this(target);
+        checkTargetChange(target, fallback);  // make sure they have the same type
+        this.fallback = fallback;
     }
+
+    /** Internal override to nominally final getTarget. */
+    @Override
+    MethodHandle getTarget0() {
+        return getTargetVolatile();
+    }
+
+    /**
+     * Set the target method of this call site, as a volatile variable.
+     * Has the same effect as {@link CallSite#setTarget}, with the additional
+     * effects associated with volatiles, in the Java Memory Model.
+     */
+    @Override public void setTarget(MethodHandle newTarget) {
+        checkTargetChange(getTargetVolatile(), newTarget);
+        setTargetVolatile(newTarget);
+    }
+
+    /**
+     * Return the fallback target for this call site.
+     * It is initialized to the target the call site had when it was constructed,
+     * but it may be changed by {@link setFallbackTarget}.
+     * <p>
+     * Like the regular target of a volatile call site,
+     * the fallback target also has the behavior of a volatile variable.
+     */
+    public MethodHandle getFallbackTarget() {
+        return fallback;
+    }
+
+    /**
+     * Update the fallback target for this call site.
+     * @see #getFallbackTarget
+     */
+    public void setFallbackTarget(MethodHandle newFallbackTarget) {
+        checkTargetChange(fallback, newFallbackTarget);
+        fallback = newFallbackTarget;
+    }
+
+    /**
+     * Reset this call site to a known state by changing the target to the fallback target value.
+     * Equivalent to {@code setTarget(getFallbackTarget())}.
+     */
+    public void invalidate() {
+        setTargetVolatile(getFallbackTarget());
+    }
+
+    /**
+     * Reset all call sites in a list by changing the target of each to its fallback value.
+     */
+    public static void invalidateAll(List<VolatileCallSite> sites) {
+        for (VolatileCallSite site : sites) {
+            site.invalidate();
+        }
+    }
+
 }
diff --git a/src/share/classes/java/dyn/package-info.java b/src/share/classes/java/dyn/package-info.java
--- a/src/share/classes/java/dyn/package-info.java
+++ b/src/share/classes/java/dyn/package-info.java
@@ -24,7 +24,6 @@
  */
 
 /**
- * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
  * This package contains dynamic language support provided directly by
  * the Java core class libraries and virtual machine.
  * <p>
@@ -42,13 +41,6 @@
  * argument and return value conversions are applied.
  * </li>
  *
- * <li>In source code, the class {@link java.dyn.InvokeDynamic InvokeDynamic} appears to accept
- * any static method invocation, of any name and any signature.
- * But instead of emitting
- * an {@code invokestatic} instruction for such a call, the Java compiler emits
- * an {@code invokedynamic} instruction with the given name and signature.
- * </li>
- *
  * <li>The JVM bytecode format supports immediate constants of
  * the classes {@link java.dyn.MethodHandle MethodHandle} and {@link java.dyn.MethodType MethodType}.
  * </li>
@@ -56,7 +48,8 @@
  *
  * <h2><a name="jvm_mods"></a>Corresponding JVM bytecode format changes</h2>
  * <em>The following low-level information is presented here as a preview of
- * changes being made to the Java Virtual Machine specification for JSR 292.</em>
+ * changes being made to the Java Virtual Machine specification for JSR 292.
+ * This information will be incorporated in a future version of the JVM specification.</em>
  *
  * <h3>{@code invokedynamic} instruction format</h3>
  * In bytecode, an {@code invokedynamic} instruction is formatted as five bytes.
@@ -64,22 +57,21 @@
  * The next two bytes are a constant pool index (in the same format as for the other {@code invoke} instructions).
  * The final two bytes are reserved for future use and required to be zero.
  * The constant pool reference of an {@code invokedynamic} instruction is to a entry
- * with tag {@code CONSTANT_InvokeDynamic} (decimal 17).  See below for its format.
- * The entry specifies the bootstrap method (a {@link java.dyn.MethodHandle MethodHandle} constant),
- * the dynamic invocation name, and the argument types and return type of the call.
+ * with tag {@code CONSTANT_InvokeDynamic} (decimal 18).  See below for its format.
+ * (The tag value 17 is also allowed.  See below.)
+ * The entry specifies the following information:
+ * <ul>
+ * <li>a bootstrap method (a {@link java.dyn.MethodHandle MethodHandle} constant)</li>
+ * <li>the dynamic invocation name (a UTF8 string)</li>
+ * <li>the argument and return types of the call (encoded as a signature in a UTF8 string)</li>
+ * <li>optionally, a sequence of additional <em>static arguments</em> to the bootstrap method (constants loadable via {@code ldc})</li>
+ * </ul>
  * <p>
  * Each instance of an {@code invokedynamic} instruction is called a <em>dynamic call site</em>.
  * Multiple instances of an {@code invokedynamic} instruction can share a single
  * {@code CONSTANT_InvokeDynamic} entry.
  * In any case, distinct call sites always have distinct linkage state.
  * <p>
- * Moreover, for the purpose of distinguishing dynamic call sites,
- * the JVM is allowed (but not required) to make internal copies
- * of {@code invokedynamic} instructions, each one
- * constituting a separate dynamic call site with its own linkage state.
- * Such copying, if it occurs, cannot be observed except indirectly via
- * execution of bootstrap methods and target methods.
- * <p>
  * A dynamic call site is originally in an unlinked state.  In this state, there is
  * no target method for the call site to invoke.
  * A dynamic call site is linked by means of a bootstrap method,
@@ -90,17 +82,35 @@
  * bootstrap method was specified dynamically, in a per-class basis, during class initialization.)</em>
  *
  * <h3>constant pool entries for {@code invokedynamic} instructions</h3>
- * If a constant pool entry has the tag {@code CONSTANT_InvokeDynamic} (decimal 17),
- * it must contain exactly four more bytes.
- * The first two bytes after the tag must be an index to a {@code CONSTANT_MethodHandle}
- * entry, and the second two bytes must be an index to a {@code CONSTANT_NameAndType}.
+ * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+ * If a constant pool entry has the tag {@code CONSTANT_InvokeDynamic} (decimal 18),
+ * it must contain at least six more bytes after the tag.
+ * All of these bytes are grouped in pairs,
+ * and each pair is interpreted as a 16-bit index (in the usual {@code u2} format).
+ * The first pair of bytes after the tag must be an index to a {@code CONSTANT_MethodHandle}
+ * entry, and the second pair of bytes must be an index to a {@code CONSTANT_NameAndType}.
+ * The third pair of bytes specifies a count <em>N</em> of remaining byte pairs.
+ * After the tag and required bytes, there must be exactly <em>2N</em> remaining bytes
+ * in the constant pool entry, each pair providing the index of a constant pool entry.
+ * <p>
  * The first index specifies a bootstrap method used by the associated dynamic call sites.
  * The second index specifies the method name, argument types, and return type of the dynamic call site.
  * The structure of such an entry is therefore analogous to a {@code CONSTANT_Methodref},
- * except that the {@code CONSTANT_Class} reference in a {@code CONSTANT_Methodref} entry
- * is replaced by a bootstrap method reference.
+ * except that the bootstrap method reference replaces
+ * the {@code CONSTANT_Class} reference of a {@code CONSTANT_Methodref} entry.
+ * The remaining indexes (if there is a non-zero count) specify
+ * <a href="#args">additional static arguments</a> for the bootstrap method.
+ * <p>
+ * Some older JVMs may allow an older constant pool entry tag of decimal 17.
+ * The format and behavior of a constant pool entry with this tag is identical to
+ * an entry with a tag of decimal 18, except that the constant pool entry must not
+ * contain extra static arguments or a static argument count.
+ * The fixed size of such an entry is therefore four bytes after the tag.
+ * The value of the missing static argument count is taken to be zero.
+ * <em>(Note: The Proposed Final Draft of this specification is not likely to support
+ * both of these formats.)</em>
  *
- * <h3>constant pool entries for {@code MethodType}s</h3>
+ * <h3>constant pool entries for {@linkplain java.dyn.MethodType method types}</h3>
  * If a constant pool entry has the tag {@code CONSTANT_MethodType} (decimal 16),
  * it must contain exactly two more bytes, which must be an index to a {@code CONSTANT_Utf8}
  * entry which represents a method type signature.
@@ -112,8 +122,13 @@
  * but not initialized.
  * Access checking and error reporting is performed exactly as it is for
  * references by {@code ldc} instructions to {@code CONSTANT_Class} constants.
+ * <p>
+ * Every use of this constant pool entry must lead to the same outcome.
+ * If the resolution of the names in the method type constant causes an exception to occur,
+ * this exception must be recorded by the JVM, and re-thrown on every subsequent attempt
+ * to use this particular constant.
  *
- * <h3>constant pool entries for {@code MethodHandle}s</h3>
+ * <h3>constant pool entries for {@linkplain java.dyn.MethodHandle method handles}</h3>
  * If a constant pool entry has the tag {@code CONSTANT_MethodHandle} (decimal 15),
  * it must contain exactly three more bytes.  The first byte after the tag is a subtag
  * value which must be in the range 1 through 9, and the last two must be an index to a
@@ -129,7 +144,7 @@
  * <p>
  * As with {@code CONSTANT_Class} and {@code CONSTANT_MethodType} constants,
  * the {@code Class} or {@code MethodType} object which reifies the field or method's
- * type is created.  Any classes mentioned in this reificaiton will be loaded if necessary,
+ * type is created.  Any classes mentioned in this reification will be loaded if necessary,
  * but not initialized, and access checking and error reporting performed as usual.
  * <p>
  * The method handle itself will have a type and behavior determined by the subtag as follows:
@@ -150,14 +165,29 @@
  * <p>
  * The special names {@code <init>} and {@code <clinit>} are not allowed except for subtag 8 as shown.
  * <p>
- * The verifier applies the same access checks and restrictions for these references as for the hypothetical
+ * The JVM verifier and linker apply the same access checks and restrictions for these references as for the hypothetical
  * bytecode instructions specified in the last column of the table.  In particular, method handles to
  * private and protected members can be created in exactly those classes for which the corresponding
  * normal accesses are legal.
  * <p>
- * None of these constant types force class initialization.
- * Method handles for subtags {@code REF_getStatic}, {@code REF_putStatic}, and {@code REF_invokeStatic}
+ * A constant may refer to a method or constructor with the {@code varargs}
+ * bit (hexadecimal {@code 80}) set in its modifier bitmask.
+ * The method handle constant produced for such a method behaves the same
+ * as if the {@code varargs} bit were not set.
+ * The argument-collecting behavior of {@code varargs} can be emulated by
+ * adapting the method handle constant with
+ * {@link java.dyn.MethodHandle#asCollector asCollector}.
+ * There is no provision for doing this automatically.
+ * <p>
+ * Although the {@code CONSTANT_MethodHandle} and {@code CONSTANT_MethodType} constant types
+ * resolve class names, they do not force class initialization.
+ * Method handle constants for subtags {@code REF_getStatic}, {@code REF_putStatic}, and {@code REF_invokeStatic}
  * may force class initialization on their first invocation, just like the corresponding bytecodes.
+ * <p>
+ * Every use of this constant pool entry must lead to the same outcome.
+ * If the resolution of the names in the method handle constant causes an exception to occur,
+ * this exception must be recorded by the JVM, and re-thrown on every subsequent attempt
+ * to use this particular constant.
  *
  * <h2><a name="bsm"></a>Bootstrap Methods</h2>
  * Before the JVM can execute a dynamic call site (an {@code invokedynamic} instruction),
@@ -181,24 +211,36 @@
  * call site execution.
  * Linkage does not trigger class initialization.
  * <p>
- * Next, the bootstrap method call is started, with four values being stacked:
+ * Next, the bootstrap method call is started, with four or five values being stacked:
  * <ul>
  * <li>a {@code MethodHandle}, the resolved bootstrap method itself </li>
- * <li>a {@code Class}, the <em>caller class</em> in which dynamic call site occurs </li>
+ * <li>a {@code MethodHandles.Lookup}, a lookup object on the <em>caller class</em> in which dynamic call site occurs </li>
  * <li>a {@code String}, the method name mentioned in the call site </li>
  * <li>a {@code MethodType}, the resolved type signature of the call </li>
+ * <li>optionally, a single object representing one or more <a href="#args">additional static arguments</a> </li>
  * </ul>
  * The method handle is then applied to the other values as if by
- * {@linkplain java.dyn.MethodHandle#invokeGeneric the <code>invokeGeneric</code> method}.
- * The returned result must be a {@link java.dyn.CallSite CallSite}, a {@link java.dyn.MethodHandle MethodHandle},
- * or another {@link java.dyn.MethodHandleProvider MethodHandleProvider} value.
- * The method {@linkplain java.dyn.MethodHandleProvider#asMethodHandle asMethodHandle}
- * is then called on the returned value.  The result of that second
- * call is the {@code MethodHandle} which becomes the
- * permanent binding for the dynamic call site.
- * That method handle's type must be exactly equal to the type
+ * {@link java.dyn.MethodHandle#invokeGeneric invokeGeneric}.
+ * The returned result must be a {@link java.dyn.CallSite CallSite} (or a subclass).
+ * The type of the call site's target must be exactly equal to the type
  * derived from the dynamic call site signature and passed to
  * the bootstrap method.
+ * The call site then becomes permanently linked to the dynamic call site.
+ * <p>
+ * As long as each bootstrap method can be correctly invoked
+ * by <code>invokeGeneric</code>, its detailed type is arbitrary.
+ * For example, the first argument could be {@code Object}
+ * instead of {@code MethodHandles.Lookup}, and the return type
+ * could also be {@code Object} instead of {@code CallSite}.
+ * <p>
+ * As with any method handle constant, a {@code varargs} modifier bit
+ * on the bootstrap method is ignored.
+ * <p>
+ * Note that the first argument of the bootstrap method cannot be
+ * a simple {@code Class} reference.  (This is a change from earlier
+ * versions of this specification.  If the caller class is needed,
+ * it is easy to {@linkplain java.dyn.MethodHandles.Lookup#lookupClass() extract it}
+ * from the {@code Lookup} object.
  * <p>
  * After resolution, the linkage process may fail in a variety of ways.
  * All failures are reported by an {@link java.dyn.InvokeDynamicBootstrapError InvokeDynamicBootstrapError},
@@ -206,13 +248,14 @@
  * site execution.
  * The following circumstances will cause this:
  * <ul>
+ * <li>the bootstrap method cannot be resolved </li>
+ * <li>the bootstrap method has the wrong arity,
+ *     causing {@code invokeGeneric} to throw {@code WrongMethodTypeException} </li>
+ * <li>the bootstrap method has a wrong argument or return type </li>
  * <li>the bootstrap method invocation completes abnormally </li>
  * <li>the result from the bootstrap invocation is not a reference to
- *     an object of type {@link java.dyn.MethodHandleProvider MethodHandleProvider} </li>
- * <li>the call to {@code asMethodHandle} completes abnormally </li>
- * <li>the call to {@code asMethodHandle} fails to return a reference to
- *     an object of type {@link java.dyn.MethodHandle MethodHandle} </li>
- * <li>the method handle produced by {@code asMethodHandle} does not have
+ *     an object of type {@link java.dyn.CallSite CallSite} </li>
+ * <li>the target of the {@code CallSite} does not have a target of
  *     the expected {@code MethodType} </li>
  * </ul>
  * <h3>timing of linkage</h3>
@@ -220,67 +263,119 @@
  * The bootstrap method call implementing the linkage occurs within
  * a thread that is attempting a first execution.
  * <p>
- * If there are several such threads, the JVM picks one thread
- * and runs the bootstrap method while the others wait for the
- * invocation to terminate normally or abnormally.
- * <p>
- * After a bootstrap method is called and a method handle target
- * successfully extracted, the JVM attempts to link the instruction
- * being executed to the target method handle.
- * This may fail if there has been intervening linkage
- * or invalidation event for the same instruction.
- * If such a failure occurs, the dynamic call site must be
- * re-executed from the beginning, either re-linking it
- * (if it has been invalidated) or invoking the target
- * (if it the instruction has been linked by some other means).
- * <p>
- * If the instruction is linked successfully, the target method
- * handle is invoked to complete the instruction execution.
- * The state of linkage continues until the method containing the
- * dynamic call site is garbage collected, or the dynamic call site
- * is invalidated by an explicit request,
- * such as {@link java.dyn.Linkage#invalidateCallerClass Linkage.invalidateCallerClass}.
+ * If there are several such threads, the bootstrap method may be
+ * invoked in several threads concurrently.
+ * Therefore, bootstrap methods which access global application
+ * data must take the usual precautions against race conditions.
+ * In any case, every {@code invokedynamic} instruction is either
+ * unlinked or linked to a unique {@code CallSite} object.
  * <p>
  * In an application which requires dynamic call sites with individually
  * mutable behaviors, their bootstrap methods should produce distinct
  * {@link java.dyn.CallSite CallSite} objects, one for each linkage request.
- * <p>
- * If a class containing {@code invokedynamic} instructions
- * is {@linkplain java.dyn.Linkage#invalidateCallerClass(Class) invalidated},
- * subsequent execution of those {@code invokedynamic} instructions
- * will require linking.
- * It is as if they had never been executed in the first place.
- * (However, invalidation does not cause constant pool entries to be
- * resolved a second time.)
- * <p>
- * Invalidation events and bootstrap method calls for a particular
- * dynamic call site are globally ordered relative to each other.
- * When an invokedynamic instruction is invalidated, if there is
- * simultaneously a bootstrap method invocation in process
- * (in the same thread or a different thread), the result
- * eventually returned must not be used to link the call site.
- * Put another way, when a call site is invalidated, its
- * subsequent linkage (if any) must be performed by a bootstrap method
- * call initiated after the invalidation occurred.
+ * Alternatively, an application can link a single {@code CallSite} object
+ * to several {@code invokedynamic} instructions, in which case
+ * a change to the target method will become visible at each of
+ * the instructions.
  * <p>
  * If several threads simultaneously execute a bootstrap method for a single dynamic
- * call site, the JVM must choose one target object and installs it visibly to
+ * call site, the JVM must choose one {@code CallSite} object and install it visibly to
  * all threads.  Any other bootstrap method calls are allowed to complete, but their
  * results are ignored, and their dynamic call site invocations proceed with the originally
  * chosen target object.
  * <p>
- * The JVM is free to duplicate dynamic call sites.
- * This means that, even if a class contains just one {@code invokedynamic}
- * instruction, its bootstrap method may be executed several times,
- * once for each duplicate.  Thus, bootstrap method code should not
- * assume an exclusive one-to-one correspondence between particular occurrences
- * of {@code invokedynamic} bytecodes in class files and linkage events.
+ * <em>Note: Unlike some previous versions of this specification,
+ * these rules do not enable the JVM to duplicate dynamic call sites,
+ * or to issue &ldquo;causeless&rdquo; bootstrap method calls.
+ * Every dynamic call site transitions at most once from unlinked to linked,
+ * just before its first invocation.</em>
+ *
+ * <h3><a name="args">static arguments to the bootstrap method</h3>
+ * <em>PROVISIONAL API, WORK IN PROGRESS:</em>
+ * An {@code invokedynamic} instruction specifies at least three arguments
+ * to pass to its bootstrap method:
+ * The caller class (expressed as a {@link java.dyn.MethodHandles.Lookup Lookup object},
+ * the name (extracted from the {@code CONSTANT_NameAndType} entry),
+ * and the type (also extracted from the {@code CONSTANT_NameAndType} entry).
+ * The {@code invokedynamic} instruction may specify additional metadata values
+ * to pass to its bootstrap method.
+ * Collectively, these values are called <em>static arguments</em> to the
+ * {@code invokedynamic} instruction, because they are used once at link
+ * time to determine the instruction's behavior on subsequent sets of
+ * <em>dynamic arguments</em>.
  * <p>
- * In principle, each individual execution of an {@code invokedynamic}
- * instruction could be deemed (by a conforming implementation) to be a separate
- * duplicate, requiring its own execution of the bootstrap method.
- * However, implementations are expected to perform code duplication
- * (if at all) in order to improve performance, not make it worse.
+ * Static arguments are used to communicate application-specific meta-data
+ * to the bootstrap method.
+ * Drawn from the constant pool, they may include references to classes, method handles,
+ * or numeric data that may be relevant to the task of linking that particular call site.
+ * <p>
+ * The third byte pair in a {@code CONSTANT_InvokeDynamic} entry, if it is not zero,
+ * counts up to 65535 additional constant pool indexes which contribute to a static argument.
+ * Each of these indexes must refer to one of a type of constant entry which is compatible with
+ * the {@code ldc} instruction.
+ * Before the bootstrap method is invoked, each index is used to compute an {@code Object}
+ * reference to the indexed value in the constant pool.
+ * If the value is a primitive type, it is converted to a reference by boxing conversion.
+ * The valid constant pool entries are listed in this table:
+ * <code>
+ * <table border=1 cellpadding=5 summary="Static argument types">
+ * <tr><th>entry type</th><th>argument type</th><th>argument value</th></tr>
+ * <tr><td>CONSTANT_String</td><td><code>java.lang.String</code></td><td>the indexed string literal</td></tr>
+ * <tr><td>CONSTANT_Class</td><td><code>java.lang.Class</code></td><td>the indexed class, resolved</td></tr>
+ * <tr><td>CONSTANT_Integer</td><td><code>java.lang.Integer</code></td><td>the indexed int value</td></tr>
+ * <tr><td>CONSTANT_Long</td><td><code>java.lang.Long</code></td><td>the indexed long value</td></tr>
+ * <tr><td>CONSTANT_Float</td><td><code>java.lang.Float</code></td><td>the indexed float value</td></tr>
+ * <tr><td>CONSTANT_Double</td><td><code>java.lang.Double</code></td><td>the indexed double value</td></tr>
+ * <tr><td>CONSTANT_MethodHandle</td><td><code>java.dyn.MethodHandle</code></td><td>the indexed method handle constant</td></tr>
+ * <tr><td>CONSTANT_MethodType</td><td><code>java.dyn.MethodType</code></td><td>the indexed method type constant</td></tr>
+ * </table>
+ * </code>
+ * <p>
+ * If a given {@code invokedynamic} instruction specifies no static arguments,
+ * the instruction's bootstrap method will be invoked on three arguments,
+ * conveying the instruction's caller class, name, and method type.
+ * If the {@code invokedynamic} instruction specifies one or more static arguments,
+ * a fourth argument will be passed to the bootstrap argument,
+ * either an {@code Object} reference to the sole extra argument (if there is one)
+ * or an {@code Object} array of references to all the arguments (if there are two or more),
+ * as if the bootstrap method is a variable-arity method.
+ * <code>
+ * <table border=1 cellpadding=5 summary="Static argument types">
+ * <tr><th>N</th><th>sample bootstrap method</th></tr>
+ * <tr><td>0</td><td><code>CallSite bootstrap(Lookup caller, String name, MethodType type)</code></td></tr>
+ * <tr><td>1</td><td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object arg)</code></td></tr>
+ * <tr><td>2</td><td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args)</code></td></tr>
+ * </table>
+ * </code>
+ * <p>
+ * The argument and return types listed here are used by the {@code invokeGeneric}
+ * call to the bootstrap method.
+ * As noted above, the actual method type of the bootstrap method can vary.
+ * For example, the fourth argument could be {@code MethodHandle},
+ * if that is the type of the corresponding constant in
+ * the {@code CONSTANT_InvokeDynamic} entry.
+ * In that case, the {@code invokeGeneric} call will pass the extra method handle
+ * constant as an {@code Object}, but the type matching machinery of {@code invokeGeneric}
+ * will cast the reference back to {@code MethodHandle} before invoking the bootstrap method.
+ * (If a string constant were passed instead, by badly generated code, that cast would then fail.)
+ * <p>
+ * If the fourth argument is an array, the array element type must be {@code Object},
+ * since object arrays (as produced by the JVM at this point) cannot be converted
+ * to other array types.
+ * <p>
+ * If an array is provided, it will appear to be freshly allocated.
+ * That is, the same array will not appear to two bootstrap method calls.
+ * <p>
+ * Extra bootstrap method arguments are intended to allow language implementors
+ * to safely and compactly encode metadata.
+ * In principle, the name and extra arguments are redundant,
+ * since each call site could be given its own unique bootstrap method.
+ * Such a practice is likely to produce large class files and constant pools.
+ * <p>
+ * <em>The Proposed Final Draft of JSR 292 may remove extra static arguments,
+ * with the associated constant tag of 18, leaving the constant tag 17.
+ * If the constant tag of 18 is retained, the constant tag 17 may be removed
+ * for the sake of simplicity.</em>
  *
  * @author John Rose, JSR 292 EG
  */
diff --git a/src/share/classes/sun/dyn/AdapterMethodHandle.java b/src/share/classes/sun/dyn/AdapterMethodHandle.java
--- a/src/share/classes/sun/dyn/AdapterMethodHandle.java
+++ b/src/share/classes/sun/dyn/AdapterMethodHandle.java
@@ -487,7 +487,7 @@
     static class WithTypeHandler extends AdapterMethodHandle {
         final MethodHandle target, typeHandler;
         WithTypeHandler(MethodHandle target, MethodHandle typeHandler) {
-            super(target, target.type(), OP_RETYPE_ONLY);
+            super(target, target.type(), makeConv(OP_RETYPE_ONLY));
             this.target = target;
             this.typeHandler = typeHandler.asType(TYPE_HANDLER_TYPE);
         }
diff --git a/src/share/classes/sun/dyn/BoundMethodHandle.java b/src/share/classes/sun/dyn/BoundMethodHandle.java
--- a/src/share/classes/sun/dyn/BoundMethodHandle.java
+++ b/src/share/classes/sun/dyn/BoundMethodHandle.java
@@ -106,18 +106,17 @@
         assert(this instanceof AdapterMethodHandle);
     }
 
-    /** Initialize the current object as a Java method handle, binding it
+    /** Initialize the current object as a self-bound method handle, binding it
      *  as the first argument of the method handle {@code entryPoint}.
      *  The invocation type of the resulting method handle will be the
      *  same as {@code entryPoint},  except that the first argument
      *  type will be dropped.
      */
-    protected BoundMethodHandle(MethodHandle entryPoint) {
-        super(Access.TOKEN, entryPoint.type().dropParameterTypes(0, 1));
+    protected BoundMethodHandle(Access token, MethodHandle entryPoint) {
+        super(token, entryPoint.type().dropParameterTypes(0, 1));
         this.argument = this; // kludge; get rid of
         this.vmargslot = this.type().parameterSlotDepth(0);
         initTarget(entryPoint, 0);
-        assert(this instanceof JavaMethodHandle);
     }
 
     /** Make sure the given {@code argument} can be used as {@code argnum}-th
@@ -173,6 +172,11 @@
 
     @Override
     public String toString() {
+        return MethodHandleImpl.addTypeString(baseName(), this);
+    }
+
+    /** Component of toString() before the type string. */
+    protected String baseName() {
         MethodHandle mh = this;
         while (mh instanceof BoundMethodHandle) {
             Object info = MethodHandleNatives.getTargetInfo(mh);
@@ -185,12 +189,16 @@
                 if (name != null)
                     return name;
                 else
-                    return super.toString(); // <unknown>, probably
+                    return noParens(super.toString()); // "invoke", probably
             }
             assert(mh != this);
-            if (mh instanceof JavaMethodHandle)
-                break;  // access JMH.toString(), not BMH.toString()
         }
-        return mh.toString();
+        return noParens(mh.toString());
+    }
+
+    private static String noParens(String str) {
+        int paren = str.indexOf('(');
+        if (paren >= 0) str = str.substring(0, paren);
+        return str;
     }
 }
diff --git a/src/share/classes/sun/dyn/CallSiteImpl.java b/src/share/classes/sun/dyn/CallSiteImpl.java
--- a/src/share/classes/sun/dyn/CallSiteImpl.java
+++ b/src/share/classes/sun/dyn/CallSiteImpl.java
@@ -41,25 +41,39 @@
                              Object info,
                              // Caller information:
                              MemberName callerMethod, int callerBCI) {
-        Class<?> caller = callerMethod.getDeclaringClass();
+        Class<?> callerClass = callerMethod.getDeclaringClass();
+        Object caller;
+        if (bootstrapMethod.type().parameterType(0) == Class.class)
+            caller = callerClass;  // remove for PFD
+        else
+            caller = MethodHandleImpl.IMPL_LOOKUP.in(callerClass);
         if (bootstrapMethod == null) {
             // If there is no bootstrap method, throw IncompatibleClassChangeError.
             // This is a valid generic error type for resolution (JLS 12.3.3).
             throw new IncompatibleClassChangeError
-                ("Class "+caller.getName()+" has not declared a bootstrap method for invokedynamic");
+                ("Class "+callerClass.getName()+" has not declared a bootstrap method for invokedynamic");
         }
         CallSite site;
         try {
             Object binding;
-            if (false)  // switch when invokeGeneric works
-                binding = bootstrapMethod.invokeGeneric(caller, name, type);
-            else
-                binding = bootstrapMethod.invokeVarargs(new Object[]{ caller, name, type });
+            if (info == null) {
+                if (false)  // switch when invokeGeneric works
+                    binding = bootstrapMethod.invokeGeneric(caller, name, type);
+                else
+                    binding = bootstrapMethod.invokeVarargs(new Object[]{ caller, name, type });
+            } else {
+                info = maybeReBox(info);
+                if (false)  // switch when invokeGeneric works
+                    binding = bootstrapMethod.invokeGeneric(caller, name, type, info);
+                else
+                    binding = bootstrapMethod.invokeVarargs(new Object[]{ caller, name, type, info });
+            }
             //System.out.println("BSM for "+name+type+" => "+binding);
             if (binding instanceof CallSite) {
                 site = (CallSite) binding;
-            } else if (binding instanceof MethodHandleProvider) {
-                MethodHandle target = ((MethodHandleProvider) binding).asMethodHandle();
+            } else if (binding instanceof MethodHandle) {
+                // Transitional!
+                MethodHandle target = (MethodHandle) binding;
                 site = new ConstantCallSite(target);
             } else {
                 throw new ClassCastException("bootstrap method failed to produce a MethodHandle or CallSite");
@@ -79,6 +93,24 @@
         return site;
     }
 
+    private static Object maybeReBox(Object x) {
+        if (x instanceof Integer) {
+            int xi = (int) x;
+            if (xi == (byte) xi)
+                x = xi;  // must rebox; see JLS 5.1.7
+            return x;
+        } else if (x instanceof Object[]) {
+            Object[] xa = (Object[]) x;
+            for (int i = 0; i < xa.length; i++) {
+                if (xa[i] instanceof Integer)
+                    xa[i] = maybeReBox(xa[i]);
+            }
+            return xa;
+        } else {
+            return x;
+        }
+    }
+
     // This method is private in CallSite because it touches private fields in CallSite.
     // These private fields (vmmethod, vmindex) are specific to the JVM.
     private static final MethodHandle PRIVATE_INITIALIZE_CALL_SITE;
diff --git a/src/share/classes/sun/dyn/FilterGeneric.java b/src/share/classes/sun/dyn/FilterGeneric.java
--- a/src/share/classes/sun/dyn/FilterGeneric.java
+++ b/src/share/classes/sun/dyn/FilterGeneric.java
@@ -115,7 +115,7 @@
 
     static MethodHandle make(Kind kind, int pos, MethodHandle filter, MethodHandle target) {
         FilterGeneric fgen = of(kind, pos, filter.type(), target.type());
-        return fgen.makeInstance(kind, pos, filter, target).asMethodHandle();
+        return fgen.makeInstance(kind, pos, filter, target);
     }
 
     /** Return the adapter information for this target and filter type. */
@@ -225,13 +225,13 @@
      * The invoker is kept separate from the target because it can be
      * generated once per type erasure family, and reused across adapters.
      */
-    static abstract class Adapter extends JavaMethodHandle {
+    static abstract class Adapter extends BoundMethodHandle {
         protected final MethodHandle filter; // transforms one or more arguments
         protected final MethodHandle target; // ultimate target
 
         @Override
         public String toString() {
-            return target.toString();
+            return MethodHandleImpl.addTypeString(target, this);
         }
 
         protected boolean isPrototype() { return target == null; }
@@ -246,7 +246,7 @@
 
         protected Adapter(MethodHandle entryPoint,
                           MethodHandle filter, MethodHandle target) {
-            super(entryPoint);
+            super(Access.TOKEN, entryPoint);
             this.filter = filter;
             this.target = target;
         }
diff --git a/src/share/classes/sun/dyn/FilterOneArgument.java b/src/share/classes/sun/dyn/FilterOneArgument.java
--- a/src/share/classes/sun/dyn/FilterOneArgument.java
+++ b/src/share/classes/sun/dyn/FilterOneArgument.java
@@ -36,7 +36,7 @@
  * final method type is the responsibility of a JVM-level adapter.
  * @author jrose
  */
-public class FilterOneArgument extends JavaMethodHandle {
+public class FilterOneArgument extends BoundMethodHandle {
     protected final MethodHandle filter;  // Object -> Object
     protected final MethodHandle target;  // Object -> Object
 
@@ -62,7 +62,7 @@
     }
 
     protected FilterOneArgument(MethodHandle filter, MethodHandle target) {
-        super(INVOKE);
+        super(Access.TOKEN, INVOKE);
         this.filter = filter;
         this.target = target;
     }
diff --git a/src/share/classes/sun/dyn/FromGeneric.java b/src/share/classes/sun/dyn/FromGeneric.java
--- a/src/share/classes/sun/dyn/FromGeneric.java
+++ b/src/share/classes/sun/dyn/FromGeneric.java
@@ -241,7 +241,7 @@
      * The invoker is kept separate from the target because it can be
      * generated once per type erasure family, and reused across adapters.
      */
-    static abstract class Adapter extends JavaMethodHandle {
+    static abstract class Adapter extends BoundMethodHandle {
         /*
          * class X<<R,int N>> extends Adapter {
          *   (MH, Object**N)=>raw(R) invoker;
@@ -256,7 +256,7 @@
 
         @Override
         public String toString() {
-            return target.toString();
+            return MethodHandleImpl.addTypeString(target, this);
         }
 
         protected boolean isPrototype() { return target == null; }
@@ -271,7 +271,7 @@
 
         protected Adapter(MethodHandle entryPoint,
                           MethodHandle invoker, MethodHandle convert, MethodHandle target) {
-            super(entryPoint);
+            super(Access.TOKEN, entryPoint);
             this.invoker = invoker;
             this.convert = convert;
             this.target  = target;
diff --git a/src/share/classes/sun/dyn/Invokers.java b/src/share/classes/sun/dyn/Invokers.java
--- a/src/share/classes/sun/dyn/Invokers.java
+++ b/src/share/classes/sun/dyn/Invokers.java
@@ -26,6 +26,7 @@
 package sun.dyn;
 
 import java.dyn.*;
+import sun.dyn.empty.Empty;
 
 /**
  * Construction and caching of often-used invokers.
@@ -48,6 +49,9 @@
     // generic (untyped) invoker for the outgoing call; accepts a single Object[]
     private final /*lazy*/ MethodHandle[] varargsInvokers;
 
+    // invoker for an unbound callsite
+    private /*lazy*/ MethodHandle uninitializedCallSite;
+
     /** Compute and cache information common to all collecting adapters
      *  that implement members of the erasure-family of the given erased type.
      */
@@ -107,6 +111,35 @@
         return vaInvoker;
     }
 
+    private static MethodHandle THROW_UCS = null;
+
+    public MethodHandle uninitializedCallSite() {
+        MethodHandle invoker = uninitializedCallSite;
+        if (invoker != null)  return invoker;
+        if (targetType.parameterCount() > 0) {
+            MethodType type0 = targetType.dropParameterTypes(0, targetType.parameterCount());
+            Invokers invokers0 = MethodTypeImpl.invokers(Access.TOKEN, type0);
+            invoker = MethodHandles.dropArguments(invokers0.uninitializedCallSite(),
+                                                  0, targetType.parameterList());
+            assert(invoker.type().equals(targetType));
+            uninitializedCallSite = invoker;
+            return invoker;
+        }
+        if (THROW_UCS == null) {
+            try {
+                THROW_UCS = MethodHandleImpl.IMPL_LOOKUP
+                    .findStatic(CallSite.class, "uninitializedCallSite",
+                                MethodType.methodType(Empty.class));
+            } catch (NoAccessException ex) {
+                throw new RuntimeException(ex);
+            }
+        }
+        invoker = AdapterMethodHandle.makeRetypeRaw(Access.TOKEN, targetType, THROW_UCS);
+        assert(invoker.type().equals(targetType));
+        uninitializedCallSite = invoker;
+        return invoker;
+    }
+
     public String toString() {
         return "Invokers"+targetType;
     }
diff --git a/src/share/classes/sun/dyn/JavaMethodHandle.java b/src/share/classes/sun/dyn/JavaMethodHandle.java
deleted file mode 100644
--- a/src/share/classes/sun/dyn/JavaMethodHandle.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.dyn;
-
-import java.dyn.*;
-import sun.dyn.Access;
-
-/**
- * A Java method handle is a deprecated proposal for extending
- * the basic method handle type with additional
- * programmer defined methods and fields.
- * Its behavior as a method handle is determined at instance creation time,
- * by providing the new instance with an "entry point" method handle
- * to handle calls.  This entry point must accept a leading argument
- * whose type is the Java method handle itself or a supertype, and the
- * entry point is always called with the Java method handle itself as
- * the first argument.  This is similar to ordinary virtual methods, which also
- * accept the receiver object {@code this} as an implicit leading argument.
- * The {@code MethodType} of the Java method handle is the same as that
- * of the entry point method handle, with the leading parameter type
- * omitted.
- * <p>
- * Here is an example of usage, creating a hybrid object/functional datum:
- * <p><blockquote><pre>
- * class Greeter extends JavaMethodHandle {
- *     private String greeting = "hello";
- *     public void setGreeting(String s) { greeting = s; }
- *     public void run() { System.out.println(greeting+", "+greetee); }
- *     private final String greetee;
- *     Greeter(String greetee) {
- *         super(RUN); // alternatively, super("run")
- *         this.greetee = greetee;
- *     }
- *     // the entry point function is computed once:
- *     private static final MethodHandle RUN
- *         = MethodHandles.lookup().findVirtual(Greeter.class, "run",
- *               MethodType.make(void.class));
- * }
- * // class Main { public static void main(String... av) { ...
- * Greeter greeter = new Greeter("world");
- * greeter.run();  // prints "hello, world"
- * // Statically typed method handle invocation (most direct):
- * MethodHandle mh = greeter;
- * mh.&lt;void&gt;invokeExact();  // also prints "hello, world"
- * // Dynamically typed method handle invocation:
- * MethodHandles.invokeExact(greeter);  // also prints "hello, world"
- * greeter.setGreeting("howdy");
- * mh.invokeExact();  // prints "howdy, world" (object-like mutable behavior)
- * </pre></blockquote>
- * <p>
- * In the example of {@code Greeter}, the method {@code run} provides the entry point.
- * The entry point need not be a constant value; it may be independently
- * computed in each call to the constructor.  The entry point does not
- * even need to be a method on the {@code Greeter} class, though
- * that is the typical case.
- * <p>
- * The entry point may also be provided symbolically, in which case the the
- * {@code JavaMethodHandle} constructor performs the lookup of the entry point.
- * This makes it possible to use {@code JavaMethodHandle} to create an anonymous
- * inner class:
- * <p><blockquote><pre>
- * // We can also do this with symbolic names and/or inner classes:
- * MethodHandles.invokeExact(new JavaMethodHandle("yow") {
- *     void yow() { System.out.println("yow, world"); }
- * });
- * </pre></blockquote>
- * <p>
- * Here is similar lower-level code which works in terms of a bound method handle.
- * <p><blockquote><pre>
- *     class Greeter {
- *         public void run() { System.out.println("hello, "+greetee); }
- *         private final String greetee;
- *         Greeter(String greetee) { this.greetee = greetee; }
- *         // the entry point function is computed once:
- *         private static final MethodHandle RUN
- *             = MethodHandles.findVirtual(Greeter.class, "run",
- *                   MethodType.make(void.class));
- *     }
- *     // class Main { public static void main(String... av) { ...
- *     Greeter greeter = new Greeter("world");
- *     greeter.run();  // prints "hello, world"
- *     MethodHandle mh = MethodHanndles.insertArgument(Greeter.RUN, 0, greeter);
- *     mh.invokeExact();  // also prints "hello, world"
- * </pre></blockquote>
- * Note that the method handle must be separately created as a view on the base object.
- * This increases footprint, complexity, and dynamic indirections.
- * <p>
- * Here is a pure functional value expressed most concisely as an anonymous inner class:
- * <p><blockquote><pre>
- *     // class Main { public static void main(String... av) { ...
- *     final String greetee = "world";
- *     MethodHandle greeter = new JavaMethodHandle("run") {
- *         private void run() { System.out.println("hello, "+greetee); }
- *     }
- *     greeter.invokeExact();  // prints "hello, world"
- * </pre></blockquote>
- * <p>
- * Here is an abstract parameterized lvalue, efficiently expressed as a subtype of MethodHandle,
- * and instantiated as an anonymous class.  The data structure is a handle to 1-D array,
- * with a specialized index type (long).  It is created by inner class, and uses
- * signature-polymorphic APIs throughout.
- * <p><blockquote><pre>
- *     abstract class AssignableMethodHandle extends JavaMethodHandle {
- *       private final MethodHandle setter;
- *       public MethodHandle setter() { return setter; }
- *       public AssignableMethodHandle(String get, String set) {
- *         super(get);
- *         MethodType getType = this.type();
- *         MethodType setType = getType.insertParameterType(getType.parameterCount(), getType.returnType()).changeReturnType(void.class);
- *         this.setter = MethodHandles.publicLookup().bind(this, set, setType);
- *       }
- *     }
- *     // class Main { public static void main(String... av) { ...
- *     final Number[] stuff = { 123, 456 };
- *     AssignableMethodHandle stuffPtr = new AssignableMethodHandle("get", "set") {
- *         public Number get(long i)           { return stuff[(int)i]; }
- *         public void   set(long i, Object x) {        stuff[(int)i] = x; }
- *     }
- *     int x = (Integer) stuffPtr.&lt;Number&gt;invokeExact(1L);  // 456
- *     stuffPtr.setter().&lt;void&gt;invokeExact(0L, (Number) 789);  // replaces 123 with 789
- * </pre></blockquote>
- * @see MethodHandle
- * @deprecated The JSR 292 EG intends to replace {@code JavaMethodHandle} with
- * an interface-based API for mixing method handle behavior with other classes.
- * @author John Rose, JSR 292 EG
- */
-public abstract class JavaMethodHandle
-        // Note: This is an implementation inheritance hack, and will be removed
-        // with a JVM change which moves the required hidden behavior onto this class.
-        extends sun.dyn.BoundMethodHandle
-{
-    private static final Access IMPL_TOKEN = Access.getToken();
-
-    /**
-     * When creating a {@code JavaMethodHandle}, the actual method handle
-     * invocation behavior will be delegated to the specified {@code entryPoint}.
-     * This may be any method handle which can take the newly constructed object
-     * as a leading parameter.
-     * <p>
-     * The method handle type of {@code this} (i.e, the fully constructed object)
-     * will be {@code entryPoint}, minus the leading argument.
-     * The leading argument will be bound to {@code this} on every method
-     * handle invocation.
-     * @param entryPoint the method handle to handle calls
-     */
-    protected JavaMethodHandle(MethodHandle entryPoint) {
-        super(entryPoint);
-    }
-}
diff --git a/src/share/classes/sun/dyn/MethodHandleImpl.java b/src/share/classes/sun/dyn/MethodHandleImpl.java
--- a/src/share/classes/sun/dyn/MethodHandleImpl.java
+++ b/src/share/classes/sun/dyn/MethodHandleImpl.java
@@ -199,7 +199,7 @@
         return allocator;
     }
 
-    static final class AllocateObject<C> extends JavaMethodHandle {
+    static final class AllocateObject<C> extends BoundMethodHandle {
         private static final Unsafe unsafe = Unsafe.getUnsafe();
 
         private final Class<C> allocateClass;
@@ -207,7 +207,7 @@
 
         private AllocateObject(MethodHandle invoker,
                                Class<C> allocateClass, MethodHandle rawConstructor) {
-            super(invoker);
+            super(Access.TOKEN, invoker);
             this.allocateClass = allocateClass;
             this.rawConstructor = rawConstructor;
         }
@@ -237,7 +237,7 @@
         }
         @Override
         public String toString() {
-            return allocateClass.getSimpleName();
+            return addTypeString(allocateClass.getSimpleName(), this);
         }
         @SuppressWarnings("unchecked")
         private C allocate() throws InstantiationException {
@@ -369,19 +369,19 @@
         return mhs[isSetter ? 1 : 0];
     }
 
-    static final class FieldAccessor<C,V> extends JavaMethodHandle {
+    static final class FieldAccessor<C,V> extends BoundMethodHandle {
         private static final Unsafe unsafe = Unsafe.getUnsafe();
         final Object base;  // for static refs only
         final long offset;
         final String name;
 
         public FieldAccessor(Access token, MemberName field, boolean isSetter) {
-            super(fhandle(field.getDeclaringClass(), field.getFieldType(), isSetter, field.isStatic()));
+            super(Access.TOKEN, fhandle(field.getDeclaringClass(), field.getFieldType(), isSetter, field.isStatic()));
             this.offset = (long) field.getVMIndex(token);
             this.name = field.getName();
             this.base = staticBase(field);
         }
-        public String toString() { return name; }
+        public String toString() { return addTypeString(name, this); }
 
         int getFieldI(C obj) { return unsafe.getInt(obj, offset); }
         void setFieldI(C obj, int x) { unsafe.putInt(obj, offset, x); }
@@ -910,11 +910,11 @@
         throw new UnsupportedOperationException("NYI");
     }
 
-    private static class GuardWithTest extends JavaMethodHandle {
+    private static class GuardWithTest extends BoundMethodHandle {
         private final MethodHandle test, target, fallback;
         private GuardWithTest(MethodHandle invoker,
                               MethodHandle test, MethodHandle target, MethodHandle fallback) {
-            super(invoker);
+            super(Access.TOKEN, invoker);
             this.test = test;
             this.target = target;
             this.fallback = fallback;
@@ -948,7 +948,7 @@
         }
         @Override
         public String toString() {
-            return target.toString();
+            return addTypeString(target, this);
         }
         private Object invoke_V(Object... av) throws Throwable {
             if (test.<boolean>invokeExact(av))
@@ -1038,7 +1038,7 @@
         return GuardWithTest.make(token, test, target, fallback);
     }
 
-    private static class GuardWithCatch extends JavaMethodHandle {
+    private static class GuardWithCatch extends BoundMethodHandle {
         private final MethodHandle target;
         private final Class<? extends Throwable> exType;
         private final MethodHandle catcher;
@@ -1047,14 +1047,14 @@
         }
         public GuardWithCatch(MethodHandle invoker,
                               MethodHandle target, Class<? extends Throwable> exType, MethodHandle catcher) {
-            super(invoker);
+            super(Access.TOKEN, invoker);
             this.target = target;
             this.exType = exType;
             this.catcher = catcher;
         }
         @Override
         public String toString() {
-            return target.toString();
+            return addTypeString(target, this);
         }
         private Object invoke_V(Object... av) throws Throwable {
             try {
@@ -1219,21 +1219,24 @@
         if (target != null)
             name = MethodHandleNatives.getMethodName(target);
         if (name == null)
-            return "<unknown>";
-        return name.getName();
+            return "invoke" + target.type();
+        return name.getName() + target.type();
     }
 
-    public static String addTypeString(MethodHandle target) {
-        if (target == null)  return "null";
-        return target.toString() + target.type();
+    static String addTypeString(Object obj, MethodHandle target) {
+        String str = String.valueOf(obj);
+        if (target == null)  return str;
+        int paren = str.indexOf('(');
+        if (paren >= 0) str = str.substring(0, paren);
+        return str + target.type();
     }
 
-    public static void checkSpreadArgument(Object av, int n) {
+    static void checkSpreadArgument(Object av, int n) {
         if (av == null ? n != 0 : ((Object[])av).length != n)
             throw newIllegalArgumentException("Array is not of length "+n);
     }
 
-    public static void raiseException(int code, Object actual, Object required) {
+    static void raiseException(int code, Object actual, Object required) {
         String message;
         // disregard the identity of the actual object, if it is not a class:
         if (!(actual instanceof Class) && !(actual instanceof MethodType))
diff --git a/src/share/classes/sun/dyn/SpreadGeneric.java b/src/share/classes/sun/dyn/SpreadGeneric.java
--- a/src/share/classes/sun/dyn/SpreadGeneric.java
+++ b/src/share/classes/sun/dyn/SpreadGeneric.java
@@ -208,7 +208,7 @@
      * The invoker is kept separate from the target because it can be
      * generated once per type erasure family, and reused across adapters.
      */
-    static abstract class Adapter extends JavaMethodHandle {
+    static abstract class Adapter extends BoundMethodHandle {
         /*
          * class X<<R,int M,int N>> extends Adapter {
          *   (Object**N)=>R target;
@@ -221,21 +221,21 @@
 
         @Override
         public String toString() {
-            return target.toString();
+            return MethodHandleImpl.addTypeString(target, this);
         }
 
         static final MethodHandle NO_ENTRY = ValueConversions.identity();
 
         protected boolean isPrototype() { return target == null; }
         protected Adapter(SpreadGeneric outer) {
-            super(NO_ENTRY);
+            super(Access.TOKEN, NO_ENTRY);
             this.outer = outer;
             this.target = null;
             assert(isPrototype());
         }
 
         protected Adapter(SpreadGeneric outer, MethodHandle target) {
-            super(outer.entryPoint);
+            super(Access.TOKEN, outer.entryPoint);
             this.outer = outer;
             this.target = target;
         }
diff --git a/src/share/classes/sun/dyn/ToGeneric.java b/src/share/classes/sun/dyn/ToGeneric.java
--- a/src/share/classes/sun/dyn/ToGeneric.java
+++ b/src/share/classes/sun/dyn/ToGeneric.java
@@ -323,7 +323,7 @@
      * via another method handle {@code convert}, which is responsible for
      * converting the object result into the raw return value.
      */
-    static abstract class Adapter extends JavaMethodHandle {
+    static abstract class Adapter extends BoundMethodHandle {
         /*
          * class X<<R,A...>> extends Adapter {
          *   Object...=>Object target;
@@ -337,13 +337,13 @@
 
         @Override
         public String toString() {
-            return target == null ? "prototype:"+convert : target.toString();
+            return target == null ? "prototype:"+convert : MethodHandleImpl.addTypeString(target, this);
         }
 
         protected boolean isPrototype() { return target == null; }
         /* Prototype constructor. */
         protected Adapter(MethodHandle entryPoint) {
-            super(entryPoint);
+            super(Access.TOKEN, entryPoint);
             this.invoker = null;
             this.convert = entryPoint;
             this.target = null;
@@ -355,7 +355,7 @@
         }
 
         protected Adapter(MethodHandle entryPoint, MethodHandle invoker, MethodHandle convert, MethodHandle target) {
-            super(entryPoint);
+            super(Access.TOKEN, entryPoint);
             this.invoker = invoker;
             this.convert = convert;
             this.target = target;
diff --git a/src/share/classes/sun/dyn/util/ValueConversions.java b/src/share/classes/sun/dyn/util/ValueConversions.java
--- a/src/share/classes/sun/dyn/util/ValueConversions.java
+++ b/src/share/classes/sun/dyn/util/ValueConversions.java
@@ -649,7 +649,9 @@
             return mh;
         }
         // slow path
-        MethodType type = MethodType.methodType(wrap.primitiveType(), wrap.primitiveType());
+        MethodType type = MethodType.methodType(wrap.primitiveType());
+        if (wrap != Wrapper.VOID)
+            type = type.appendParameterTypes(wrap.primitiveType());
         try {
             mh = IMPL_LOOKUP.findStatic(ValueConversions.class, "identity", type);
         } catch (NoAccessException ex) {
@@ -677,7 +679,7 @@
     }
 
     private static MethodHandle retype(MethodType type, MethodHandle mh) {
-        return AdapterMethodHandle.makeRetypeOnly(IMPL_TOKEN, type, mh);
+        return AdapterMethodHandle.makeRetypeRaw(IMPL_TOKEN, type, mh);
     }
 
     private static final Object[] NO_ARGS_ARRAY = {};
diff --git a/src/share/classes/sun/dyn/util/VerifyAccess.java b/src/share/classes/sun/dyn/util/VerifyAccess.java
--- a/src/share/classes/sun/dyn/util/VerifyAccess.java
+++ b/src/share/classes/sun/dyn/util/VerifyAccess.java
@@ -25,7 +25,6 @@
 
 package sun.dyn.util;
 
-import java.dyn.LinkagePermission;
 import java.dyn.NoAccessException;
 import java.lang.reflect.Modifier;
 import sun.dyn.MemberName;
@@ -43,6 +42,7 @@
 
     private static final int PACKAGE_ONLY = 0;
     private static final int ALL_ACCESS_MODES = (PUBLIC|PRIVATE|PROTECTED|PACKAGE_ONLY);
+    private static final boolean ALLOW_NESTMATE_ACCESS = false;
 
     /**
      * Evaluate the JVM linkage rules for access to the given method
@@ -102,6 +102,8 @@
                 // a superclass of the lookup class.
             }
         }
+        if (defc == lookupClass)
+            return true;        // easy check; all self-access is OK
         switch (mods & ALL_ACCESS_MODES) {
         case PUBLIC:
             if (refc != defc)  return true;  // already checked above
@@ -112,7 +114,8 @@
             return isSamePackage(defc, lookupClass);
         case PRIVATE:
             // Loosened rules for privates follows access rules for inner classes.
-            return isSamePackageMember(defc, lookupClass);
+            return (ALLOW_NESTMATE_ACCESS &&
+                    isSamePackageMember(defc, lookupClass));
         default:
             throw new IllegalArgumentException("bad modifiers: "+Modifier.toString(mods));
         }
@@ -206,24 +209,4 @@
         }
         return false;
     }
-
-    /**
-     * Ensure the requesting class have privileges to perform invokedynamic
-     * linkage operations on subjectClass.  True if requestingClass is
-     * Access.class (meaning the request originates from the JVM) or if the
-     * classes are in the same package and have consistent class loaders.
-     * (The subject class loader must be identical with or be a child of
-     * the requesting class loader.)
-     * @param requestingClass
-     * @param subjectClass
-     */
-    public static void checkBootstrapPrivilege(Class requestingClass, Class subjectClass,
-                                               String permissionName) {
-        if (requestingClass == null)          return;
-        if (requestingClass == subjectClass)  return;
-        SecurityManager security = System.getSecurityManager();
-        if (security == null)  return;  // open season
-        if (isSamePackage(requestingClass, subjectClass))  return;
-        security.checkPermission(new LinkagePermission(permissionName, requestingClass));
-    }
 }
diff --git a/src/share/classes/sun/dyn/util/Wrapper.java b/src/share/classes/sun/dyn/util/Wrapper.java
--- a/src/share/classes/sun/dyn/util/Wrapper.java
+++ b/src/share/classes/sun/dyn/util/Wrapper.java
@@ -26,17 +26,19 @@
 package sun.dyn.util;
 
 public enum Wrapper {
-    INT(Integer.class, int.class, 'I', (Integer)(int)0, Format.signed(32)),
-    LONG(Long.class, long.class, 'J', (Long)(long)0, Format.signed(64)),
+    BOOLEAN(Boolean.class, boolean.class, 'Z', (Boolean)false, Format.unsigned(1)),
+    // These must be in the order defined for widening primitive conversions in JLS 5.1.2
     BYTE(Byte.class, byte.class, 'B', (Byte)(byte)0, Format.signed(8)),
     SHORT(Short.class, short.class, 'S', (Short)(short)0, Format.signed(16)),
     CHAR(Character.class, char.class, 'C', (Character)(char)0, Format.unsigned(16)),
-    BOOLEAN(Boolean.class, boolean.class, 'Z', (Boolean)false, Format.unsigned(1)),
+    INT(Integer.class, int.class, 'I', (Integer)(int)0, Format.signed(32)),
+    LONG(Long.class, long.class, 'J', (Long)(long)0, Format.signed(64)),
     FLOAT(Float.class, float.class, 'F', (Float)(float)0, Format.floating(32)),
     DOUBLE(Double.class, double.class, 'D', (Double)(double)0, Format.floating(64)),
-    VOID(Void.class, void.class, 'V', null, Format.other(0)),
     //NULL(Null.class, null.class, 'N', null, Format.other(1)),
     OBJECT(Object.class, Object.class, 'L', null, Format.other(1)),
+    // VOID must be the last type, since it is "assignable" from any other type:
+    VOID(Void.class, void.class, 'V', null, Format.other(0)),
     ;
 
     private final Class<?> wrapperType;
@@ -76,9 +78,11 @@
                    false);
             return kind | (size << SIZE_SHIFT) | (slots << SLOT_SHIFT);
         }
-        static int
+        static final int
                 INT      = SIGNED   | (32 << SIZE_SHIFT) | (1 << SLOT_SHIFT),
+                SHORT    = SIGNED   | (16 << SIZE_SHIFT) | (1 << SLOT_SHIFT),
                 BOOLEAN  = UNSIGNED | (1  << SIZE_SHIFT) | (1 << SLOT_SHIFT),
+                CHAR     = UNSIGNED | (16 << SIZE_SHIFT) | (1 << SLOT_SHIFT),
                 FLOAT    = FLOATING | (32 << SIZE_SHIFT) | (1 << SLOT_SHIFT),
                 VOID     = UNSIGNED | (0  << SIZE_SHIFT) | (0 << SLOT_SHIFT),
                 NUM_MASK = (-1) << SIZE_SHIFT;
@@ -111,6 +115,29 @@
     /** Is the wrapped type either float or double? */
     public boolean isFloating()    { return format >= Format.FLOAT; }
 
+    /** Does the JVM verifier allow a variable of this wrapper's
+     *  primitive type to be assigned from a value of the given wrapper's primitive type?
+     *  Cases:
+     *  <ul>
+     *  <li>unboxing followed by widening primitive conversion
+     *  <li>any type converted to {@code void}
+     *  <li>boxing conversion followed by widening reference conversion to {@code Object}
+     *  <li>conversion of {@code boolean} to any type
+     *  </ul>
+     */
+    public boolean isConvertibleFrom(Wrapper source) {
+        if (this == source)  return true;
+        if (this.compareTo(source) < 0) {
+            // At best, this is a narrowing conversion.
+            return false;
+        }
+        if ((this.format ^ source.format) == (Format.SHORT ^ Format.CHAR)) {
+            assert (this == SHORT && source == CHAR) || (this == CHAR && source == SHORT);
+            return false;
+        }
+        return true;
+    }
+
     /** Produce a zero value for the given wrapper type.
      *  This will be a numeric zero for a number or character,
      *  false for a boolean, and null for a reference or void.
@@ -122,10 +149,10 @@
     public Object zero() { return zero; }
 
     /** Produce a zero value for the given wrapper type T.
-     *  The optinoal argument must a type compatible with this wrapper.
+     *  The optional argument must a type compatible with this wrapper.
      *  Equivalent to {@code this.cast(this.zero(), type)}.
      */
-    public <T> T zero(Class<T> type) { return cast(zero, type); }
+    public <T> T zero(Class<T> type) { return convert(zero, type); }
 
 //    /** Produce a wrapper for the given wrapper or primitive type. */
 //    public static Wrapper valueOf(Class<?> type) {
@@ -264,7 +291,11 @@
                    exampleType.isInterface()) {
             return forceType(wrapperType, exampleType);
         }
-        throw new ClassCastException(exampleType + " not <:" + wrapperType);
+        throw newClassCastException(exampleType, primitiveType);
+    }
+
+    private static ClassCastException newClassCastException(Class<?> actual, Class<?> expected) {
+        return new ClassCastException(actual + " is not compatible with " + expected);
     }
 
     /** If {@code type} is a primitive type, return the corresponding
@@ -325,17 +356,55 @@
 //    }
 
     /** Cast a wrapped value to the given type, which may be either a primitive or wrapper type.
+     *  The given target type must be this wrapper's primitive or wrapper type.
+     *  If this wrapper is OBJECT, the target type may also be an interface, perform no runtime check.
      *  Performs standard primitive conversions, including truncation and float conversions.
      *  The given type must be compatible with this wrapper.  That is, it must either
      *  be the wrapper type (or a subtype, in the case of {@code OBJECT}) or else
      *  it must be the wrapper's primitive type.
+     *  Primitive conversions are only performed if the given type is itself a primitive.
      *  @throws ClassCastException if the given type is not compatible with this wrapper
      */
     public <T> T cast(Object x, Class<T> type) {
+        return convert(x, type, true);
+    }
+
+    /** Convert a wrapped value to the given type.
+     *  The given target type must be this wrapper's primitive or wrapper type.
+     *  This is equivalent to {@link #cast}, except that it refuses to perform
+     *  narrowing primitive conversions.
+     */
+    public <T> T convert(Object x, Class<T> type) {
+        return convert(x, type, false);
+    }
+
+    private <T> T convert(Object x, Class<T> type, boolean isCast) {
+        if (this == OBJECT) {
+            // If the target wrapper is OBJECT, just do a reference cast.
+            // If the target type is an interface, perform no runtime check.
+            // (This loophole is safe, and is allowed by the JVM verifier.)
+            // If the target type is a primitive, change it to a wrapper.
+            @SuppressWarnings("unchecked")
+            T result = (T) x;  // unchecked warning is expected here
+            return result;
+        }
         Class<T> wtype = wrapperType(type);
-        if (wtype.isInstance(x))
-            return wtype.cast(x);
-        return wtype.cast(wrap(x));
+        if (wtype.isInstance(x)) {
+            @SuppressWarnings("unchecked")
+            T result = (T) x;  // unchecked warning is expected here
+            return result;
+        }
+        Class<?> sourceType = x.getClass();  // throw NPE if x is null
+        if (!isCast) {
+            Wrapper source = findWrapperType(sourceType);
+            if (source == null || !this.isConvertibleFrom(source)) {
+                throw newClassCastException(wtype, sourceType);
+            }
+        }
+        @SuppressWarnings("unchecked")
+        T result = (T) wrap(x);  // unchecked warning is expected here
+        assert result.getClass() == wtype;
+        return result;
     }
 
     /** Cast a reference type to another reference type.
diff --git a/test/java/dyn/InvokeGenericTest.java b/test/java/dyn/InvokeGenericTest.java
--- a/test/java/dyn/InvokeGenericTest.java
+++ b/test/java/dyn/InvokeGenericTest.java
@@ -398,7 +398,7 @@
             case 4:
                 junk = target.invokeGeneric(args[0], args[1], args[2], args[3]); break;
             default:
-                junk = MethodHandles.invokeVarargs(target, args); break;
+                junk = target.invokeWithArguments(args); break;
             }
         } catch (WrongMethodTypeException ex) {
             return;
diff --git a/test/java/dyn/JavaDocExamples.java b/test/java/dyn/JavaDocExamplesTest.java
rename from test/java/dyn/JavaDocExamples.java
rename to test/java/dyn/JavaDocExamplesTest.java
--- a/test/java/dyn/JavaDocExamples.java
+++ b/test/java/dyn/JavaDocExamplesTest.java
@@ -25,18 +25,18 @@
 
 /* @test
  * @summary example code used in javadoc for java.dyn API
- * @compile -XDallowTransitionalJSR292=no JavaDocExamples.java
- * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableMethodHandles test.java.dyn.JavaDocExamples
+ * @compile -XDallowTransitionalJSR292=no JavaDocExamplesTest.java
+ * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableMethodHandles test.java.dyn.JavaDocExamplesTest
  */
 
 /*
 ---- To run outside jtreg:
 $ $JAVA7X_HOME/bin/javac -cp $JUNIT4_JAR -d /tmp/Classes \
-   $DAVINCI/sources/jdk/test/java/dyn/JavaDocExamples.java
+   $DAVINCI/sources/jdk/test/java/dyn/JavaDocExamplesTest.java
 $ $JAVA7X_HOME/bin/java   -cp $JUNIT4_JAR:/tmp/Classes \
    -XX:+UnlockExperimentalVMOptions -XX:+EnableMethodHandles \
-   -Dtest.java.dyn.JavaDocExamples.verbosity=1 \
-     test.java.dyn.JavaDocExamples
+   -Dtest.java.dyn.JavaDocExamplesTest.verbosity=1 \
+     test.java.dyn.JavaDocExamplesTest
 ----
 */
 
@@ -57,15 +57,15 @@
 /**
  * @author jrose
  */
-public class JavaDocExamples {
+public class JavaDocExamplesTest {
     /** Wrapper for running the JUnit tests in this module.
      *  Put JUnit on the classpath!
      */
     public static void main(String... ignore) {
-        org.junit.runner.JUnitCore.runClasses(JavaDocExamples.class);
+        org.junit.runner.JUnitCore.runClasses(JavaDocExamplesTest.class);
     }
     // How much output?
-    static int verbosity = Integer.getInteger("test.java.dyn.JavaDocExamples.verbosity", 0);
+    static int verbosity = Integer.getInteger("test.java.dyn.JavaDocExamplesTest.verbosity", 0);
 
 {}
 static final private Lookup LOOKUP = lookup();
@@ -120,9 +120,79 @@
             }}
     }
 
+    @Test public void testFilterArguments() throws Throwable {
+        {{
+{} /// JAVADOC
+MethodHandle cat = lookup().findVirtual(String.class,
+  "concat", methodType(String.class, String.class));
+cat = cat.asType(methodType(Object.class, String.class, String.class)); /*(String)*/
+MethodHandle upcase = lookup().findVirtual(String.class,
+  "toUpperCase", methodType(String.class));
+assertEquals("xy", /*(String)*/ cat.invokeExact("x", "y")); // xy
+MethodHandle f0 = filterArguments(cat, 0, upcase);
+assertEquals("Xy", /*(String)*/ f0.invokeExact("x", "y")); // Xy
+MethodHandle f1 = filterArguments(cat, 1, upcase);
+assertEquals("xY", /*(String)*/ f1.invokeExact("x", "y")); // xY
+MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
+assertEquals("XY", /*(String)*/ f2.invokeExact("x", "y")); // XY
+            }}
+    }
+
     static void assertEquals(Object exp, Object act) {
         if (verbosity > 0)
             System.out.println("result: "+act);
         Assert.assertEquals(exp, act);
     }
+
+    @Test public void testVolatileCallSite() throws Throwable {
+        {{
+{} /// JAVADOC
+MethodHandle strcat = MethodHandles.lookup()
+  .findVirtual(String.class, "concat", MethodType.methodType(String.class, String.class));
+MethodHandle trueCon  = MethodHandles.constant(boolean.class, true);
+MethodHandle falseCon = MethodHandles.constant(boolean.class, false);
+VolatileCallSite switcher = new VolatileCallSite(trueCon, falseCon);
+// following steps may be repeated to re-use the same switcher:
+MethodHandle worker1 = strcat;
+MethodHandle worker2 = MethodHandles.permuteArguments(strcat, strcat.type(), 1, 0);
+MethodHandle worker = MethodHandles.guardWithTest(switcher.dynamicInvoker(), worker1, worker2);
+System.out.println((String) worker.invokeExact("met", "hod"));  // method
+switcher.invalidate();
+System.out.println((String) worker.invokeExact("met", "hod"));  // hodmet
+            }}
+    }
+
+static MethodHandle asList;
+    @Test public void testWithTypeHandler() throws Throwable {
+        {{
+{} /// JAVADOC
+MethodHandle makeEmptyList = MethodHandles.constant(List.class, Arrays.asList());
+MethodHandle asList = lookup()
+  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class));
+
+JavaDocExamplesTest.asList = asList;
+/*
+static MethodHandle collectingTypeHandler(MethodHandle base, MethodType newType) {
+  return asList.asCollector(Object[].class, newType.parameterCount()).asType(newType);
 }
+*/
+
+MethodHandle collectingTypeHandler = lookup()
+  .findStatic(lookup().lookupClass(), "collectingTypeHandler",
+     methodType(MethodHandle.class, MethodHandle.class, MethodType.class));
+MethodHandle makeAnyList = makeEmptyList.withTypeHandler(collectingTypeHandler);
+
+System.out.println(makeAnyList.invokeGeneric());
+System.out.println(makeAnyList.invokeGeneric(1));
+System.out.println(makeAnyList.invokeGeneric("two", "too"));
+            }}
+    }
+
+static MethodHandle collectingTypeHandler(MethodHandle base, MethodType newType) {
+    //System.out.println("Converting "+asList+" to "+newType);
+    MethodHandle conv = asList.asCollector(Object[].class, newType.parameterCount()).asType(newType);
+    //System.out.println(" =>"+conv);
+    return conv;
+}
+
+}
diff --git a/test/java/dyn/MethodHandlesTest.java b/test/java/dyn/MethodHandlesTest.java
--- a/test/java/dyn/MethodHandlesTest.java
+++ b/test/java/dyn/MethodHandlesTest.java
@@ -62,7 +62,6 @@
     // lookups, without exercising the actual method handle.
     static boolean DO_MORE_CALLS = true;
 
-
     @Test
     public void testFirst() throws Throwable {
         verbosity += 9; try {
@@ -458,7 +457,7 @@
         Exception noAccess = null;
         try {
             if (verbosity >= 4)  System.out.println("lookup via "+lookup+" of "+defc+" "+name+type);
-            target = lookup.findStatic(defc, name, type);
+            target = lookup.in(defc).findStatic(defc, name, type);
         } catch (NoAccessException ex) {
             noAccess = ex;
         }
@@ -469,16 +468,22 @@
         assertEquals(positive ? "positive test" : "negative test erroneously passed", positive, target != null);
         if (!positive)  return; // negative test failed as expected
         assertEquals(type, target.type());
-        assertTrue(target.toString().contains(name));  // rough check
+        assertNameStringContains(target, name);
         if (!DO_MORE_CALLS && lookup != PRIVATE)  return;
         Object[] args = randomArgs(params);
         printCalled(target, name, args);
-        target.invokeVarargs(args);
+        target.invokeWithArguments(args);
         assertCalled(name, args);
         if (verbosity >= 1)
             System.out.print(':');
     }
 
+    // rough check of name string
+    static void assertNameStringContains(Object x, String s) {
+        if (x.toString().contains(s))  return;
+        assertEquals(s, x);
+    }
+
     @Test
     public void testFindVirtual() throws Throwable {
         if (CAN_SKIP_WORKING)  return;
@@ -522,7 +527,7 @@
         Exception noAccess = null;
         try {
             if (verbosity >= 4)  System.out.println("lookup via "+lookup+" of "+defc+" "+name+type);
-            target = lookup.findVirtual(defc, methodName, type);
+            target = lookup.in(defc).findVirtual(defc, methodName, type);
         } catch (NoAccessException ex) {
             noAccess = ex;
         }
@@ -535,12 +540,12 @@
         Class<?>[] paramsWithSelf = cat(array(Class[].class, (Class)defc), params);
         MethodType typeWithSelf = MethodType.methodType(ret, paramsWithSelf);
         assertEquals(typeWithSelf, target.type());
-        assertTrue(target.toString().contains(methodName));  // rough check
+        assertNameStringContains(target, methodName);
         if (!DO_MORE_CALLS && lookup != PRIVATE)  return;
         Object[] argsWithSelf = randomArgs(paramsWithSelf);
         if (rcvc != defc)  argsWithSelf[0] = randomArg(rcvc);
         printCalled(target, name, argsWithSelf);
-        target.invokeVarargs(argsWithSelf);
+        target.invokeWithArguments(argsWithSelf);
         assertCalled(name, argsWithSelf);
         if (verbosity >= 1)
             System.out.print(':');
@@ -576,7 +581,8 @@
         Exception noAccess = null;
         try {
             if (verbosity >= 4)  System.out.println("lookup via "+lookup+" of "+defc+" "+name+type);
-            target = lookup.findSpecial(defc, name, type, specialCaller);
+            if (verbosity >= 5)  System.out.println("  lookup => "+lookup.in(specialCaller));
+            target = lookup.in(specialCaller).findSpecial(defc, name, type, specialCaller);
         } catch (NoAccessException ex) {
             noAccess = ex;
         }
@@ -591,11 +597,11 @@
         assertEquals(type,          target.type().dropParameterTypes(0,1));
         Class<?>[] paramsWithSelf = cat(array(Class[].class, (Class)specialCaller), params);
         MethodType typeWithSelf = MethodType.methodType(ret, paramsWithSelf);
-        assertTrue(target.toString().contains(name));  // rough check
+        assertNameStringContains(target, name);
         if (!DO_MORE_CALLS && lookup != PRIVATE && lookup != EXAMPLE)  return;
         Object[] args = randomArgs(paramsWithSelf);
         printCalled(target, name, args);
-        target.invokeVarargs(args);
+        target.invokeWithArguments(args);
         assertCalled(name, args);
     }
 
@@ -632,7 +638,7 @@
         Exception noAccess = null;
         try {
             if (verbosity >= 4)  System.out.println("lookup via "+lookup+" of "+defc+" "+name+type);
-            target = lookup.bind(receiver, methodName, type);
+            target = lookup.in(defc).bind(receiver, methodName, type);
         } catch (NoAccessException ex) {
             noAccess = ex;
         }
@@ -645,7 +651,7 @@
         assertEquals(type, target.type());
         Object[] args = randomArgs(params);
         printCalled(target, name, args);
-        target.invokeVarargs(args);
+        target.invokeWithArguments(args);
         Object[] argsWithReceiver = cat(array(Object[].class, receiver), args);
         assertCalled(name, argsWithReceiver);
         if (verbosity >= 1)
@@ -705,9 +711,9 @@
         try {
             if (verbosity >= 4)  System.out.println("lookup via "+lookup+" of "+defc+" "+name+type);
             if (isSpecial)
-                target = lookup.unreflectSpecial(rmethod, specialCaller);
+                target = lookup.in(specialCaller).unreflectSpecial(rmethod, specialCaller);
             else
-                target = lookup.unreflect(rmethod);
+                target = lookup.in(defc).unreflect(rmethod);
         } catch (NoAccessException ex) {
             noAccess = ex;
         }
@@ -737,7 +743,7 @@
         }
         Object[] argsMaybeWithSelf = randomArgs(paramsMaybeWithSelf);
         printCalled(target, name, argsMaybeWithSelf);
-        target.invokeVarargs(argsMaybeWithSelf);
+        target.invokeWithArguments(argsMaybeWithSelf);
         assertCalled(name, argsMaybeWithSelf);
         if (verbosity >= 1)
             System.out.print(':');
@@ -875,7 +881,7 @@
         if (isStatic)  expType = expType.dropParameterTypes(0, 1);
         MethodHandle mh = lookup.unreflectGetter(f);
         assertSame(mh.type(), expType);
-        assertEquals(mh.toString(), fname);
+        assertNameStringContains(mh, fname);
         HasFields fields = new HasFields();
         Object sawValue;
         Class<?> rtype = type;
@@ -947,7 +953,7 @@
             mh = lookup.findStaticSetter(fclass, fname, ftype);
         else  throw new InternalError();
         assertSame(mh.type(), expType);
-        assertEquals(mh.toString(), fname);
+        assertNameStringContains(mh, fname);
         HasFields fields = new HasFields();
         Object sawValue;
         Class<?> vtype = type;
@@ -1102,6 +1108,18 @@
         }
     }
 
+    static MethodHandle typeHandler2(MethodHandle target, MethodType newType) {
+        MethodType oldType = target.type();
+        int oldArity = oldType.parameterCount();
+        int newArity = newType.parameterCount();
+        if (newArity < oldArity)
+            return MethodHandles.insertArguments(target, oldArity, "OPTIONAL");
+        else if (newArity > oldArity)
+            return MethodHandles.dropArguments(target, oldArity-1, newType.parameterType(oldArity-1));
+        else
+            return target;  // attempt no further conversions
+    }
+
     @Test
     public void testConvertArguments() throws Throwable {
         if (CAN_SKIP_WORKING)  return;
@@ -1115,10 +1133,29 @@
     }
 
     void testConvert(MethodHandle id, Class<?> rtype, String name, Class<?>... params) throws Throwable {
-        testConvert(true, id, rtype, name, params);
+        testConvert(true, false, id, rtype, name, params);
+        testConvert(true, true,  id, rtype, name, params);
     }
 
-    void testConvert(boolean positive, MethodHandle id, Class<?> rtype, String name, Class<?>... params) throws Throwable {
+    @Test
+    public void testTypeHandler() throws Throwable {
+        MethodHandle id = Callee.ofType(1);
+        MethodHandle th2 = PRIVATE.findStatic(MethodHandlesTest.class, "typeHandler2",
+                               MethodType.methodType(MethodHandle.class, MethodHandle.class, MethodType.class));
+        MethodHandle id2 = id.withTypeHandler(th2);
+        testConvert(true,  false, id2, null, "id", Object.class);
+        testConvert(true,  true,  id2, null, "id", Object.class);
+        if (true)  return;  //FIXME
+        testConvert(true,  false, id2, null, "id", String.class);  // FIXME: throws WMT
+        testConvert(false, true,  id2, null, "id", String.class);  // FIXME: should not succeed
+        testConvert(false, false, id2, null, "id", Object.class, String.class); //FIXME: array[1] line 1164
+        testConvert(true,  true,  id2, null, "id", Object.class, String.class);
+        testConvert(false, false, id2, null, "id");
+        testConvert(true,  true,  id2, null, "id");
+    }
+
+    void testConvert(boolean positive, boolean useAsType,
+                     MethodHandle id, Class<?> rtype, String name, Class<?>... params) throws Throwable {
         countTest(positive);
         MethodType idType = id.type();
         if (rtype == null)  rtype = idType.returnType();
@@ -1135,7 +1172,7 @@
             if (src != dst)
                 convArgs[i] = castToWrapper(convArgs[i], dst);
         }
-        Object convResult = id.invokeVarargs(convArgs);
+        Object convResult = id.invokeWithArguments(convArgs);
         {
             Class<?> dst = newType.returnType();
             Class<?> src = idType.returnType();
@@ -1145,7 +1182,10 @@
         MethodHandle target = null;
         RuntimeException error = null;
         try {
-            target = MethodHandles.convertArguments(id, newType);
+            if (useAsType)
+                target = MethodHandles.convertArguments(id, newType);
+            else
+                target = id.asType(newType);
         } catch (RuntimeException ex) {
             error = ex;
         }
@@ -1157,7 +1197,7 @@
         if (!positive)  return; // negative test failed as expected
         assertEquals(newType, target.type());
         printCalled(target, id.toString(), args);
-        Object result = target.invokeVarargs(args);
+        Object result = target.invokeWithArguments(args);
         assertCalled(name, convArgs);
         assertEquals(convResult, result);
         if (verbosity >= 1)
@@ -1279,7 +1319,7 @@
         MethodType outType = MethodType.methodType(Object.class, permTypes);
         MethodHandle target = MethodHandles.convertArguments(ValueConversions.varargsList(outargs), outType);
         MethodHandle newTarget = MethodHandles.permuteArguments(target, inType, reorder);
-        Object result = newTarget.invokeVarargs(args);
+        Object result = newTarget.invokeWithArguments(args);
         Object expected = Arrays.asList(permArgs);
         assertEquals(expected, result);
     }
@@ -1311,7 +1351,7 @@
         Object[] args = randomArgs(target2.type().parameterArray());
         // make sure the target does what we think it does:
         if (pos == 0 && nargs < 5) {
-            Object[] check = (Object[]) target.invokeVarargs(args);
+            Object[] check = (Object[]) target.invokeWithArguments(args);
             assertArrayEquals(args, check);
             switch (nargs) {
                 case 0:
@@ -1342,7 +1382,7 @@
         } else {
             Object[] args1 = Arrays.copyOfRange(args, 0, pos+1);
             args1[pos] = Arrays.copyOfRange(args, pos, args.length);
-            returnValue = (Object[]) result.invokeVarargs(args1);
+            returnValue = (Object[]) result.invokeWithArguments(args1);
         }
         assertArrayEquals(args, returnValue);
     }
@@ -1379,7 +1419,7 @@
         if (verbosity >= 3)
             System.out.println("collect from "+Arrays.asList(args)+" ["+pos+".."+nargs+"]");
         MethodHandle result = MethodHandles.collectArguments(target, newType);
-        Object[] returnValue = (Object[]) result.invokeVarargs(args);
+        Object[] returnValue = (Object[]) result.invokeWithArguments(args);
 //        assertTrue(returnValue.length == pos+1 && returnValue[pos] instanceof Object[]);
 //        returnValue[pos] = Arrays.asList((Object[]) returnValue[pos]);
 //        collectedArgs[pos] = Arrays.asList((Object[]) collectedArgs[pos]);
@@ -1412,7 +1452,7 @@
         MethodHandle target2 = MethodHandles.insertArguments(target, pos,
                 (Object[]) argsToInsert.toArray());
         argsToInsert.clear();  // remove from argsToInsert
-        Object res2 = target2.invokeVarargs(argsToPass);
+        Object res2 = target2.invokeWithArguments(argsToPass);
         Object res2List = Arrays.asList((Object[])res2);
         if (verbosity >= 3)
             System.out.println("result: "+res2List);
@@ -1440,14 +1480,12 @@
         Object[] argsToPass = randomArgs(nargs, Object.class);
         if (verbosity >= 3)
             System.out.println("filter "+target+" at "+pos+" with "+filter);
-        MethodHandle[] filters = new MethodHandle[pos*2+1];
-        filters[pos] = filter;
-        MethodHandle target2 = MethodHandles.filterArguments(target, filters);
+        MethodHandle target2 = MethodHandles.filterArguments(target, pos, filter);
         // Simulate expected effect of filter on arglist:
         Object[] filteredArgs = argsToPass.clone();
         filteredArgs[pos] = filter.invokeExact(filteredArgs[pos]);
         List<Object> expected = Arrays.asList(filteredArgs);
-        Object result = target2.invokeVarargs(argsToPass);
+        Object result = target2.invokeWithArguments(argsToPass);
         if (verbosity >= 3)
             System.out.println("result: "+result);
         if (!expected.equals(result))
@@ -1482,9 +1520,9 @@
         List<Object> argsToFold = expected.subList(pos, pos + fold);
         if (verbosity >= 3)
             System.out.println("fold: "+argsToFold+" into "+target2);
-        Object foldedArgs = combine.invokeVarargs(argsToFold);
+        Object foldedArgs = combine.invokeWithArguments(argsToFold);
         argsToFold.add(0, foldedArgs);
-        Object result = target2.invokeVarargs(argsToPass);
+        Object result = target2.invokeWithArguments(argsToPass);
         if (verbosity >= 3)
             System.out.println("result: "+result);
         if (!expected.equals(result))
@@ -1516,7 +1554,7 @@
         for (int i = drop; i > 0; i--) {
             argsToDrop.add(pos, "blort#"+i);
         }
-        Object res2 = target2.invokeVarargs(argsToDrop);
+        Object res2 = target2.invokeWithArguments(argsToDrop);
         Object res2List = Arrays.asList((Object[])res2);
         //if (!resList.equals(res2List))
         //    System.out.println("*** fail at n/p/d = "+nargs+"/"+pos+"/"+drop+": "+argsToDrop+" => "+res2List);
@@ -1572,7 +1610,7 @@
         countTest();
         calledLog.clear();
         inv = MethodHandles.exactInvoker(type);
-        result = inv.invokeVarargs(targetPlusArgs);
+        result = inv.invokeWithArguments(targetPlusArgs);
         if (testRetCode)  assertEquals(code, result);
         assertCalled("invokee", args);
         // generic invoker
@@ -1598,7 +1636,7 @@
             assertCalled("invokee", args);
         }
         calledLog.clear();
-        result = inv.invokeVarargs(targetPlusArgs);
+        result = inv.invokeWithArguments(targetPlusArgs);
         if (testRetCode)  assertEquals(code, result);
         assertCalled("invokee", args);
         // varargs invoker #0
@@ -1640,17 +1678,29 @@
             List<Object> tailList = targetPlusVarArgs.subList(1+k, 1+nargs);
             Object[] tail = tailList.toArray();
             tailList.clear(); tailList.add(tail);
-            result = inv.invokeVarargs(targetPlusVarArgs);
+            result = inv.invokeWithArguments(targetPlusVarArgs);
             if (testRetCode)  assertEquals(code, result);
             assertCalled("invokee", args);
         }
+
         // dynamic invoker
         countTest();
-        CallSite site = new CallSite(MethodHandlesTest.class, "foo", type);
+        CallSite site = new CallSite(type);
         inv = MethodHandles.dynamicInvoker(site);
+
+        // see if we get the result of the original target:
+        try {
+            result = inv.invokeWithArguments(args);
+            assertTrue("should not reach here", false);
+        } catch (IllegalStateException ex) {
+            String msg = ex.getMessage();
+            assertTrue(msg, msg.contains("site"));
+        }
+
+        // set new target after invoker is created, to make sure we track target
         site.setTarget(target);
         calledLog.clear();
-        result = inv.invokeVarargs(args);
+        result = inv.invokeWithArguments(args);
         if (testRetCode)  assertEquals(code, result);
         assertCalled("invokee", args);
     }
@@ -1734,7 +1784,7 @@
             String willCall = (equals ? "targetIfEquals" : "fallbackIfNotEquals");
             if (verbosity >= 3)
                 System.out.println(logEntry(willCall, argList));
-            Object result = mh.invokeVarargs(argList);
+            Object result = mh.invokeWithArguments(argList);
             assertCalled(willCall, argList);
         }
     }
@@ -1776,7 +1826,7 @@
         //System.out.println("catching with "+target+" : "+throwOrReturn);
         Object[] args = randomArgs(nargs, Object.class);
         args[1] = (throwIt ? thrown : null);
-        Object returned = target.invokeVarargs(args);
+        Object returned = target.invokeWithArguments(args);
         //System.out.println("return from "+target+" : "+returned);
         if (!throwIt) {
             assertSame(args[0], returned);
@@ -1828,13 +1878,10 @@
         testCastFailure("unbox/return", 11000);
     }
 
-    static class Surprise implements MethodHandleProvider {
+    static class Surprise {
         public MethodHandle asMethodHandle() {
             return VALUE.bindTo(this);
         }
-        public MethodHandle asMethodHandle(MethodType type) {
-            return asMethodHandle().asType(type);
-        }
         Object value(Object x) {
             trace("value", x);
             if (boo != null)  return boo;
@@ -1896,8 +1943,8 @@
             }
             if (callee != null) {
                 callee = MethodHandles.convertArguments(callee, MethodType.genericMethodType(1));
-                surprise = MethodHandles.filterArguments(callee, surprise);
-                identity = MethodHandles.filterArguments(callee, identity);
+                surprise = MethodHandles.filterArguments(callee, 0, surprise);
+                identity = MethodHandles.filterArguments(callee, 0, identity);
             }
         }
         assertNotSame(mode, surprise, surprise0);
@@ -1949,7 +1996,7 @@
         assertEquals(mt, mh.type());
         assertEquals(Example.class, mh.type().returnType());
         args = randomArgs(mh.type().parameterArray());
-        mh.invokeVarargs(args);
+        mh.invokeWithArguments(args);
         assertCalled(name, args);
 
         // Try a virtual method.
@@ -1959,7 +2006,7 @@
         assertEquals(mt, mh.type().dropParameterTypes(0,1));
         assertTrue(mh.type().parameterList().contains(Example.class));
         args = randomArgs(mh.type().parameterArray());
-        mh.invokeVarargs(args);
+        mh.invokeWithArguments(args);
         assertCalled(name, args);
     }
 

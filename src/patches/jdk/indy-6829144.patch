6829144: JSR 292 JVM features need a provisional Java API
Summary: JSR 292 RI for invokedynamic, preview edition

diff --git a/src/share/classes/java/dyn/CallSite.java b/src/share/classes/java/dyn/CallSite.java
new file mode 100644
--- /dev/null
+++ b/src/share/classes/java/dyn/CallSite.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.dyn;
+
+import sun.dyn.util.BytecodeName;
+
+/**
+ * An <code>invokedynamic</code> call site, as reified to the bootstrap method.
+ * Every instance of a call site corresponds to a distinct instance
+ * of the <code>invokedynamic</code> instruction.
+ * Call sites have state, one reference word, called the <code>target</code>,
+ * and typed as a {@link MethodHandle}.  When this state is null (as it is
+ * initially) the call site is in the unlinked state.  Otherwise, it is said
+ * to be linked to its target.
+ * <p>
+ * When an unlinked call site is executed, a bootstrap routine is called
+ * to finish the execution of the call site, and optionally to link
+ * the call site.
+ * <p>
+ * @author John Rose, JSR 292 EG
+ */
+public class CallSite {
+    // Fields used only by the JVM.  Do not use or change.
+    private Object vmmethod;
+    int callerMID, callerBCI;  // supplied by the JVM
+
+    MethodHandle target;
+    final Object caller;  // usually a class
+    final String name;
+    final MethodType type;
+
+    public CallSite(Object caller, String name, MethodType type) {
+        this.caller = caller;
+        this.name = name;
+        this.type = type;
+    }
+
+    private static void privateInitializeCallSite(CallSite site, int callerMID, int callerBCI) {
+        site.callerMID = callerMID;
+        site.callerBCI = callerBCI;
+        if (site.target == null)
+            site.setTarget(site.initialTarget());
+    }
+
+    /**
+     * Just after a call site is created by a bootstrap method handle,
+     * if the target has not been initialized by the factory method itself,
+     * the method {@code initialTarget} is called to produce an initial
+     * non-null target.  (Live call sites must never have null targets.)
+     * <p>
+     * If the bootstrap method itself does not initialize the call site,
+     * this method must be overridden, because it just raises an
+     * {@code InvokeDynamicBootstrapError}.
+     */
+    protected MethodHandle initialTarget() {
+        throw new InvokeDynamicBootstrapError("target must be initialized before call site is linked: "+this);
+    }
+
+    /**
+     * Report the current linkage state of the call site.  (This is mutable.)
+     * The value is null if and only if the call site is currently unlinked.
+     * When a linked call site is invoked, the target method is used directly.
+     * When an unlinked call site is invoked, its bootstrap method receives
+     * the call, as if via {@link Linkage#bootstrapInvokeDynamic}.
+     * <p>
+     * The interactions of {@code getTarget} with memory are the same
+     * as of a read from an ordinary variable, such as an array element or a
+     * non-volatile, non-final field.
+     * <p>
+     * In particular, the current thread may choose to reuse the result
+     * of a previous read of the target from memory, and may fail to see
+     * a recent update to the target by another thread.
+     * @return the current linkage state of the call site
+     * @see #setTarget
+     */
+    public MethodHandle getTarget() {
+        return target;
+    }
+
+    /**
+     * Link or relink the call site, by setting its target method.
+     * <p>
+     * The interactions of {@code setTarget} with memory are the same
+     * as of a write to an ordinary variable, such as an array element or a
+     * non-volatile, non-final field.
+     * <p>
+     * In particular, unrelated threads may fail to see the updated target
+     * until they perform a read from memory.
+     * Stronger guarantees can be created by putting appropriate operations
+     * into the bootstrap method and/or the target methods used
+     * at any given call site.
+     * @param target the new target, or null if it is to be unlinked
+     * @throws WrongMethodTypeException if the new target is not null
+     *         and has a method type that differs from the call site's {@link #type}
+     */
+    public void setTarget(MethodHandle target) {
+        checkTarget(target);
+        this.target = target;
+    }
+
+    protected void checkTarget(MethodHandle target) {
+        if (!canSetTarget(target))
+            throw new WrongMethodTypeException(String.valueOf(target));
+    }
+
+    protected boolean canSetTarget(MethodHandle target) {
+        return (target != null && target.type() == type());
+    }
+
+    /**
+     * Report the class containing the call site.
+     * This is immutable static context.
+     * @return class containing the call site
+     */
+    public Class<?> callerClass() {
+        return (Class) caller;
+    }
+
+    /**
+     * Report the method name specified in the {@code invokedynamic} instruction.
+     * This is immutable static context.
+     * <p>
+     * Note that the name is a JVM bytecode name, and as such can be any
+     * non-empty string, as long as it does not contain certain "dangerous"
+     * characters such as slash {@code '/'} and dot {@code '.'}.
+     * See the Java Virtual Machine specification for more details.
+     * <p>
+     * Application such as a language runtimes may need to encode
+     * arbitrary program element names and other configuration information
+     * into the name.  A standard convention for doing this is
+     * <a href="http://blogs.sun.com/jrose/entry/symbolic_freedom_in_the_vm">specified here</a>.
+     * @return method name specified by the call site
+     */
+    public String name() {
+        return name;
+    }
+
+    /**
+     * Report the method name specified in the {@code invokedynamic} instruction,
+     * as a series of components, individually demangled according to
+     * the standard convention
+     * <a href="http://blogs.sun.com/jrose/entry/symbolic_freedom_in_the_vm">specified here</a>.
+     * <p>
+     * Non-empty runs of characters between dangerous characters are demangled.
+     * Each component is either a completely arbitrary demangled string,
+     * or else a character constant for a punctuation character, typically ':'.
+     * (In principle, the character can be any dangerous character that the
+     * JVM lets through in a method name, such as '$' or ']'.
+     * Runtime implementors are encouraged to use colon ':' for building
+     * structured names.)
+     * <p>
+     * In the common case where the name contains no dangerous characters,
+     * the result is an array whose only element array is the demangled
+     * name at the call site.  Such a demangled name can be any sequence
+     * of any number of any unicode characters.
+     * @return method name components specified by the call site
+     */
+    public Object[] nameComponents() {
+        return BytecodeName.parseBytecodeName(name);
+    }
+
+    /**
+     * Report the resolved result and parameter types of this call site,
+     * which are derived from its bytecode-level invocation descriptor.
+     * The types are packaged into a {@link MethodType}.
+     * Any linked target of this call site must be exactly this method type.
+     * This is immutable static context.
+     * @return method type specified by the call site
+     */
+    public MethodType type() {
+        return type;
+    }
+
+    @Override
+    public String toString() {
+        return "CallSite#"+hashCode()+"["+name+type+" => "+target+"]";
+    }
+}
diff --git a/src/share/classes/java/dyn/InvokeDynamic.java b/src/share/classes/java/dyn/InvokeDynamic.java
new file mode 100644
--- /dev/null
+++ b/src/share/classes/java/dyn/InvokeDynamic.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.dyn;
+
+/**
+ * Syntactic marker interface to request javac to emit an {@code invokedynamic} instruction.
+ * <p>
+ * This type has no particular meaning as a class or interface supertype, and can never be instantiated.
+ * Logically, it denotes a source of all dynamically typed methods.
+ * @author John Rose, JSR 292 EG
+ */
+public final class InvokeDynamic {
+    private InvokeDynamic() { throw new InternalError(); }  // do not instantiate
+
+    // no statically defined static methods
+}
diff --git a/src/share/classes/java/dyn/InvokeDynamicBootstrapError.java b/src/share/classes/java/dyn/InvokeDynamicBootstrapError.java
new file mode 100644
--- /dev/null
+++ b/src/share/classes/java/dyn/InvokeDynamicBootstrapError.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.dyn;
+
+/**
+ * Thrown to indicate that an {@code invokedynamic} instruction has
+ * failed to find its bootstrap method, or the bootstrap method has
+ * failed to provide a call site with a non-null target.
+ * <p>
+ * The boostrap method must have been declared during a class's initialization
+ * by a call to {@link Linkage#registerBootstrapMethod}.
+ *
+ * @author John Rose, JSR 292 EG
+ */
+public class InvokeDynamicBootstrapError extends LinkageError {
+    /**
+     * Constructs a {@code InvokeDynamicBootstrapError} with no detail message.
+     */
+    public InvokeDynamicBootstrapError() {
+        super();
+    }
+
+    /**
+     * Constructs a {@code InvokeDynamicBootstrapError} with the specified
+     * detail message.
+     *
+     * @param s the detail message.
+     */
+    public InvokeDynamicBootstrapError(String s) {
+        super(s);
+    }
+}
diff --git a/src/share/classes/java/dyn/Linkage.java b/src/share/classes/java/dyn/Linkage.java
new file mode 100644
--- /dev/null
+++ b/src/share/classes/java/dyn/Linkage.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.dyn;
+
+import java.util.WeakHashMap;
+import sun.reflect.Reflection;
+import static sun.dyn.util.VerifyAccess.checkBootstrapPrivilege;
+
+/**
+ * Static methods which control the linkage of invokedynamic call sites.
+ * @author John Rose, JSR 292 EG
+ */
+public class Linkage {
+    private Linkage() {}  // do not instantiate
+
+    /**
+     * Register a bootstrap method for use for a given caller class.
+     * The method handle must be of a type equivalent to {@link Linkage#makeCallSite}.
+     * <p>
+     * The operation will fail with an exception if any of the following conditions hold:
+     * <ul>
+     * <li>The caller of this method is in a different package than the {@code callerClass},
+     *     and there is a security manager, and its {@code checkPermission} call throws
+     *     when passed {@link LinkagePermission}("registerBootstrapMethod",callerClass).
+     * <li>The given class already has a bootstrap method, either from an embedded
+     *     {@code BootstrapInvokeDynamic} classfile attribute, or from a previous
+     *     call to this method.
+     * <li>The given class is already fully initialized.
+     * <li>The given class is in the process of initialization, in another thread.
+     * </ul>
+     * Because of these rules, a class may install its own bootstrap method in
+     * a static initializer.
+     */
+    public static
+    void registerBootstrapMethod(Class callerClass, MethodHandle mh) {
+        Class callc = Reflection.getCallerClass(2);
+        checkBootstrapPrivilege(callc, callerClass, "registerBootstrapMethod");
+        checkBSM(mh);
+        synchronized (bootstrapMethods) {
+            if (bootstrapMethods.containsKey(callerClass))
+                throw new IllegalStateException("bootstrap method already declared in "+callerClass);
+            bootstrapMethods.put(callerClass, mh);
+        }
+    }
+
+    static void checkBSM(MethodHandle mh) {
+        if (mh == null)  throw new IllegalArgumentException("null bootstrap method");
+        if (mh.type() == OLD_BOOTSTRAP_METHOD_TYPE) // FIXME: delete at EDR/PFD
+            throw new WrongMethodTypeException("bootstrap method must be a CallSite factory");
+        if (mh.type() != BOOTSTRAP_METHOD_TYPE)
+            throw new WrongMethodTypeException(mh.toString());
+    }
+
+    /**
+     * Simplified version of registerBootstrapMethod for self-registration,
+     * to be called from a static initializer.
+     * Finds a static method of type (CallSite, Object[]) -> Object in the
+     * given class, and installs it on the caller.
+     * @throws IllegalArgumentException if there is no such method
+     */
+    public static
+    void registerBootstrapMethod(Class<?> runtime, String name) {
+        Class callc = Reflection.getCallerClass(2);
+        MethodHandle bootstrapMethod =
+            MethodHandles.findStaticFrom(callc, runtime, name, BOOTSTRAP_METHOD_TYPE);
+        // FIXME: exception processing wrong here
+        checkBSM(bootstrapMethod);
+        Linkage.registerBootstrapMethod(callc, bootstrapMethod);
+    }
+
+    /**
+     * Simplified version of registerBootstrapMethod for self-registration,
+     * to be called from a static initializer.
+     * Finds a static method of type (CallSite, Object[]) -> Object in the
+     * caller's class, and installs it on the caller.
+     * @throws IllegalArgumentException if there is no such method
+     */
+    public static
+    void registerBootstrapMethod(String name) {
+        Class callc = Reflection.getCallerClass(2);
+        MethodHandle bootstrapMethod =
+            MethodHandles.findStaticFrom(callc, callc, name, BOOTSTRAP_METHOD_TYPE);
+        // FIXME: exception processing wrong here
+        checkBSM(bootstrapMethod);
+        Linkage.registerBootstrapMethod(callc, bootstrapMethod);
+    }
+
+    /**
+     * Report the bootstrap method registered for a given class.
+     * Returns null if the class has never yet registered a bootstrap method,
+     * or if the class has explicitly registered a null bootstrap method.
+     * Only callers privileged to set the bootstrap method may inquire
+     * about it, because a bootstrap method is potentially a back-door entry
+     * point into its class.
+     */
+    public static
+    MethodHandle getBootstrapMethod(Class callerClass) {
+        Class callc = Reflection.getCallerClass(2);
+        checkBootstrapPrivilege(callc, callerClass, "registerBootstrapMethod");
+        synchronized (bootstrapMethods) {
+            return bootstrapMethods.get(callerClass);
+        }
+    }
+
+    /** The type of any bootstrap method is a three-argument method
+     * {@code (Class<?>, String, MethodType)} returning a {@code CallSite}.
+     */
+    public static final MethodType BOOTSTRAP_METHOD_TYPE
+            = MethodType.make(CallSite.class,
+                              Class.class, String.class, MethodType.class);
+
+    private static final MethodType OLD_BOOTSTRAP_METHOD_TYPE
+            = MethodType.make(Object.class,
+                              CallSite.class, Object[].class);
+
+    private static final WeakHashMap<Class, MethodHandle> bootstrapMethods =
+            new WeakHashMap<Class, MethodHandle>();
+
+    /**
+     * Invalidate all <code>invokedynamic</code> call sites everywhere.
+     * <p>
+     * When this method returns, every <code>invokedynamic</code> instruction
+     * will invoke its bootstrap method on next call.
+     * <p>
+     * It is unspecified whether call sites already known to the Java
+     * code will continue to be associated with <code>invokedynamic</code>
+     * instructions.  If any call site is still so associated, its
+     * {@link CallSite#getTarget()} method is guaranteed to return null
+     * the invalidation operation completes.
+     * <p>
+     * Invalidation operations are likely to be slow.  Use them sparingly.
+     */
+    public static
+    Object invalidateAll() {
+        SecurityManager security = System.getSecurityManager();
+        if (security != null) {
+            security.checkPermission(new LinkagePermission("invalidateAll"));
+        }
+        throw new UnsupportedOperationException("NYI");
+    }
+
+    /**
+     * Invalidate all <code>invokedynamic</code> call sites associated
+     * with the given class.
+     * (These are exactly those sites which report the given class
+     * via the {@link CallSite#callerClass()} method.)
+     * <p>
+     * When this method returns, every matching <code>invokedynamic</code>
+     * instruction will invoke its bootstrap method on next call.
+     * <p>
+     * For additional semantics of call site invalidation,
+     * see {@link #invalidateAll()}.
+     */
+    public static
+    Object invalidateCallerClass(Class<?> callerClass) {
+        SecurityManager security = System.getSecurityManager();
+        if (security != null) {
+            security.checkPermission(new LinkagePermission("invalidateAll", callerClass));
+        }
+        throw new UnsupportedOperationException("NYI");
+    }
+
+    private static Object doNotBootstrap(CallSite site, Object... arguments) {
+        throw new UnsupportedOperationException("call site must not have null target: "+site);
+    }
+
+    private static final MethodHandle DO_NOT_BOOTSTRAP =
+            MethodHandles.Lookup.IMPL_LOOKUP.findStatic(Linkage.class, "doNotBootstrap",
+                OLD_BOOTSTRAP_METHOD_TYPE);
+
+    // Up-call from the JVM.  Obsolete.  FIXME: Delete from VM then from here.
+    static
+    MethodHandle findBootstrapMethod(Class callerClass, Class searchBootstrapClass) {
+        return DO_NOT_BOOTSTRAP;
+    }
+}
diff --git a/src/share/classes/java/dyn/LinkagePermission.java b/src/share/classes/java/dyn/LinkagePermission.java
new file mode 100644
--- /dev/null
+++ b/src/share/classes/java/dyn/LinkagePermission.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package java.dyn;
+
+import java.security.*;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.StringTokenizer;
+
+/**
+ * This class is for runtime permissions. A RuntimePermission
+ * contains a name (also referred to as a "target name") but
+ * no actions list; you either have the named permission
+ * or you don't.
+ *
+ * <P>
+ * The target name is the name of the runtime permission (see below). The
+ * naming convention follows the  hierarchical property naming convention.
+ * Also, an asterisk
+ * may appear at the end of the name, following a ".", or by itself, to
+ * signify a wildcard match. For example: "loadLibrary.*" or "*" is valid,
+ * "*loadLibrary" or "a*b" is not valid.
+ * <P>
+ * The following table lists all the possible RuntimePermission target names,
+ * and for each provides a description of what the permission allows
+ * and a discussion of the risks of granting code the permission.
+ * <P>
+ *
+ * <table border=1 cellpadding=5 summary="permission target name,
+ *  what the target allows,and associated risks">
+ * <tr>
+ * <th>Permission Target Name</th>
+ * <th>What the Permission Allows</th>
+ * <th>Risks of Allowing this Permission</th>
+ * </tr>
+ *
+ * <tr>
+ *   <td>registerBootstrapMethod.{class name}</td>
+ *   <td>Specifying a bootstrap method for invokedynamic, within a class of the given name</td>
+ *   <td>An attacker could attempt to attach a bootstrap method to a class which
+ *       has just been loaded, thus gaining control of its invokedynamic calls.</td>
+ * </tr>
+ *
+ * <tr>
+ *   <td>invalidateAll</td>
+ *   <td>Force the relinking of invokedynamic call sites everywhere.</td>
+ *   <td>This could allow an attacker to slow down the system, or perhaps surface timing bugs in a dynamic language implementations, by forcing redundant relinking operations.</td>
+ * </tr>
+ *
+ *
+ * <tr>
+ *   <td>invalidateCallerClass.{class name}</td>
+ *   <td>Force the relinking of invokedynamic call sites in the given class.</td>
+ *   <td>See {@code invalidateAll}.</td>
+ * </tr>
+ * </table>
+ *
+ * @see java.security.BasicPermission
+ * @see java.lang.SecurityManager
+ *
+ * @author John Rose, JSR 292 EG
+ */
+
+public final class LinkagePermission extends BasicPermission {
+    /**
+     * Create a new LinkagePermission with the given name.
+     * The name is the symbolic name of the LinkagePermission, such as
+     * "registerBootstrapMethod", "invalidateClass.*", etc. An asterisk
+     * may appear at the end of the name, following a ".", or by itself, to
+     * signify a wildcard match.
+     *
+     * @param name the name of the LinkagePermission
+     */
+    public LinkagePermission(String name) {
+        super(name);
+    }
+
+    /**
+     * Create a new LinkagePermission with the given name on the given class.
+     * Equivalent to {@code LinkagePermission(name+"."+clazz.getName())}.
+     *
+     * @param name the name of the LinkagePermission
+     * @param clazz the class affected by the permission
+     */
+    public LinkagePermission(String name, Class<?> clazz) {
+        super(name + "." + clazz.getName());
+    }
+}
diff --git a/src/share/classes/sun/dyn/CallSiteImpl.java b/src/share/classes/sun/dyn/CallSiteImpl.java
new file mode 100644
--- /dev/null
+++ b/src/share/classes/sun/dyn/CallSiteImpl.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.dyn;
+
+import java.dyn.*;
+
+/**
+ * The CallSite privately created by the JVM at every invokedynamic instruction.
+ * @author jrose
+ */
+class CallSiteImpl extends CallSite {
+    // Fields used only by the JVM.  Do not use or change.
+    private Object vmmethod;
+
+    // Values supplied by the JVM:
+    int callerMID, callerBCI;
+
+    private CallSiteImpl(Class<?> caller, String name, MethodType type) {
+        super(caller, name, type);
+    }
+
+    @Override
+    public void setTarget(MethodHandle mh) {
+        checkTarget(mh);
+        if (MethodHandleNatives.JVM_SUPPORT)
+            MethodHandleNatives.linkCallSite(this, (MethodHandle) mh);
+        else
+            super.setTarget(mh);
+    }
+
+    private static final MethodHandle PRIVATE_INITIALIZE_CALL_SITE =
+            MethodHandleImpl.IMPL_LOOKUP.findStatic(CallSite.class, "privateInitializeCallSite",
+                MethodType.make(void.class, CallSite.class, int.class, int.class));
+
+    // this is the up-call from the JVM:
+    static CallSite makeSite(Class<?> caller, String name, MethodType type,
+                             int callerMID, int callerBCI) {
+        MethodHandle bsm = Linkage.getBootstrapMethod(caller);
+        if (bsm == null)
+            throw new InvokeDynamicBootstrapError("class has no bootstrap method: "+caller);
+        CallSite site = bsm.<CallSite>invoke(caller, name, type);
+        if (site == null)
+            throw new InvokeDynamicBootstrapError("class bootstrap method failed to create a call site: "+caller);
+        PRIVATE_INITIALIZE_CALL_SITE.<void>invoke(site, callerMID, callerBCI);
+        return site;
+    }
+}
diff --git a/src/share/classes/sun/dyn/MethodHandleNatives.java b/src/share/classes/sun/dyn/MethodHandleNatives.java
--- a/src/share/classes/sun/dyn/MethodHandleNatives.java
+++ b/src/share/classes/sun/dyn/MethodHandleNatives.java
@@ -67,6 +67,9 @@
     /** Initialize a method type, once per form. */
     static native void init(MethodType self);
 
+    /** Tell the JVM that we need to change the target of an invokedynamic. */
+    static native void linkCallSite(CallSiteImpl site, MethodHandle target);
+
     /** Fetch the vmtarget field.
      *  It will be sanitized as necessary to avoid exposing non-Java references.
      *  This routine is for debugging and reflection.
diff --git a/src/share/classes/sun/dyn/empty/Empty.java b/src/share/classes/sun/dyn/empty/Empty.java
--- a/src/share/classes/sun/dyn/empty/Empty.java
+++ b/src/share/classes/sun/dyn/empty/Empty.java
@@ -1,4 +1,3 @@
-
 /*
  * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
diff --git a/src/share/classes/sun/dyn/util/BytecodeName.java b/src/share/classes/sun/dyn/util/BytecodeName.java
new file mode 100644
--- /dev/null
+++ b/src/share/classes/sun/dyn/util/BytecodeName.java
@@ -0,0 +1,711 @@
+/*
+ * Copyright 2007-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Sun designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Sun in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ */
+
+package sun.dyn.util;
+
+/**
+ * Utility routines for dealing with bytecode-level names.
+ * Includes universal mangling rules for the JVM.
+ *
+ * <h3>Avoiding Dangerous Characters </h3>
+ *
+ * <p>
+ * The JVM defines a very small set of characters which are illegal
+ * in name spellings.  We will slightly extend and regularize this set
+ * into a group of <cite>dangerous characters</cite>.
+ * These characters will then be replaced, in mangled names, by escape sequences.
+ * In addition, accidental escape sequences must be further escaped.
+ * Finally, a special prefix will be applied if and only if
+ * the mangling would otherwise fail to begin with the escape character.
+ * This happens to cover the corner case of the null string,
+ * and also clearly marks symbols which need demangling.
+ * </p>
+ * <p>
+ * Dangerous characters are the union of all characters forbidden
+ * or otherwise restricted by the JVM specification,
+ * plus their mates, if they are brackets
+ * (<code><big><b>[</b></big></code> and <code><big><b>]</b></big></code>,
+ * <code><big><b>&lt;</b></big></code> and <code><big><b>&gt;</b></big></code>),
+ * plus, arbitrarily, the colon character <code><big><b>:</b></big></code>.
+ * There is no distinction between type, method, and field names.
+ * This makes it easier to convert between mangled names of different
+ * types, since they do not need to be decoded (demangled).
+ * </p>
+ * <p>
+ * The escape character is backslash <code><big><b>\</b></big></code>
+ * (also known as reverse solidus).
+ * This character is, until now, unheard of in bytecode names,
+ * but traditional in the proposed role.
+ *
+ * </p>
+ * <h3> Replacement Characters </h3>
+ *
+ *
+ * <p>
+ * Every escape sequence is two characters
+ * (in fact, two UTF8 bytes) beginning with
+ * the escape character and followed by a
+ * <cite>replacement character</cite>.
+ * (Since the replacement character is never a backslash,
+ * iterated manglings do not double in size.)
+ * </p>
+ * <p>
+ * Each dangerous character has some rough visual similarity
+ * to its corresponding replacement character.
+ * This makes mangled symbols easier to recognize by sight.
+ * </p>
+ * <p>
+ * The dangerous characters are
+ * <code><big><b>/</b></big></code> (forward slash, used to delimit package components),
+ * <code><big><b>.</b></big></code> (dot, also a package delimiter),
+ * <code><big><b>;</b></big></code> (semicolon, used in signatures),
+ * <code><big><b>$</b></big></code> (dollar, used in inner classes and synthetic members),
+ * <code><big><b>&lt;</b></big></code> (left angle),
+ * <code><big><b>&gt;</b></big></code> (right angle),
+ * <code><big><b>[</b></big></code> (left square bracket, used in array types),
+ * <code><big><b>]</b></big></code> (right square bracket, reserved in this scheme for language use),
+ * and <code><big><b>:</b></big></code> (colon, reserved in this scheme for language use).
+ * Their replacements are, respectively,
+ * <code><big><b>|</b></big></code> (vertical bar),
+ * <code><big><b>,</b></big></code> (comma),
+ * <code><big><b>?</b></big></code> (question mark),
+ * <code><big><b>%</b></big></code> (percent),
+ * <code><big><b>^</b></big></code> (caret),
+ * <code><big><b>_</b></big></code> (underscore), and
+ * <code><big><b>{</b></big></code> (left curly bracket),
+ * <code><big><b>}</b></big></code> (right curly bracket),
+ * <code><big><b>!</b></big></code> (exclamation mark).
+ * In addition, the replacement character for the escape character itself is
+ * <code><big><b>-</b></big></code> (hyphen),
+ * and the replacement character for the null prefix is
+ * <code><big><b>=</b></big></code> (equal sign).
+ * </p>
+ * <p>
+ * An escape character <code><big><b>\</b></big></code>
+ * followed by any of these replacement characters
+ * is an escape sequence, and there are no other escape sequences.
+ * An equal sign is only part of an escape sequence
+ * if it is the second character in the whole string, following a backslash.
+ * Two consecutive backslashes do <em>not</em> form an escape sequence.
+ * </p>
+ * <p>
+ * Each escape sequence replaces a so-called <cite>original character</cite>
+ * which is either one of the dangerous characters or the escape character.
+ * A null prefix replaces an initial null string, not a character.
+ * </p>
+ * <p>
+ * All this implies that escape sequences cannot overlap and may be
+ * determined all at once for a whole string.  Note that a spelling
+ * string can contain <cite>accidental escapes</cite>, apparent escape
+ * sequences which must not be interpreted as manglings.
+ * These are disabled by replacing their leading backslash with an
+ * escape sequence (<code><big><b>\-</b></big></code>).  To mangle a string, three logical steps
+ * are required, though they may be carried out in one pass:
+ * </p>
+ * <ol>
+ *   <li>In each accidental escape, replace the backslash with an escape sequence
+ * (<code><big><b>\-</b></big></code>).</li>
+ *   <li>Replace each dangerous character with an escape sequence
+ * (<code><big><b>\|</b></big></code> for <code><big><b>/</b></big></code>, etc.).</li>
+ *   <li>If the first two steps introduced any change, <em>and</em>
+ * if the string does not already begin with a backslash, prepend a null prefix (<code><big><b>\=</b></big></code>).</li>
+ * </ol>
+ *
+ * To demangle a mangled string that begins with an escape,
+ * remove any null prefix, and then replace (in parallel)
+ * each escape sequence by its original character.
+ * <p>Spelling strings which contain accidental
+ * escapes <em>must</em> have them replaced, even if those
+ * strings do not contain dangerous characters.
+ * This restriction means that mangling a string always
+ * requires a scan of the string for escapes.
+ * But then, a scan would be required anyway,
+ * to check for dangerous characters.
+ *
+ * </p>
+ * <h3> Nice Properties </h3>
+ *
+ * <p>
+ * If a bytecode name does not contain any escape sequence,
+ * demangling is a no-op:  The string demangles to itself.
+ * Such a string is called <cite>self-mangling</cite>.
+ * Almost all strings are self-mangling.
+ * In practice, to demangle almost any name &ldquo;found in nature&rdquo;,
+ * simply verify that it does not begin with a backslash.
+ * </p>
+ * <p>
+ * Mangling is a one-to-one function, while demangling
+ * is a many-to-one function.
+ * A mangled string is defined as <cite>validly mangled</cite> if
+ * it is in fact the unique mangling of its spelling string.
+ * Three examples of invalidly mangled strings are <code><big><b>\=foo</b></big></code>,
+ * <code><big><b>\-bar</b></big></code>, and <code><big><b>baz\!</b></big></code>, which demangle to <code><big><b>foo</b></big></code>, <code><big><b>\bar</b></big></code>, and
+ * <code><big><b>baz\!</b></big></code>, but then remangle to <code><big><b>foo</b></big></code>, <code><big><b>\bar</b></big></code>, and <code><big><b>\=baz\-!</b></big></code>.
+ * If a language back-end or runtime is using mangled names,
+ * it should never present an invalidly mangled bytecode
+ * name to the JVM.  If the runtime encounters one,
+ * it should also report an error, since such an occurrence
+ * probably indicates a bug in name encoding which
+ * will lead to errors in linkage.
+ * However, this note does not propose that the JVM verifier
+ * detect invalidly mangled names.
+ * </p>
+ * <p>
+ * As a result of these rules, it is a simple matter to
+ * compute validly mangled substrings and concatenations
+ * of validly mangled strings, and (with a little care)
+ * these correspond to corresponding operations on their
+ * spelling strings.
+ * </p>
+ * <ul>
+ *   <li>Any prefix of a validly mangled string is also validly mangled,
+ * although a null prefix may need to be removed.</li>
+ *   <li>Any suffix of a validly mangled string is also validly mangled,
+ * although a null prefix may need to be added.</li>
+ *   <li>Two validly mangled strings, when concatenated,
+ * are also validly mangled, although any null prefix
+ * must be removed from the second string,
+ * and a trailing backslash on the first string may need escaping,
+ * if it would participate in an accidental escape when followed
+ * by the first character of the second string.</li>
+ * </ul>
+ * <p>If languages that include non-Java symbol spellings use this
+ * mangling convention, they will enjoy the following advantages:
+ * </p>
+ * <ul>
+ *   <li>They can interoperate via symbols they share in common.</li>
+ *   <li>Low-level tools, such as backtrace printers, will have readable displays.</li>
+ *   <li>Future JVM and language extensions can safely use the dangerous characters
+ * for structuring symbols, but will never interfere with valid spellings.</li>
+ *   <li>Runtimes and compilers can use standard libraries for mangling and demangling.</li>
+ *   <li>Occasional transliterations and name composition will be simple and regular,
+ * for classes, methods, and fields.</li>
+ *   <li>Bytecode names will continue to be compact.
+ * When mangled, spellings will at most double in length, either in
+ * UTF8 or UTF16 format, and most will not change at all.</li>
+ * </ul>
+ *
+ *
+ * <h3> Suggestions for Human Readable Presentations </h3>
+ *
+ *
+ * <p>
+ * For human readable displays of symbols,
+ * it will be better to present a string-like quoted
+ * representation of the spelling, because JVM users
+ * are generally familiar with such tokens.
+ * We suggest using single or double quotes before and after
+ * mangled symbols which are not valid Java identifiers,
+ * with quotes, backslashes, and non-printing characters
+ * escaped as if for literals in the Java language.
+ * </p>
+ * <p>
+ * For example, an HTML-like spelling
+ * <code><big><b>&lt;pre&gt;</b></big></code> mangles to
+ * <code><big><b>\^pre\_</b></big></code> and could
+ * display more cleanly as
+ * <code><big><b>'&lt;pre&gt;'</b></big></code>,
+ * with the quotes included.
+ * Such string-like conventions are <em>not</em> suitable
+ * for mangled bytecode names, in part because
+ * dangerous characters must be eliminated, rather
+ * than just quoted.  Otherwise internally structured
+ * strings like package prefixes and method signatures
+ * could not be reliably parsed.
+ * </p>
+ * <p>
+ * In such human-readable displays, invalidly mangled
+ * names should <em>not</em> be demangled and quoted,
+ * for this would be misleading.  Likewise, JVM symbols
+ * which contain dangerous characters (like dots in field
+ * names or brackets in method names) should not be
+ * simply quoted.  The bytecode names
+ * <code><big><b>\=phase\,1</b></big></code> and
+ * <code><big><b>phase.1</b></big></code> are distinct,
+ * and in demangled displays they should be presented as
+ * <code><big><b>'phase.1'</b></big></code> and something like
+ * <code><big><b>'phase'.1</b></big></code>, respectively.
+ * </p>
+ *
+ * @author John Rose
+ * @version 1.2, 02/06/2008
+ * @see http://blogs.sun.com/jrose/entry/symbolic_freedom_in_the_vm
+ */
+public class BytecodeName {
+    private BytecodeName() { }  // static only class
+
+    /** Given a source name, produce the corresponding bytecode name.
+     * The source name should not be qualified, because any syntactic
+     * markers (dots, slashes, dollar signs, colons, etc.) will be mangled.
+     * @param s the source name
+     * @return a valid bytecode name which represents the source name
+     */
+    public static String toBytecodeName(String s) {
+        String bn = mangle(s);
+        assert((Object)bn == s || looksMangled(bn)) : bn;
+        assert(s.equals(toSourceName(bn))) : s;
+        return bn;
+    }
+
+    /** Given an unqualified bytecode name, produce the corresponding source name.
+     * The bytecode name must not contain dangerous characters.
+     * In particular, it must not be qualified or segmented by colon {@code ':'}.
+     * @param s the bytecode name
+     * @return the source name, which may possibly have unsafe characters
+     * @throws IllegalArgumentException if the bytecode name is not {@link #isSafeBytecodeName safe}
+     * @see #isSafeBytecodeName(java.lang.String)
+     */
+    public static String toSourceName(String s) {
+        checkSafeBytecodeName(s);
+        String sn = s;
+        if (looksMangled(s)) {
+            sn = demangle(s);
+            assert(s.equals(mangle(sn))) : s+" => "+sn+" => "+mangle(sn);
+        }
+        return sn;
+    }
+
+    /**
+     * Given a bytecode name from a classfile, separate it into
+     * components delimited by dangerous characters.
+     * Each resulting array element will be either a dangerous character,
+     * or else a safe bytecode name.
+     * (The safe name might possibly be mangled to hide further dangerous characters.)
+     * For example, the qualified class name {@code java/lang/String}
+     * will be parsed into the array {@code {"java", '/', "lang", '/', "String"}}.
+     * The name {@code &lt;init&gt;} will be parsed into { '&lt;', "init", '&gt;'}}
+     * The name {@code foo/bar$:baz} will be parsed into
+     * {@code {"foo", '/', "bar", '$', ':', "baz"}}.
+     */
+    public static Object[] parseBytecodeName(String s) {
+        int slen = s.length();
+        Object[] res = null;
+        for (int pass = 0; pass <= 1; pass++) {
+            int fillp = 0;
+            int lasti = 0;
+            for (int i = 0; i <= slen; i++) {
+                int whichDC = -1;
+                if (i < slen) {
+                    whichDC = DANGEROUS_CHARS.indexOf(s.charAt(i));
+                    if (whichDC < DANGEROUS_CHAR_FIRST_INDEX)  continue;
+                }
+                // got to end of string or next dangerous char
+                if (lasti < i) {
+                    // normal component
+                    if (pass != 0)
+                        res[fillp] = s.substring(lasti, i);
+                    fillp++;
+                    lasti = i+1;
+                }
+                if (whichDC >= DANGEROUS_CHAR_FIRST_INDEX) {
+                    if (pass != 0)
+                        res[fillp] = DANGEROUS_CHARS_CA[whichDC];
+                    fillp++;
+                }
+            }
+            if (pass != 0)  break;
+            // between passes, build the result array
+            res = new String[fillp];
+            if (fillp <= 1) {
+                if (fillp != 0)  res[0] = s;
+                break;
+            }
+        }
+        return res;
+    }
+
+    /**
+     * Given a series of components, create a bytecode name for a classfile.
+     * This is the inverse of {@link #parseBytecodeName(java.lang.String)}.
+     * Each component must either be an interned one-character string of
+     * a dangerous character, or else a safe bytecode name.
+     * @param components a series of name components
+     * @return the concatenation of all components
+     * @throws IllegalArgumentException if any component contains an unsafe
+     *          character, and is not an interned one-character string
+     * @throws NullPointerException if any component is null
+     */
+    public static String unparseBytecodeName(Object[] components) {
+        for (Object c : components) {
+            if (c instanceof String)
+                checkSafeBytecodeName((String) c);  // may fail
+        }
+        return appendAll(components);
+    }
+    private static String appendAll(Object[] components) {
+        if (components.length <= 1) {
+            if (components.length == 1) {
+                return String.valueOf(components[0]);
+            }
+            return "";
+        }
+        int slen = 0;
+        for (Object c : components) {
+            if (c instanceof String)
+                slen += String.valueOf(c).length();
+            else
+                slen += 1;
+        }
+        StringBuilder sb = new StringBuilder(slen);
+        for (Object c : components) {
+            sb.append(c);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Given a bytecode name, produce the corresponding display name.
+     * This is the source name, plus quotes if needed.
+     * If the bytecode name contains dangerous characters,
+     * assume that they are being used as punctuation,
+     * and pass them through unchanged.
+     * @param s the original bytecode name (which may be qualified)
+     * @return a human-readable presentation
+     */
+    public static String toDisplayName(String s) {
+        Object[] components = parseBytecodeName(s);
+        for (int i = 0; i < components.length; i++) {
+            if (!(components[i] instanceof String))
+                continue;
+            String c = (String) components[i];
+            // pretty up the name by demangling it
+            String sn = toSourceName(c);
+            if ((Object)sn != c || !isJavaIdent(sn)) {
+                components[i] = quoteDisplay(sn);
+            }
+        }
+        return appendAll(components);
+    }
+    private static boolean isJavaIdent(String s) {
+        int slen = s.length();
+        if (slen == 0)  return false;
+        if (!Character.isUnicodeIdentifierStart(s.charAt(0)))
+            return false;
+        for (int i = 1; i < slen; i++) {
+            if (!Character.isUnicodeIdentifierPart(s.charAt(0)))
+                return false;
+        }
+        return true;
+    }
+    private static String quoteDisplay(String s) {
+        // TO DO:  Replace wierd characters in s by C-style escapes.
+        return "'"+s.replaceAll("['\\\\]", "\\\\$0")+"'";
+    }
+
+    private static void checkSafeBytecodeName(String s)
+            throws IllegalArgumentException {
+        if (!isSafeBytecodeName(s)) {
+            throw new IllegalArgumentException(s);
+        }
+    }
+
+    /**
+     * Report whether a simple name is safe as a bytecode name.
+     * Such names are acceptable in class files as class, method, and field names.
+     * Additionally, they are free of "dangerous" characters, even if those
+     * characters are legal in some (or all) names in class files.
+     * @param s the proposed bytecode name
+     * @return true if the name is non-empty and all of its characters are safe
+     */
+    public static boolean isSafeBytecodeName(String s) {
+        if (s.length() == 0)  return false;
+        // check occurrences of each DANGEROUS char
+        for (char xc : DANGEROUS_CHARS_A) {
+            if (xc == ESCAPE_C)  continue;  // not really that dangerous
+            if (s.indexOf(xc) >= 0)  return false;
+        }
+        return true;
+    }
+
+    /**
+     * Report whether a character is safe in a bytecode name.
+     * This is true of any unicode character except the following
+     * <em>dangerous characters</em>: {@code ".;:$[]<>/"}.
+     * @param s the proposed character
+     * @return true if the character is safe to use in classfiles
+     */
+    public static boolean isSafeBytecodeChar(char c) {
+        return DANGEROUS_CHARS.indexOf(c) < DANGEROUS_CHAR_FIRST_INDEX;
+    }
+
+    private static boolean looksMangled(String s) {
+        return s.charAt(0) == ESCAPE_C;
+    }
+
+    private static String mangle(String s) {
+        if (s.length() == 0)
+            return NULL_ESCAPE;
+
+        // build this lazily, when we first need an escape:
+        StringBuilder sb = null;
+
+        for (int i = 0, slen = s.length(); i < slen; i++) {
+            char c = s.charAt(i);
+
+            boolean needEscape = false;
+            if (c == ESCAPE_C) {
+                if (i+1 < slen) {
+                    char c1 = s.charAt(i+1);
+                    if ((i == 0 && c1 == NULL_ESCAPE_C)
+                        || c1 != originalOfReplacement(c1)) {
+                        // an accidental escape
+                        needEscape = true;
+                    }
+                }
+            } else {
+                needEscape = isDangerous(c);
+            }
+
+            if (!needEscape) {
+                if (sb != null)  sb.append(c);
+                continue;
+            }
+
+            // build sb if this is the first escape
+            if (sb == null) {
+                sb = new StringBuilder(s.length()+10);
+                // mangled names must begin with a backslash:
+                if (s.charAt(0) != ESCAPE_C && i > 0)
+                    sb.append(NULL_ESCAPE);
+                // append the string so far, which is unremarkable:
+                sb.append(s.substring(0, i));
+            }
+
+            // rewrite \ to \-, / to \|, etc.
+            sb.append(ESCAPE_C);
+            sb.append(replacementOf(c));
+        }
+
+        if (sb != null)   return sb.toString();
+
+        return s;
+    }
+
+    private static String demangle(String s) {
+        // build this lazily, when we first meet an escape:
+        StringBuilder sb = null;
+
+        int stringStart = 0;
+        if (s.startsWith(NULL_ESCAPE))
+            stringStart = 2;
+
+        for (int i = stringStart, slen = s.length(); i < slen; i++) {
+            char c = s.charAt(i);
+
+            if (c == ESCAPE_C && i+1 < slen) {
+                // might be an escape sequence
+                char rc = s.charAt(i+1);
+                char oc = originalOfReplacement(rc);
+                if (oc != rc) {
+                    // build sb if this is the first escape
+                    if (sb == null) {
+                        sb = new StringBuilder(s.length());
+                        // append the string so far, which is unremarkable:
+                        sb.append(s.substring(stringStart, i));
+                    }
+                    ++i;  // skip both characters
+                    c = oc;
+                }
+            }
+
+            if (sb != null)
+                sb.append(c);
+        }
+
+        if (sb != null)   return sb.toString();
+
+        return s.substring(stringStart);
+    }
+
+    static char ESCAPE_C = '\\';
+    // empty escape sequence to avoid a null name or illegal prefix
+    static char NULL_ESCAPE_C = '=';
+    static String NULL_ESCAPE = ESCAPE_C+""+NULL_ESCAPE_C;
+
+    static final String DANGEROUS_CHARS   = "\\/.;:$[]<>"; // \\ must be first
+    static final String REPLACEMENT_CHARS =  "-|,?!%{}^_";
+    static final int DANGEROUS_CHAR_FIRST_INDEX = 1; // index after \\
+    static char[] DANGEROUS_CHARS_A   = DANGEROUS_CHARS.toCharArray();
+    static char[] REPLACEMENT_CHARS_A = REPLACEMENT_CHARS.toCharArray();
+    static final Character[] DANGEROUS_CHARS_CA;
+    static {
+        Character[] dcca = new Character[DANGEROUS_CHARS.length()];
+        for (int i = 0; i < dcca.length; i++)
+            dcca[i] = Character.valueOf(DANGEROUS_CHARS.charAt(i));
+        DANGEROUS_CHARS_CA = dcca;
+    }
+
+    static final long[] SPECIAL_BITMAP = new long[2];  // 128 bits
+    static {
+        String SPECIAL = DANGEROUS_CHARS + REPLACEMENT_CHARS;
+        //System.out.println("SPECIAL = "+SPECIAL);
+        for (char c : SPECIAL.toCharArray()) {
+            SPECIAL_BITMAP[c >>> 6] |= 1L << c;
+        }
+    }
+    static boolean isSpecial(char c) {
+        if ((c >>> 6) < SPECIAL_BITMAP.length)
+            return ((SPECIAL_BITMAP[c >>> 6] >> c) & 1) != 0;
+        else
+            return false;
+    }
+    static char replacementOf(char c) {
+        if (!isSpecial(c))  return c;
+        int i = DANGEROUS_CHARS.indexOf(c);
+        if (i < 0)  return c;
+        return REPLACEMENT_CHARS.charAt(i);
+    }
+    static char originalOfReplacement(char c) {
+        if (!isSpecial(c))  return c;
+        int i = REPLACEMENT_CHARS.indexOf(c);
+        if (i < 0)  return c;
+        return DANGEROUS_CHARS.charAt(i);
+    }
+    static boolean isDangerous(char c) {
+        if (!isSpecial(c))  return false;
+        return (DANGEROUS_CHARS.indexOf(c) >= DANGEROUS_CHAR_FIRST_INDEX);
+    }
+    static int indexOfDangerousChar(String s, int from) {
+        for (int i = from, slen = s.length(); i < slen; i++) {
+            if (isDangerous(s.charAt(i)))
+                return i;
+        }
+        return -1;
+    }
+    static int lastIndexOfDangerousChar(String s, int from) {
+        for (int i = Math.min(from, s.length()-1); i >= 0; i--) {
+            if (isDangerous(s.charAt(i)))
+                return i;
+        }
+        return -1;
+    }
+
+    // test driver
+    static void main(String[] av) {
+        // If verbose is enabled, quietly check everything.
+        // Otherwise, print the output for the user to check.
+        boolean verbose = false;
+
+        int maxlen = 0;
+
+        while (av.length > 0 && av[0].startsWith("-")) {
+            String flag = av[0].intern();
+            av = java.util.Arrays.copyOfRange(av, 1, av.length); // Java 1.6 or later
+            if (flag == "-" || flag == "--")  break;
+            else if (flag == "-q")
+                verbose = false;
+            else if (flag == "-v")
+                verbose = true;
+            else if (flag.startsWith("-l"))
+                maxlen = Integer.valueOf(flag.substring(2));
+            else
+                throw new Error("Illegal flag argument: "+flag);
+        }
+
+        if (maxlen == 0)
+            maxlen = (verbose ? 2 : 4);
+        if (verbose)  System.out.println("Note: maxlen = "+maxlen);
+
+        switch (av.length) {
+        case 0: av = new String[] {
+                    DANGEROUS_CHARS.substring(0) +
+                    REPLACEMENT_CHARS.substring(0, 1) +
+                    NULL_ESCAPE + "x"
+                }; // and fall through:
+        case 1:
+            char[] cv = av[0].toCharArray();
+            av = new String[cv.length];
+            int avp = 0;
+            for (char c : cv) {
+                String s = String.valueOf(c);
+                if (c == 'x')  s = "foo";  // tradition...
+                av[avp++] = s;
+            }
+        }
+        if (verbose)
+            System.out.println("Note: Verbose output mode enabled.  Use '-q' to suppress.");
+        Tester t = new Tester();
+        t.maxlen = maxlen;
+        t.verbose = verbose;
+        t.tokens = av;
+        t.test("", 0);
+    }
+
+    static class Tester {
+        boolean verbose;
+        int maxlen;
+        java.util.Map<String,String> map = new java.util.HashMap<String,String>();
+        String[] tokens;
+
+        void test(String stringSoFar, int tokensSoFar) {
+            test(stringSoFar);
+            if (tokensSoFar <= maxlen) {
+                for (String token : tokens) {
+                    if (token.length() == 0)  continue;  // skip empty tokens
+                    if (stringSoFar.indexOf(token) != stringSoFar.lastIndexOf(token))
+                        continue;   // there are already two occs. of this token
+                    if (token.charAt(0) == ESCAPE_C && token.length() == 1 && maxlen < 4)
+                        test(stringSoFar+token, tokensSoFar);  // want lots of \'s
+                    else if (tokensSoFar < maxlen)
+                        test(stringSoFar+token, tokensSoFar+1);
+                }
+            }
+        }
+
+        void test(String s) {
+            // for small batches, do not test the null string
+            if (s.length() == 0 && maxlen >=1 && maxlen <= 2)  return;
+            String bn = testSourceName(s);
+            if (bn == null)  return;
+            if (bn == s) {
+                //if (verbose)  System.out.println(s+" == id");
+            } else {
+                if (verbose)  System.out.println(s+" => "+bn+" "+toDisplayName(bn));
+                String bnbn = testSourceName(bn);
+                if (bnbn == null)  return;
+                if (verbose)  System.out.println(bn+" => "+bnbn+" "+toDisplayName(bnbn));
+                /*
+                String bn3 = testSourceName(bnbn);
+                if (bn3 == null)  return;
+                if (verbose)  System.out.println(bnbn+" => "+bn3);
+                */
+            }
+        }
+
+        String testSourceName(String s) {
+            if (map.containsKey(s))  return null;
+            String bn = toBytecodeName(s);
+            map.put(s, bn);
+            String sn = toSourceName(bn);
+            if (!sn.equals(s)) {
+                String bad = (s+" => "+bn+" != "+sn);
+                if (!verbose)  throw new Error("Bad mangling: "+bad);
+                System.out.println("*** "+bad);
+                return null;
+            }
+            return bn;
+        }
+    }
+}
diff --git a/src/share/classes/sun/dyn/util/VerifyAccess.java b/src/share/classes/sun/dyn/util/VerifyAccess.java
--- a/src/share/classes/sun/dyn/util/VerifyAccess.java
+++ b/src/share/classes/sun/dyn/util/VerifyAccess.java
@@ -25,10 +25,9 @@
 
 package sun.dyn.util;
 
-import sun.dyn.MemberName;
-import java.lang.reflect.Method;
+import java.dyn.LinkagePermission;
 import java.lang.reflect.Modifier;
-import java.util.Arrays;
+import sun.dyn.Access;
 
 /**
  * This class centralizes information about the JVM's linkage access control.
@@ -96,7 +95,7 @@
     public static boolean isSamePackage(Class<?> class1, Class<?> class2) {
         if (class1 == class2)
             return true;
-        if (class1.getClassLoader() != class2.getClassLoader())
+        if (loadersAreRelated(class1.getClassLoader(), class2.getClassLoader()))
             return false;
         String name1 = class1.getName(), name2 = class2.getName();
         int dot = name1.lastIndexOf('.');
@@ -133,4 +132,38 @@
         return pkgmem;
     }
 
+    private static boolean loadersAreRelated(ClassLoader loader1, ClassLoader loader2) {
+        if (loader1 == loader2 || loader1 == null || loader2 == null) {
+            return true;
+        }
+        for (ClassLoader scan1 = loader1;
+                scan1 != null; scan1 = scan1.getParent()) {
+            if (scan1 == loader2)  return true;
+        }
+        for (ClassLoader scan2 = loader2;
+                scan2 != null; scan2 = scan2.getParent()) {
+            if (scan2 == loader1)  return true;
+        }
+        return false;
+    }
+
+    /**
+     * Ensure the requesting class have privileges to perform invokedynamic
+     * linkage operations on subjectClass.  True if requestingClass is
+     * Access.class (meaning the request originates from the JVM) or if the
+     * classes are in the same package and have consistent class loaders.
+     * (The subject class loader must be identical with or be a child of
+     * the requesting class loader.)
+     * @param requestingClass
+     * @param subjectClass
+     */
+    public static void checkBootstrapPrivilege(Class requestingClass, Class subjectClass,
+                                               String permissionName) {
+        if (requestingClass == Access.class)  return;
+        if (requestingClass == subjectClass)  return;
+        SecurityManager security = System.getSecurityManager();
+        if (security == null)  return;  // open season
+        if (isSamePackage(requestingClass, subjectClass))  return;
+        security.checkPermission(new LinkagePermission(permissionName, requestingClass));
+    }
 }
